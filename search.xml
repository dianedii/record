<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript基础知识笔记</title>
      <link href="/record/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/"/>
      <url>/record/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h3><p>本文基于<code>ES5</code>版本的<a href="https://wangdoc.com/javascript/"><code>JavaScript</code>教程</a>，阅读时整理的基于知识点结构的笔记。仅梳理了本人以往不清晰或者与其他编程语言有差异之处或该语言特点。作为一文流笔记以备之后检索使用。</p><h3 id="1-lable"><a href="#1-lable" class="headerlink" title="1.lable"></a>1.<code>lable</code></h3><p><code>JavaScript</code> 语言允许，语句的前面有标签<code>（label）</code>，相当于定位符，用于跳转到程序的任意位置，标签的格式如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">  语句</span><br></pre></td></tr></table></figure><p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。</p><p>标签通常与<code>break</code>语句和<code>continue</code>语句配合使用，跳出特定的循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">break</span> top;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;i=&#x27;</span> + i + <span class="string">&#x27;, j=&#x27;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// i=0, j=0</span></span><br><span class="line"><span class="comment">// i=0, j=1</span></span><br><span class="line"><span class="comment">// i=0, j=2</span></span><br><span class="line"><span class="comment">// i=1, j=0</span></span><br></pre></td></tr></table></figure><p>上面代码为一个双重循环区块，<code>break</code>命令后面加上了<code>top</code>标签（注意，<code>top</code>不用加引号），满足条件时，直接跳出双层循环。如果<code>break</code>语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。</p><p>标签也可以用于跳出代码块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo: &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">break</span> foo;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;本行不会输出&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码执行到<code>break foo</code>，就会跳出区块。</p><p><code>continue</code>语句也可以与标签配合使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">continue</span> top;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;i=&#x27;</span> + i + <span class="string">&#x27;, j=&#x27;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// i=0, j=0</span></span><br><span class="line"><span class="comment">// i=0, j=1</span></span><br><span class="line"><span class="comment">// i=0, j=2</span></span><br><span class="line"><span class="comment">// i=1, j=0</span></span><br><span class="line"><span class="comment">// i=2, j=0</span></span><br><span class="line"><span class="comment">// i=2, j=1</span></span><br><span class="line"><span class="comment">// i=2, j=2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>continue</code>命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果<code>continue</code>语句后面不使用标签，则只能进入下一轮的内层循环。</p><hr><h3 id="2-布尔值"><a href="#2-布尔值" class="headerlink" title="2.布尔值"></a>2.布尔值</h3><p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code>。</p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>false</code></li><li><code>0</code></li><li><code>NaN</code></li><li><code>&quot;&quot;</code>或<code>&#39;&#39;</code>（空字符串）</li></ul><p>注意：空数组（<code>[]</code>）和空对象（<code>&#123;&#125;</code>）对应的布尔值，都是<code>true</code>。</p><hr><h3 id="3-数值"><a href="#3-数值" class="headerlink" title="3.数值"></a>3.数值</h3><ul><li><p>不要拿在<code>js</code>中直接做小数的数值运算</p></li><li><p><code>js</code>可以使用科学计数法表示数值，但不要用<code>parseInt()</code>去转化科学计数法表示的值，用<code>praseFloat()</code>。</p></li><li><p>其他进制表示：（八进制前缀不要只加<code>0</code>）</p><ul><li>八进制：有前缀<code>0o</code>或<code>0O</code>的数值，<del>或者有前导0</del>、且只用到<code>0-7</code>的八个阿拉伯数字的数值。</li><li>十六进制：有前缀<code>0x</code>或<code>0X</code>的数值。</li><li>二进制：有前缀<code>0b</code>或<code>0B</code>的数值。</li></ul></li><li><p>了解几个特殊值：（尤其是涉及特殊值的运算，结果要注意）</p><ul><li><code>NaN</code></li><li><code>+0 /-0</code></li><li><code>Infinity</code></li></ul></li><li><p>常见方法</p><p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">null</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="number">1</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>。</p></li></ul><hr><h3 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h3><ul><li><p>字符串可以被视为字符数组，但通过这种方式：字符串内部的单个字符无法改变和增删，这些操作会默默地失败</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">s[<span class="number">0</span>] <span class="comment">// &quot;h&quot;</span></span><br><span class="line">s[<span class="number">1</span>] <span class="comment">// &quot;e&quot;</span></span><br><span class="line">s[<span class="number">4</span>] <span class="comment">// &quot;o&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接对字符串使用方括号运算符</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>[<span class="number">1</span>] <span class="comment">// &quot;e&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> s[<span class="number">0</span>];</span><br><span class="line">s <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">s <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>JavaScript</code> 原生提供两个 Base64 相关的方法。注意这两个方法不适合非 <code>ASCII</code> 码的字符，会报错</p><ul><li><code>btoa()</code>：任意值转为 Base64 编码</li><li><code>atob()</code>：Base64 编码转为原来的值</li></ul><p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Encode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> btoa(<span class="built_in">encodeURIComponent</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Decode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(atob(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b64Encode(<span class="string">&#x27;你好&#x27;</span>) <span class="comment">// &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;</span></span><br><span class="line">b64Decode(<span class="string">&#x27;JUU0JUJEJUEwJUU1JUE1JUJE&#x27;</span>) <span class="comment">// &quot;你好&quot;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="5-对象"><a href="#5-对象" class="headerlink" title="5.对象"></a>5.对象</h3><ul><li>对象的引用</li></ul><p>​        如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"></span><br><span class="line">o1.a = <span class="number">1</span>;</span><br><span class="line">o2.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">o2.b = <span class="number">2</span>;</span><br><span class="line">o1.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>​        上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。</p><p>​        此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"></span><br><span class="line">o1 = <span class="number">1</span>;</span><br><span class="line">o2 <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>​        上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，然后<code>o1</code>的值变为1，这时不会对<code>o2</code>产生影响，<code>o2</code>还是指向原来的那个对象。</p><hr><h5 id="对象属性的操作"><a href="#对象属性的操作" class="headerlink" title="对象属性的操作"></a>对象属性的操作</h5><ul><li>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">key1</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">key2</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="comment">// [&#x27;key1&#x27;, &#x27;key2&#x27;]</span></span><br></pre></td></tr></table></figure><ul><li><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// [&quot;p&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br><span class="line">obj.p <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>​        上面代码中，<code>delete</code>命令删除对象<code>obj</code>的<code>p</code>属性。删除后，再读取<code>p</code>属性就会返回<code>undefined</code>，而且<code>Object.keys</code>方法的返回值也不再包括该属性。</p><p>​        注意，删除一个不存在的属性，<code>delete</code>不报错，而且返回<code>true</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>​        上面代码中，对象<code>obj</code>并没有<code>p</code>属性，但是<code>delete</code>命令照样返回<code>true</code>。因此，不能根据<code>delete</code>命令的结果，认定某个属性是存在的。</p><p>​        只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>​        上面代码之中，对象<code>obj</code>的<code>p</code>属性是不能删除的，所以<code>delete</code>命令返回<code>false</code>。</p><p>​        另外，需要注意的是，<code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.toString <span class="comment">// true</span></span><br><span class="line">obj.toString <span class="comment">// function toString() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><p>​        上面代码中，<code>toString</code>是对象<code>obj</code>继承的属性，虽然<code>delete</code>命令返回<code>true</code>，但该属性并没有被删除，依然存在。这个例子还说明，即使<code>delete</code>返回<code>true</code>，该属性依然可能读取到值。</p><hr><h5 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a><code>in</code>运算符</h5><p><code>in</code>运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回<code>true</code>，否则返回<code>false</code>。它的左边是一个字符串，表示属性名，右边是一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="string">&#x27;p&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>in</code>运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象<code>obj</code>本身并没有<code>toString</code>属性，但是<code>in</code>运算符会返回<code>true</code>，因为这个属性是继承的。</p><p>这时，可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h3><p>函数<code>A.name</code>可以获取函数名，<code>.length</code>可以获取函数参数个数，<code>toString</code>返回函数源码，有点反射内味儿了。</p><p>函数内部也能定义函数…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> f = foo();</span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>foo</code>内部声明了一个函数<code>bar</code>，<code>bar</code>的作用域绑定<code>foo</code>。当我们在<code>foo</code>外部取出<code>bar</code>执行时，变量<code>x</code>指向的是<code>foo</code>内部的<code>x</code>，而不是<code>foo</code>外部的<code>x</code>。正是这种机制，构成了下文要讲解的“闭包”现象。</p><hr><p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递<code>（passes by value）</code>。这意味着，在函数体内修改参数值，不会影响到函数外部。</p><p>但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递<code>（pass by reference）</code>。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。</p><p>注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。</p><hr><h5 id="javaScript中的闭包的理解"><a href="#javaScript中的闭包的理解" class="headerlink" title="javaScript中的闭包的理解"></a>javaScript中的闭包的理解</h5><p>闭包<code>（closure）</code>是 <code>JavaScript</code> 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p><p>理解闭包，首先必须理解变量作用域。前面提到，<code>JavaScript</code> 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line">f1() <span class="comment">// 999</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f1</code>可以读取全局变量<code>n</code>。</p><p>但是，正常情况下，函数外部无法读取函数内部声明的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: n is not defined(</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f1</code>内部声明的变量<code>n</code>，函数外是无法读取的。</p><p>如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="built_in">console</span>.log(n); <span class="comment">// 999</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f2</code>就在函数<code>f1</code>内部，这时<code>f1</code>内部的所有局部变量，对<code>f2</code>都是可见的。但是反过来就不行，<code>f2</code>内部的局部变量，对<code>f1</code>就是不可见的。这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>既然<code>f2</code>可以读取<code>f1</code>的局部变量，那么只要把<code>f2</code>作为返回值，我们不就可以在<code>f1</code>外部读取它的内部变量了吗！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f1</code>的返回值就是函数<code>f2</code>，由于<code>f2</code>可以读取<code>f1</code>的内部变量，所以就可以在外部获得<code>f1</code>的内部变量了。</p><p>闭包就是函数<code>f2</code>，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如<code>f2</code>记住了它诞生的环境<code>f1</code>，所以从<code>f2</code>可以得到<code>f1</code>的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><p>闭包的最大用处有两个，一个是可以读取外层函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrementor</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> start++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inc = createIncrementor(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">inc() <span class="comment">// 5</span></span><br><span class="line">inc() <span class="comment">// 6</span></span><br><span class="line">inc() <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>start</code>是函数<code>createIncrementor</code>的内部变量。通过闭包，<code>start</code>的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包<code>inc</code>使得函数<code>createIncrementor</code>的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。</p><p>为什么闭包能够返回外层函数的内部变量？原因是闭包（上例的<code>inc</code>）用到了外层变量（<code>start</code>），导致外层函数（<code>createIncrementor</code>）不能从内存释放。只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始终保存着当前值，供闭包读取。</p><p>闭包的另一个用处，是封装对象的私有属性和私有方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _age;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setAge</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    _age = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: name,</span><br><span class="line">    <span class="attr">getAge</span>: getAge,</span><br><span class="line">    <span class="attr">setAge</span>: setAge</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Person(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">p1.setAge(<span class="number">25</span>);</span><br><span class="line">p1.getAge() <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>Person</code>的内部变量<code>_age</code>，通过闭包<code>getAge</code>和<code>setAge</code>，变成了返回对象<code>p1</code>的私有变量。</p><p>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p><hr><p><code>eval</code>命令接受一个字符串作为参数，并将这个字符串当作语句执行。</p><p>总之，<code>eval</code>的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，一般不推荐使用。通常情况下，<code>eval</code>最常见的场合是解析 JSON 数据的字符串，不过正确的做法应该是使用原生的<code>JSON.parse</code>方法。</p><hr><h3 id="7-数组"><a href="#7-数组" class="headerlink" title="7.数组"></a>7.数组</h3><p><code>length</code>属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到<code>length</code>设置的值。</p><p>清空数组的一个有效方法，就是将<code>length</code>属性设为0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line">arr <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果人为设置<code>length</code>大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位 undefined。</p><p>值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响<code>length</code>属性的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;p&#x27;</span>] = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">a.length <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">2.1</span>] = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">a.length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><hr><p>检查某个键名是否存在的运算符<code>in</code>，适用于对象，也适用于数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> arr  <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span> <span class="keyword">in</span> arr <span class="comment">// true</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">in</span> arr <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码表明，数组存在键名为<code>2</code>的键。由于键名都是字符串，所以数值<code>2</code>会自动转成字符串。</p><hr><p><code>for...in</code>不仅会遍历数组所有的数字键，还会遍历非数字键。</p><p>所以，不推荐使用<code>for...in</code>遍历数组。</p><p>数组的遍历可以考虑使用普通<code>for</code>循环或<code>while</code>循环。</p><hr><p>使用<code>delete</code>命令删除一个数组成员，会形成空位，并且不会影响<code>length</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// undefined</span></span><br><span class="line">a.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码用<code>delete</code>命令删除了数组的第二个元素，这个位置就形成了空位，但是对<code>length</code>属性没有影响。也就是说，<code>length</code>属性不过滤空位。所以，使用<code>length</code>属性进行数组遍历，一定要非常小心。</p><p>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过。如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过。这就是说，空位就是数组没有这个元素，所以不会被遍历到，而<code>undefined</code>则表示数组有这个元素，值是<code>undefined</code>，所以遍历不会跳过。</p><hr><h5 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h5><p>如果一个对象的所有键名都是正整数或零，并且有<code>length</code>属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="number">0</span>] <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">obj[<span class="number">1</span>] <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line">obj.length <span class="comment">// 3</span></span><br><span class="line">obj.push(<span class="string">&#x27;d&#x27;</span>) <span class="comment">// TypeError: obj.push is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象<code>obj</code>没有数组的<code>push</code>方法，使用该方法就会报错。</p><p>“类似数组的对象”的根本特征，就是具有<code>length</code>属性。只要有<code>length</code>属性，就可以认为这个对象类似于数组。但是有一个问题，这种<code>length</code>属性不是动态值，不会随着成员的变化而变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[<span class="number">3</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">obj.length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>上面代码为对象<code>obj</code>添加了一个数字键，但是<code>length</code>属性没变。这就说明了<code>obj</code>不是数组。</p><p>典型的“类似数组的对象”是函数的<code>arguments</code>对象，以及大多数 DOM 元素集，还有字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">args</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">arguments</span> &#125;</span><br><span class="line"><span class="keyword">var</span> arrayLike = args(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">arrayLike[<span class="number">0</span>] <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">arrayLike.length <span class="comment">// 2</span></span><br><span class="line">arrayLike <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM元素集</span></span><br><span class="line"><span class="keyword">var</span> elts = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;h3&#x27;</span>);</span><br><span class="line">elts.length <span class="comment">// 3</span></span><br><span class="line">elts <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="number">1</span>] <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.length <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码包含三个例子，它们都不是数组（<code>instanceof</code>运算符返回<code>false</code>），但是看上去都非常像数组。</p><p>数组的<code>slice</code>方法可以将“类似数组的对象”变成真正的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure><p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过<code>call()</code>把数组的方法放到对象上面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index + <span class="string">&#x27; : &#x27;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(arrayLike, print);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>arrayLike</code>代表一个类似数组的对象，本来是不可以使用数组的<code>forEach()</code>方法的，但是通过<code>call()</code>，可以把<code>forEach()</code>嫁接到<code>arrayLike</code>上面调用。</p><p>下面的例子就是通过这种方法，在<code>arguments</code>对象上面调用<code>forEach</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span> (<span class="params">elem, i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i + <span class="string">&#x27;. &#x27;</span> + elem);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 for 循环</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i + <span class="string">&#x27;. &#x27;</span> + <span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串也是类似数组的对象，所以也可以用<code>Array.prototype.forEach.call</code>遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(<span class="string">&#x27;abc&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>注意，这种方法比直接使用数组原生的<code>forEach</code>要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的<code>forEach</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">chr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure><hr><h3 id="8-运算符"><a href="#8-运算符" class="headerlink" title="8.运算符"></a>8.运算符</h3><ul><li><strong>指数运算符</strong>：<code>x ** y</code></li><li><strong>余数运算符</strong>：<code>x % y</code></li></ul><hr><p>JavaScript 提供两种相等运算符：<code>==</code>和<code>===</code>。</p><p>简单说，它们的区别是相等运算符（<code>==</code>）比较两个值是否相等，严格相等运算符（<code>===</code>）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（<code>===</code>）直接返回<code>false</code>，而相等运算符（<code>==</code>）会将它们转换成同一个类型，再用严格相等运算符进行比较。</p><p><code>undefined</code>和<code>null</code>与自身严格相等。</p><hr><ul><li><strong>二进制或运算符</strong>（or）：符号为<code>|</code>，表示若两个二进制位都为<code>0</code>，则结果为<code>0</code>，否则为<code>1</code>。</li><li><strong>二进制与运算符</strong>（and）：符号为<code>&amp;</code>，表示若两个二进制位都为1，则结果为1，否则为0。</li><li><strong>二进制否运算符</strong>（not）：符号为<code>~</code>，表示对一个二进制位取反。</li><li><strong>异或运算符</strong>（xor）：符号为<code>^</code>，表示若两个二进制位不相同，则结果为1，否则为0。</li><li><strong>左移运算符</strong>（left shift）：符号为<code>&lt;&lt;</code>，详见下文解释。</li><li><strong>右移运算符</strong>（right shift）：符号为<code>&gt;&gt;</code>，详见下文解释。</li><li><strong>头部补零的右移运算符</strong>（zero filled right shift）：符号为<code>&gt;&gt;&gt;</code>，详见下文解释。</li></ul><hr><p><code>void</code>运算符的作用是执行一个表达式，然后不返回任何值，或者说返回<code>undefined</code>。</p><p>这个运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转。</p><p>请看下面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;f(); return false;&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>上面代码中，点击链接后，会先执行<code>onclick</code>的代码，由于<code>onclick</code>返回<code>false</code>，所以浏览器不会跳转到 example.com。</p><p><code>void</code>运算符可以取代上面的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript: void(f())&quot;</span>&gt;文字&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript: void(document.form.submit())&quot;</span>&gt;</span><br><span class="line">  提交</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><hr><p><code>Boolean()</code>函数可以将任意类型的值转为布尔值。</p><p>它的转换规则相对简单：除了以下五个值的转换结果为<code>false</code>，其他的值全部为<code>true</code>。</p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>0</code>（包含<code>-0</code>和<code>+0</code>）</li><li><code>NaN</code></li><li><code>&#39;&#39;</code>（空字符串）</li></ul><p>使用<code>Number()</code>函数，可以将任意类型的值转化成数值。 转不了的会变成NaN,同理也有<code>String()</code></p><hr><h3 id="9-错误机制处理"><a href="#9-错误机制处理" class="headerlink" title="9.错误机制处理"></a>9.错误机制处理</h3><p>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.message = message || <span class="string">&#x27;默认信息&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;UserError&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">UserError.prototype.constructor = UserError;</span><br></pre></td></tr></table></figure><p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> UserError(<span class="string">&#x27;这是自定义的错误！&#x27;</span>);</span><br></pre></td></tr></table></figure><hr><p><code>try catch</code>    语句内不管报错还是有<code>return</code>,只要有<code>finally</code>就一定会执行它。</p><hr><h3 id="10-js编程风格建议"><a href="#10-js编程风格建议" class="headerlink" title="10. js编程风格建议"></a>10. js编程风格建议</h3><p>JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。</p><p>因此，建议避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如<code>UPPER_CASE</code>。</p><p>建议不要使用相等运算符（<code>==</code>），只使用严格相等运算符（<code>===</code>）。</p><p>建议不要将不同目的的语句，合并成一行。</p><p>建议自增（<code>++</code>）和自减（<code>--</code>）运算符尽量使用<code>+=</code>和<code>-=</code>代替。</p><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAction</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> actions = &#123;</span><br><span class="line">    <span class="string">&#x27;hack&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;hack&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;slash&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;slash&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;run&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;run&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actions[action] !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Invalid action.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> actions[action]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议<code>switch...case</code>结构可以用对象结构代替。</p><hr><h3 id="11-console对象"><a href="#11-console对象" class="headerlink" title="11. console对象"></a>11. <code>console</code>对象</h3><p>打开开发者工具以后，顶端有多个面板。</p><ul><li><strong>Elements</strong>：查看网页的 HTML 源码和 CSS 代码。</li><li><strong>Resources</strong>：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。</li><li><strong>Network</strong>：查看网页的 HTTP 通信情况。</li><li><strong>Sources</strong>：查看网页加载的脚本源码。</li><li><strong>Timeline</strong>：查看各种网页行为随时间变化的情况。</li><li><strong>Performance</strong>：查看网页的性能情况，比如 CPU 和内存消耗。</li><li><strong>Console</strong>：用来运行 JavaScript 命令。</li></ul><hr><p><code>console.log</code>方法支持以下占位符，不同类型的数据必须使用对应的占位符。</p><ul><li><code>%s</code> 字符串</li><li><code>%d</code> 整数</li><li><code>%i</code> 整数</li><li><code>%f</code> 浮点数</li><li><code>%o</code> 对象的链接</li><li><code>%c</code> CSS 格式字符串</li></ul><p>使用<code>%c</code>占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="string">&#x27;%cThis text is styled!&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;color: red; background: yellow; font-size: 24px;&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><p>对于某些复合类型的数据，<code>console.table</code>方法可以将其转为表格显示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;JavaScript&quot;</span>, <span class="attr">fileExtension</span>: <span class="string">&quot;.js&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;TypeScript&quot;</span>, <span class="attr">fileExtension</span>: <span class="string">&quot;.ts&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;CoffeeScript&quot;</span>, <span class="attr">fileExtension</span>: <span class="string">&quot;.coffee&quot;</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table(languages);</span><br></pre></td></tr></table></figure><hr><p><code>console.count</code>方法用于计数，输出它被调用了多少次。</p><p>该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.count(user);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hi &quot;</span> + user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line"><span class="comment">// bob: 1</span></span><br><span class="line"><span class="comment">// &quot;hi bob&quot;</span></span><br><span class="line"></span><br><span class="line">greet(<span class="string">&#x27;alice&#x27;</span>)</span><br><span class="line"><span class="comment">// alice: 1</span></span><br><span class="line"><span class="comment">// &quot;hi alice&quot;</span></span><br><span class="line"></span><br><span class="line">greet(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line"><span class="comment">// bob: 2</span></span><br><span class="line"><span class="comment">// &quot;hi bob&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码根据参数的不同，显示<code>bob</code>执行了两次，<code>alice</code>执行了一次。</p><hr><p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</p><p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为<code>false</code>，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.assert(list.childNodes.length &lt; <span class="number">500</span>, <span class="string">&#x27;节点个数大于等于500&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。</p><hr><p><code>console.time()  console.timeEnd()</code>这两个方法用于计时，可以算出一个操作所花费的准确时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;Array initialize&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array= <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  array[i] = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;Array initialize&#x27;</span>);</span><br><span class="line"><span class="comment">// Array initialize: 1914.481ms</span></span><br></pre></td></tr></table></figure><p><code>time</code>方法表示计时开始，<code>timeEnd</code>方法表示计时结束。它们的参数是计时器的名称。调用<code>timeEnd</code>方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p><hr><p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.trace()</span><br><span class="line"><span class="comment">// console.trace()</span></span><br><span class="line"><span class="comment">//   (anonymous function)</span></span><br><span class="line"><span class="comment">//   InjectedScript._evaluateOn</span></span><br><span class="line"><span class="comment">//   InjectedScript._evaluateAndWrap</span></span><br><span class="line"><span class="comment">//   InjectedScript.evaluate</span></span><br></pre></td></tr></table></figure><p><code>console.clear</code>方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，<code>console.clear</code>方法将不起作用。</p><hr><h5 id="控制台常见命令"><a href="#控制台常见命令" class="headerlink" title="控制台常见命令"></a>控制台常见命令</h5><p>浏览器控制台中，除了使用<code>console</code>对象，还可以使用一些控制台自带的命令行方法。</p><p>（1）<code>$_</code></p><p><code>$_</code>属性返回上一个表达式的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">$_</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>（2）<code>$0</code> - <code>$4</code></p><p>控制台保存了最近5个在 Elements 面板选中的 DOM 元素，<code>$0</code>代表倒数第一个（最近一个），<code>$1</code>代表倒数第二个，以此类推直到<code>$4</code>。</p><p>（3）<code>$(selector)</code></p><p><code>$(selector)</code>返回第一个匹配的元素，等同于<code>document.querySelector()</code>。注意，如果页面脚本对<code>$</code>有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行<code>$(selector)</code>就会采用 jQuery 的实现，返回一个数组。</p><p>（4）<code>$$(selector)</code></p><p><code>$$(selector)</code>返回选中的 DOM 对象，等同于<code>document.querySelectorAll</code>。</p><p>（5）<code>$x(path)</code></p><p><code>$x(path)</code>方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$x(<span class="string">&quot;//p[a]&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面代码返回所有包含<code>a</code>元素的<code>p</code>元素。</p><p>（6）<code>inspect(object)</code></p><p><code>inspect(object)</code>方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在<code>Elements</code>面板中显示，比如<code>inspect(document)</code>会在 Elements 面板显示<code>document</code>元素。JavaScript 对象在控制台面板<code>Profiles</code>面板中显示，比如<code>inspect(window)</code>。</p><p>（7）<code>getEventListeners(object)</code></p><p><code>getEventListeners(object)</code>方法返回一个对象，该对象的成员为<code>object</code>登记了回调函数的各种事件（比如<code>click</code>或<code>keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数。</p><p>（8）<code>keys(object)</code>，<code>values(object)</code></p><p><code>keys(object)</code>方法返回一个数组，包含<code>object</code>的所有键名。</p><p><code>values(object)</code>方法返回一个数组，包含<code>object</code>的所有键值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="string">&#x27;p1&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;p2&#x27;</span>: <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">keys(o)</span><br><span class="line"><span class="comment">// [&quot;p1&quot;, &quot;p2&quot;]</span></span><br><span class="line">values(o)</span><br><span class="line"><span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure><p>（9）<code>monitorEvents(object[, events]) ，unmonitorEvents(object[, events])</code></p><p><code>monitorEvents(object[, events])</code>方法监听特定对象上发生的特定事件。事件发生时，会返回一个<code>Event</code>对象，包含该事件的相关信息。<code>unmonitorEvents</code>方法用于停止监听。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">monitorEvents(<span class="built_in">window</span>, <span class="string">&quot;resize&quot;</span>);</span><br><span class="line">monitorEvents(<span class="built_in">window</span>, [<span class="string">&quot;resize&quot;</span>, <span class="string">&quot;scroll&quot;</span>])</span><br></pre></td></tr></table></figure><p>上面代码分别表示单个事件和多个事件的监听方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">monitorEvents($<span class="number">0</span>, <span class="string">&#x27;mouse&#x27;</span>);</span><br><span class="line">unmonitorEvents($<span class="number">0</span>, <span class="string">&#x27;mousemove&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面代码表示如何停止监听。</p><p><code>monitorEvents</code>允许监听同一大类的事件。所有事件可以分成四个大类。</p><ul><li>mouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”</li><li>key：”keydown”, “keyup”, “keypress”, “textInput”</li><li>touch：”touchstart”, “touchmove”, “touchend”, “touchcancel”</li><li>control：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset”</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitorEvents($(&quot;#msg&quot;), &quot;key&quot;);</span><br></pre></td></tr></table></figure><p>上面代码表示监听所有<code>key</code>大类的事件。</p><p>（10）其他方法</p><p>命令行 API 还提供以下方法。</p><ul><li><code>clear()</code>：清除控制台的历史。</li><li><code>copy(object)</code>：复制特定 DOM 元素到剪贴板。</li><li><code>dir(object)</code>：显示特定对象的所有属性，是<code>console.dir</code>方法的别名。</li><li><code>dirxml(object)</code>：显示特定对象的 XML 形式，是<code>console.dirxml</code>方法的别名。</li></ul><hr><p><code>debugger</code>语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。如果没有除错工具，<code>debugger</code>语句不会产生任何结果，JavaScript 引擎自动跳过这一句。</p><p>Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">2</span>) <span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。</p><hr><h5 id="Js对象认识"><a href="#Js对象认识" class="headerlink" title="Js对象认识"></a><code>Js</code>对象认识</h5><p>所谓“静态方法”，是指部署在<code>Object</code>对象自身的方法。</p><p>写在对象的原型对象上的方法，就是”实例”方法，</p><hr><h3 id="12-Object对象"><a href="#12-Object对象" class="headerlink" title="12.Object对象"></a>12.<code>Object</code>对象</h3><p><code>Object</code>本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。</p><p>如果参数是原始类型的值，<code>Object</code>方法将其转为对应的包装对象的实例</p><p>如果<code>Object</code>方法的参数是一个对象，它总是返回该对象，即不用转换。</p><p>利用这一点，可以写一个判断变量是否为对象的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value === <span class="built_in">Object</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Object.keys</code>方法和<code>Object.getOwnPropertyNames</code>方法都用来遍历对象的属性。区别是前者返回的数组的成员都是该对象自身的（而不是继承的）所有属性名。后者包含了该对象自身的所有属性名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(a) <span class="comment">// [&quot;0&quot;, &quot;1&quot;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(a) <span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]</span></span><br></pre></td></tr></table></figure><p>一般情况下，几乎总是使用<code>Object.keys</code>方法，遍历对象的属性。</p><hr><p><code>Object</code>还有不少其他静态方法，将在后文逐一详细介绍。</p><p><strong>（1）对象属性模型的相关方法</strong></p><ul><li><code>Object.getOwnPropertyDescriptor()</code>：获取某个属性的描述对象。</li><li><code>Object.defineProperty()</code>：通过描述对象，定义某个属性。</li><li><code>Object.defineProperties()</code>：通过描述对象，定义多个属性。</li></ul><p><strong>（2）控制对象状态的方法</strong></p><ul><li><code>Object.preventExtensions()</code>：防止对象扩展。</li><li><code>Object.isExtensible()</code>：判断对象是否可扩展。</li><li><code>Object.seal()</code>：禁止对象配置。</li><li><code>Object.isSealed()</code>：判断一个对象是否可配置。</li><li><code>Object.freeze()</code>：冻结一个对象。</li><li><code>Object.isFrozen()</code>：判断一个对象是否被冻结。</li></ul><p><strong>（3）原型链相关方法</strong></p><ul><li><p><code>Object.create()</code>：该方法可以指定原型对象和属性，返回一个新的对象。(生成实例对象的常用方法是，使用<code>new</code>命令让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？该方法用来满足这种需求。)</p></li><li><p><code>Object.getPrototypeOf()</code>：获取对象的<code>Prototype</code>对象。</p></li><li><p><code>Object.setPrototypeOf</code>方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。</p><hr><h5 id="proto-说明"><a href="#proto-说明" class="headerlink" title="__proto__说明"></a><code>__proto__</code>说明</h5></li><li><p><code>Object.prototype.__proto__</code>实例对象的的这个属性（前后各两个下划线），返回该对象的原型。该属性可读写。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.__proto__ = p;</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj) === p <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码通过<code>__proto__</code>属性，将<code>p</code>对象设为<code>obj</code>对象的原型。</p><p>根据语言标准，<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用<code>Object.getPrototypeOf()</code>和<code>Object.setPrototypeOf()</code>，进行原型对象的读写操作。</p><p>原型链可以用<code>__proto__</code>很直观地表示。</p><hr><h5 id="Object-的实例方法"><a href="#Object-的实例方法" class="headerlink" title="Object 的实例方法"></a>Object 的实例方法</h5><p>除了静态方法，还有不少方法定义在<code>Object.prototype</code>对象。它们称为实例方法，所有<code>Object</code>的实例对象都继承了这些方法。</p><p><code>Object</code>实例对象的方法，主要有以下六个。</p><ul><li><code>Object.prototype.valueOf()</code>：返回当前对象对应的值。</li><li><code>Object.prototype.toString()</code>：返回当前对象对应的字符串形式。</li><li><code>Object.prototype.toLocaleString()</code>：返回当前对象对应的本地字符串形式。</li><li><code>Object.prototype.hasOwnProperty()</code>：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</li><li><code>Object.prototype.isPrototypeOf()</code>：判断当前对象是否为另一个对象的原型。</li><li><code>Object.prototype.propertyIsEnumerable()</code>：判断某个属性是否可枚举。</li></ul><hr><p><code>JavaScript</code>对于对象提供了六个默认属性，通过<code>getOwnPropertyDescriptor()</code>方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。以下是默认属性说明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="string">&#x27;a&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;p&#x27;</span>)</span><br></pre></td></tr></table></figure><p>（1）<code>value</code></p><p><code>value</code>是该属性的属性值，默认为<code>undefined</code>。</p><p>（2）<code>writable</code></p><p><code>writable</code>是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为<code>true</code>。</p><p>（3）<code>enumerable</code></p><p><code>enumerable</code>是一个布尔值，表示该属性是否可遍历，默认为<code>true</code>。如果设为<code>false</code>，会使得某些操作（比如<code>for...in</code>循环、<code>Object.keys()</code>、<code>JSON.stringify</code>方法）跳过该属性。</p><ul><li>如果对象的 JSON 格式输出要排除某些属性，就可以把这些属性的<code>enumerable</code>设为<code>false</code></li></ul><p>（4）<code>configurable</code></p><p><code>configurable</code>是一个布尔值，表示属性的可配置性，默认为<code>true</code>。如果设为<code>false</code>，将阻止某些操作改写属性描述对象，比如无法删除该属性，也不得改变各种元属性（<code>value</code>属性除外）。也就是说，<code>configurable</code>属性控制了属性描述对象的可写性。</p><p>（5）<code>get</code></p><p><code>get</code>是一个函数，表示该属性的取值函数（getter），默认为<code>undefined</code>。</p><p>（6）<code>set</code></p><p><code>set</code>是一个函数，表示该属性的存值函数（setter），默认为<code>undefined</code>。</p><hr><ul><li><p>一旦定义了取值函数<code>get</code>（或存值函数<code>set</code>），就不能将<code>writable</code>属性设为<code>true</code>，或者同时定义<code>value</code>属性，否则会报错。</p></li><li><p>这些属性也被称作元属性。通过<code>defineProperty()</code>方法进行修改</p></li><li><p><code>obj.p</code>定义了<code>get</code>和<code>set</code>属性。<code>obj.p</code>取值时，就会调用<code>get</code>；赋值时，就会调用<code>set</code>。以下是一般写法</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">p</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">p</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><ul><li><p><code>Object.getOwnPropertyNames</code>方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。</p></li><li><p>实例对象的<code>propertyIsEnumerable()</code>方法返回一个布尔值，用来判断某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回<code>false</code>。</p></li></ul><hr><h5 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h5><p>既需要拷贝自定义属性，也需要拷贝元属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extend = <span class="function"><span class="keyword">function</span> (<span class="params">to, <span class="keyword">from</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> property <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">from</span>.hasOwnProperty(property)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(</span><br><span class="line">      to,</span><br><span class="line">      property,</span><br><span class="line">      <span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="keyword">from</span>, property)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extend(&#123;&#125;, &#123; <span class="keyword">get</span> <span class="title">a</span>()&#123; <span class="keyword">return</span> <span class="number">1</span> &#125; &#125;)</span><br><span class="line"><span class="comment">// &#123; get a()&#123; return 1 &#125; &#125;)</span></span><br></pre></td></tr></table></figure><hr><p>控制对象的状态</p><p>有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是<code>Object.preventExtensions</code>，其次是<code>Object.seal</code>，最强的是<code>Object.freeze</code>。</p><ul><li><p><code>Object.preventExtensions</code>方法可以使得一个对象无法再添加新的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br></pre></td></tr></table></figure></li></ul><p>​        <code>Object.isExtensible</code>方法用于检查一个对象是否使用了<code>Object.preventExtensions</code>方法。也就是说，检查是否可以为一个对象添加属性。</p><ul><li><p><code>Object.seal</code>方法使得一个对象既无法添加新属性，也无法删除旧属性。<code>Object.seal</code>实质是把属性描述对象的<code>configurable</code>属性设为<code>false</code>，因此属性描述对象不再能改变了。<code>Object.seal</code>只是禁止新增或删除属性，并不影响修改某个属性的值。</p><p><code>Object.isSealed</code>方法用于检查一个对象是否使用了<code>Object.seal</code>方法。</p></li><li><p><code>Object.freeze</code>方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。(凯亚：冻结吧！)</p><p><code>Object.isFrozen</code>方法用于检查一个对象是否使用了<code>Object.freeze</code>方法。<code>Object.isFrozen</code>的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值。</p></li><li><p>漏洞</p><ul><li>漏洞一：虽然冻结了对象（Object），但是可以通过改变原型对象，来为对象增加属性。</li></ul><p>一种解决方案是，把<code>obj</code>的原型也冻结住。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.getPrototypeOf(obj);</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proto);</span><br></pre></td></tr></table></figure><ul><li>漏洞二：如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。比如说：<code>obj.bar</code>属性指向一个数组，<code>obj</code>对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的。</li></ul></li></ul><hr><h3 id="13-Array对象"><a href="#13-Array对象" class="headerlink" title="13.Array对象"></a>13.<code>Array</code>对象</h3><ul><li><code>push()</code> 末尾插数</li><li><code>pop()</code> 末尾减数，返回被减去的数对象</li></ul><p><code>push</code>和<code>pop</code>结合使用，就构成了“后进先出”的栈结构（stack）。</p><ul><li><code>shift()</code>头部插数</li><li><code>unshift()</code>头部减数，返回被减去的数对象</li></ul><p><code>push()</code>和<code>shift()</code>结合使用，就构成了“先进先出”的队列结构（queue）。</p><ul><li><p><code>join()</code>相当于<code>Java</code>的<code>spilt</code>,</p></li><li><p><code>concat()</code>方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;hello&#x27;</span>].concat([<span class="string">&#x27;world&#x27;</span>], [<span class="string">&#x27;!&#x27;</span>])</span><br><span class="line"><span class="comment">//concat也接受其他类型的值作为参数，添加到目标数组尾部。</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].concat(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>如果数组成员包括对象，<code>concat</code>方法返回当前数组的一个浅拷贝。</p></li><li><p><code>reverse</code>方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</p></li><li><p><code>arr.slice(start, end)</code>方法用于提取目标数组的一部分，返回一个新数组，原数组不变。如果<code>slice()</code>方法的参数是负数，则表示倒着数计算的位置。</p><p><code>slice()</code>方法的一个重要应用，是将类似数组的对象转为真正的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(&#123; <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>));</span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure><p>上面代码的参数都不是数组，但是通过<code>call</code>方法，在它们上面调用<code>slice()</code>方法，就可以把它们转为真正的数组。</p></li><li><p><code>splice()</code>方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(start, count, addElement1, addElement2, ...);</span><br></pre></td></tr></table></figure><p><code>splice</code>的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。相同的，起始位置如果是负数，就表示从倒数位置开始删除。</p><ul><li>如果只是单纯地插入元素，<code>splice</code>方法的第二个参数可以设为<code>0</code>。</li><li>如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</li></ul></li><li><p><code>sort</code>方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</p><p>如果想让<code>sort</code>方法按照自定义方式排序，可以传入一个函数作为参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10111</span>, <span class="number">1101</span>, <span class="number">111</span>].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [111, 1101, 10111]</span></span><br></pre></td></tr></table></figure></li><li><p><code>map()</code>方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</p><p><code>map()</code>方法接受一个函数作为参数。该函数调用时，这个参数函数可以传入三个参数：当前成员、当前位置和数组本身。</p><p><code>map()</code>方法还可以接受第二个参数，用来绑定回调函数内部的<code>this</code>变量,就是把结果指向<code>arr</code>数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">elem, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem * index;</span><br><span class="line">&#125;);</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem + <span class="number">1</span>;</span><br><span class="line">&#125;,arr);</span><br></pre></td></tr></table></figure></li><li><p><code>forEach()</code>的用法与<code>map()</code>方法一致，参数是也一致。如果数组遍历的目的是为了得到返回值，那么使用<code>map()</code>方法，否则使用<code>forEach()</code>方法。</p><p><code>forEach()</code>方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用<code>for</code>循环</p><p><code>forEach()</code>方法不会跳过<code>undefined</code>和<code>null</code>，但会跳过空位。</p></li><li><p><code>filter()</code>方法用于过滤数组成员，满足条件的成员组成一个新数组返回,参数同上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].filter(<span class="function"><span class="keyword">function</span> (<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (elem &gt; <span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>类似断言的方法</p><ul><li><code>some</code>方法是只要一个成员的返回值是<code>true</code>，则整个<code>some</code>方法的返回值就是<code>true</code>，否则返回<code>false</code>。</li><li><code>every</code>方法是所有成员的返回值都是<code>true</code>，整个<code>every</code>方法才返回<code>true</code>，否则返回<code>false</code>。</li></ul></li><li><p><code>reduce()</code>方法和<code>reduceRight()</code>方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code>reduce()</code>是从左到右处理（从第一个成员到最后一个成员），<code>reduceRight()</code>则是从右到左（从最后一个成员到第一个成员），其他完全一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"><span class="comment">// 3 3</span></span><br><span class="line"><span class="comment">// 6 4</span></span><br><span class="line"><span class="comment">// 10 5</span></span><br><span class="line"><span class="comment">//最后结果：15</span></span><br></pre></td></tr></table></figure><p>这四个参数之中，只有前两个是必须的，后两个则是可选的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  a,   <span class="comment">// 累积变量，必须</span></span></span></span><br><span class="line"><span class="params"><span class="function">  b,   <span class="comment">// 当前变量，必须</span></span></span></span><br><span class="line"><span class="params"><span class="function">  i,   <span class="comment">// 当前位置，可选</span></span></span></span><br><span class="line"><span class="params"><span class="function">  arr  <span class="comment">// 原数组，可选</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... ...</span></span><br></pre></td></tr></table></figure><p>如果要对累积变量指定初值，可以把它放在<code>reduce()</code>方法和<code>reduceRight()</code>方法的第二个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 25</span></span><br></pre></td></tr></table></figure></li><li><p><code>lastIndexOf</code>方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回<code>-1</code></p><p>该和<code>indexOf()</code>方法不能用来搜索<code>NaN</code>的位置，即它们无法确定数组成员是否包含<code>NaN</code>。这是因为这两个方法内部，使用严格相等运算符（<code>===</code>）进行比较，而<code>NaN</code>是唯一一个不等于自身的值。</p></li><li><p>总结一下：这个就是类似<code>java Stream</code>的方法，它们也可以链式调用。</p></li></ul><hr><h3 id="14-包装对象"><a href="#14-包装对象" class="headerlink" title="14.包装对象"></a>14.包装对象</h3><p>所谓“包装对象”，指的是与数值、字符串、布尔值分别相对应的<code>Number</code>、<code>String</code>、<code>Boolean</code>三个原生对象。</p><p>值得注意的是包装对象还可以自定义方法和属性，供原始类型的值直接调用。</p><p>比如，我们可以新增一个<code>double</code>方法，使得字符串和数字翻倍。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.double = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() + <span class="built_in">this</span>.valueOf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.double()</span><br><span class="line"><span class="comment">// abcabc</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.prototype.double = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() + <span class="built_in">this</span>.valueOf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="number">123</span>).double() <span class="comment">// 246</span></span><br></pre></td></tr></table></figure><hr><h3 id="15-Boolean-值得注意的点"><a href="#15-Boolean-值得注意的点" class="headerlink" title="15.Boolean 值得注意的点"></a>15.<code>Boolean</code> 值得注意的点</h3><p>Boolean对于特殊值的判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;false&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="regexp">/foo/</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>使用双重的否运算符（<code>!</code>）也可以将任意值转为对应的布尔值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!!<span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">null</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>最后，对于一些特殊值，<code>Boolean</code>对象前面加不加<code>new</code>，会得到完全相反的结果，必须小心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Boolean</span>(<span class="literal">false</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// 无输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Boolean</span>(<span class="literal">null</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// 无输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">null</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h3 id="16-Number对象值得注意的点"><a href="#16-Number对象值得注意的点" class="headerlink" title="16.Number对象值得注意的点"></a>16.Number对象值得注意的点</h3><ul><li><code>Number.POSITIVE_INFINITY</code>：正的无限，指向<code>Infinity</code>。</li><li><code>Number.NEGATIVE_INFINITY</code>：负的无限，指向<code>-Infinity</code>。</li><li><code>Number.NaN</code>：表示非数值，指向<code>NaN</code>。</li><li><code>Number.MIN_VALUE</code>：表示最小的正数（即最接近0的正数，在64位浮点数体系中为<code>5e-324</code>），相应的，最接近0的负数为<code>-Number.MIN_VALUE</code>。</li><li><code>Number.MAX_SAFE_INTEGER</code>：表示能够精确表示的最大整数，即<code>9007199254740991</code>。</li><li><code>Number.MIN_SAFE_INTEGER</code>：表示能够精确表示的最小整数，即<code>-9007199254740991</code>。</li></ul><hr><ul><li><p><code>toFixed()</code>方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。</p><p><code>toFixed()</code>方法的参数为小数位数，有效范围为0到100，超出这个范围将抛出 RangeError 错误。</p><p>由于浮点数的原因，小数<code>5</code>的四舍五入是不确定的，使用的时候必须小心。</p></li><li><p><code>toExponential</code>方法用于将一个数转为科学计数法形式。</p><p><code>toExponential</code>方法的参数是小数点后有效数字的位数，范围为0到100，超出这个范围，会抛出一个 RangeError 错误。</p></li><li><p><code>Number.prototype.toPrecision()</code>方法用于将一个数转为指定位数的有效数字。 参数同上</p><p>该方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关。</p></li><li><p>总结：Js做小数的操作都不太靠谱，能不用尽量别用。</p></li></ul><hr><h3 id="17-String对象值得注意的点"><a href="#17-String对象值得注意的点" class="headerlink" title="17.String对象值得注意的点"></a>17.<code>String</code>对象值得注意的点</h3><ul><li><p><code>charCodeAt()</code>方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于<code>String.fromCharCode()</code>的逆操作。</p></li><li><p><code>concat</code>方法用于连接两个字符串，返回一个新字符串，不改变原字符串。</p></li><li><p><code>slice()</code>方法用于从原字符串取出子字符串并返回，<em><strong>不改变原字符串</strong></em>。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。<code>substr</code>方法好像作用一样。</p></li><li><p><code>trim</code>方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</p></li><li><p><code>match</code>方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回<code>null</code>。<code>search</code>方法作用一样，但还可以使用正则表达式作为参数。</p></li></ul><hr><h3 id="18-Math对象值得注意的点"><a href="#18-Math对象值得注意的点" class="headerlink" title="18.Math对象值得注意的点"></a>18.<code>Math</code>对象值得注意的点</h3><p><code>Math</code>对象的静态属性，提供以下一些数学常数。</p><ul><li><code>Math.E</code>：常数<code>e</code>。</li><li><code>Math.LN2</code>：2 的自然对数。</li><li><code>Math.LN10</code>：10 的自然对数。</li><li><code>Math.LOG2E</code>：以 2 为底的<code>e</code>的对数。</li><li><code>Math.LOG10E</code>：以 10 为底的<code>e</code>的对数。</li><li><code>Math.PI</code>：常数<code>π</code>。</li><li><code>Math.SQRT1_2</code>：0.5 的平方根。</li><li><code>Math.SQRT2</code>：2 的平方根。</li></ul><p><code>Math</code>对象提供以下一些静态方法。</p><ul><li><code>Math.abs()</code>：绝对值</li><li><code>Math.ceil()</code>：向上取整</li><li><code>Math.floor()</code>：向下取整</li><li><code>Math.max()</code>：最大值</li><li><code>Math.min()</code>：最小值</li><li><code>Math.pow()</code>：幂运算</li><li><code>Math.sqrt()</code>：平方根</li><li><code>Math.log()</code>：自然对数</li><li><code>Math.exp()</code>：<code>e</code>的指数</li><li><code>Math.round()</code>：四舍五入</li><li><code>Math.random()</code>：随机数</li></ul><hr><h3 id="19-Date对象值得注意的点"><a href="#19-Date对象值得注意的点" class="headerlink" title="19.Date对象值得注意的点"></a>19.<code>Date</code>对象值得注意的点</h3><p>定义时间就跟<code>Java8 Time</code>包的差不多，但更灵活。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"><span class="comment">//灵活在这样都能解析</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2013-2-15&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2013/2/15&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;02/15/2013&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>日期设为<code>0</code>，就代表上个月的最后一天。</p></li><li><p>参数还可以使用负数，表示扣去的时间。</p></li><li><p>日期运算不能直接加减，先转成对应的毫秒数，运算后在<code>new Date()</code>转回来。</p></li></ul><p>静态方法</p><ul><li><code>Date.now</code>方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。</li><li><code>Date.parse</code>方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。如果解析失败，返回<code>NaN</code>。</li><li><code>Date.UTC</code>方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数</li></ul><p>实例方法</p><p><code>Date</code>的实例对象，有几十个自己的方法，除了<code>valueOf</code>和<code>toString</code>，可以分为以下三类。</p><ul><li><code>to</code>类：从<code>Date</code>对象返回一个字符串，表示指定的时间。</li><li><code>get</code>类：获取<code>Date</code>对象的日期和时间。<code>getFullYear</code>这种就不加以赘述</li><li><code>set</code>类：设置<code>Date</code>对象的日期和时间。<code>setFullYear</code>这种就不加以赘述</li></ul><hr><ul><li><code>valueOf</code>方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，等同于<code>getTime</code>方法。</li><li><code>toDateString</code>方法返回日期字符串（不含小时、分和秒）。</li><li><code>toTimeString</code>方法返回时间字符串（不含年月日）。</li></ul><hr><p>正则用到的时候再看吧，语法都是其次，<a href="https://wangdoc.com/javascript/stdlib/regexp#%E6%A6%82%E8%BF%B0">here</a>.</p><hr><h3 id="20-JSON对象"><a href="#20-JSON对象" class="headerlink" title="20.JSON对象"></a>20.<code>JSON</code>对象</h3><ul><li><p><code>JSON.stringify()</code>方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，</p><p><code>JSON.stringify()</code>方法还可以接受一个数组，作为第二个参数，指定参数对象的哪些属性需要转成字符串。</p><p><code>(</code>用处不大<code>)</code>：<code>JSON.stringify()</code>还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。默认返回的是单行字符串，对于大型的 JSON 对象，可读性非常差。第三个参数使得每个属性单独占据一行，并且将每个属性前面添加指定的前缀（不超过10个字符）。第三个属性如果是一个数字，则表示每个属性前面添加的空格（最多不超过10个）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认输出</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">p1</span>: <span class="number">1</span>, <span class="attr">p2</span>: <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// JSON.stringify(&#123; p1: 1, p2: 2 &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分行输出</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">p1</span>: <span class="number">1</span>, <span class="attr">p2</span>: <span class="number">2</span> &#125;, <span class="literal">null</span>, <span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// &quot;p1&quot;: 1,</span></span><br><span class="line"><span class="comment">// &quot;p2&quot;: 2</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>​    <code>toJSON()</code>方法跟<code>JSON.stringify()</code>作用一样。它的一个应用是，将正则对象自动转为字符串。因为<code>JSON.stringify()</code>默认不能转换正则对象，但是设置了<code>toJSON()</code>方法以后，就可以转换正则对象了。</p><ul><li><code>JSON.parse()</code>方法用于将 JSON 字符串转换成对应的值。</li></ul><hr><h3 id="21-面向对象"><a href="#21-面向对象" class="headerlink" title="21.面向对象"></a>21.面向对象</h3><ul><li><p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用<code>Object.create()</code>方法。</p></li><li><p><code>this</code>就是属性或方法“当前”所在的对象。</p></li><li><p>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</p><p>如果一层层地上溯，所有对象的原型最终都可以上溯到<code>Object.prototype</code>，即<code>Object</code>构造函数的<code>prototype</code>属性。也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的。</p><p>那么，<code>Object.prototype</code>对象有没有它的原型呢？回答是<code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是<code>null</code>。</p></li><li><p>JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.hello = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.world = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">S</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  M1.call(<span class="built_in">this</span>);</span><br><span class="line">  M2.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 M1</span></span><br><span class="line">S.prototype = <span class="built_in">Object</span>.create(M1.prototype);</span><br><span class="line"><span class="comment">// 继承链上加入 M2</span></span><br><span class="line"><span class="built_in">Object</span>.assign(S.prototype, M2.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定构造函数</span></span><br><span class="line">S.prototype.constructor = S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> S();</span><br><span class="line">s.hello <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">s.world <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中，子类<code>S</code>同时继承了父类<code>M1</code>和<code>M2</code>。这种模式又称为 Mixin（混入）。</p></li></ul><hr><p>JavaScript 模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p><p>模块是实现特定功能的一组属性和方法的封装。</p><p>简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　<span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">　<span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　  <span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　<span class="attr">m1</span> : m1,</span><br><span class="line">　　<span class="attr">m2</span> : m2</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>上面的函数<code>m1</code>和<code>m2</code>，都封装在<code>module1</code>对象里。使用的时候，就是调用这个对象的属性。</p><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">mod</span>) </span>&#123;</span><br><span class="line">　<span class="comment">//...</span></span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(<span class="built_in">window</span>.module1 || &#123;&#125;);</span><br></pre></td></tr></table></figure><hr><h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><p>进入严格模式的标志，是一行字符串<code>use strict</code>。作用域可以是脚本：使用需要放在脚本文件的第一行。作用域也可以是单个函数：需要将其放在函数体的第一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br></pre></td></tr></table></figure><p>在多人开发中，有时需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><hr><h3 id="22-JavaScript的异步操作"><a href="#22-JavaScript的异步操作" class="headerlink" title="22.JavaScript的异步操作"></a>22.<code>JavaScript</code>的异步操作</h3><ul><li><p>首先，<code>JavaScript</code>是单线程模型的语言，但<code>JavaScript</code> 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。对于高频大量访问的情况是通过异步解决的。</p></li><li><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p><p>同步任务就在主线程上排队，异步任务就其他任务队列（队列有多个）的，从而不影响异步任务后的任务。引擎会实时检查异步任务能否是否满足执行条件，满足的话就把它挪到主线程上去（异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数，如果一个异步任务没有回调函数，就不会重新进入主线程，因为没有用回调函数指定下一步的操作。），当任务队列清空，程序结束。</p></li></ul><h5 id="异步的操作模式"><a href="#异步的操作模式" class="headerlink" title="异步的操作模式"></a>异步的操作模式</h5><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li></ul><h5 id="多个异步的流程控制"><a href="#多个异步的流程控制" class="headerlink" title="多个异步的流程控制"></a>多个异步的流程控制</h5><ul><li>串行执行：编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。</li><li>并行执行：即所有异步任务同时执行，等到全部完成以后，才执行<code>final</code>函数。</li><li>线程池模式：并行给他设置个池子大小，即同时最多只能执行<code>n</code>个任务….简易的线程池。</li></ul><hr><h3 id="23-定时器相关"><a href="#23-定时器相关" class="headerlink" title="23.定时器相关"></a>23.定时器相关</h3><p><code>setTimeout</code>函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。<code>setTimeout</code>函数接受两个参数，第一个参数<code>func|code</code>是将要推迟执行的函数名或者一段代码，第二个参数<code>delay</code>是推迟执行的毫秒数。<code>setTimeout</code>的第二个参数如果省略，则默认为0。</p><p><code>setTimeout</code>还允许更多的参数。下例中的<code>1,1</code>就作为回调函数的参数<code>a,b</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>值得注意的点：</p><ul><li><p>setTimeout<code>的作用是将代码推迟到指定时间执行，如果指定时间为</code>0<code>，即</code>setTimeout(f, 0)会在下一轮事件循环一开始就执行。<code>setTimeout(f, 0)</code>有几个非常重要的用途。</p><ul><li><p>可以调整事件的发生顺序（举例：父子模块执行顺序）。</p></li><li><p>另一个应用是，用户自定义的回调函数，通常在浏览器的默认动作之前触发。（举例：用户每次输入文本后，立即将字符转为大写。但是实际上，它只能将本次输入前的字符转为大写，因为浏览器此时还没接收到新的文本，所以<code>this.value</code>取不到最新输入的那个字符。只有用<code>setTimeout</code>改写，上面的代码才能发挥作用。）</p></li><li><p>由于<code>setTimeout(f, 0)</code>实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到<code>setTimeout(f, 0)</code>里面执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0xA00000</span>; i &lt; <span class="number">0xFFFFFF</span>; i++) &#123;</span><br><span class="line">  div.style.backgroundColor = <span class="string">&#x27;#&#x27;</span> + i.toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> timer;</span><br><span class="line"><span class="keyword">var</span> i=<span class="number">0x100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(func, <span class="number">0</span>);</span><br><span class="line">  div.style.backgroundColor = <span class="string">&#x27;#&#x27;</span> + i.toString(<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">if</span> (i++ == <span class="number">0xFFFFFF</span>) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timer = <span class="built_in">setTimeout</span>(func, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，因为 JavaScript 执行速度远高于 DOM，会造成大量 DOM 操作“堆积”，而写法二就不会，这就是<code>setTimeout(f, 0)</code>的好处。</p><p>另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成<code>setTimeout(highlightNext, 50)</code>的样子，性能压力就会减轻。</p></li></ul></li><li><p>如果回调函数是对象的方法，那么<code>setTimeout</code>使得方法内部的<code>this</code>关键字指向全局环境，而不是定义时所在的那个对象。</p><p>为了防止出现这个问题，一种解决方法是将<code>obj.y</code>放入一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  obj.y();</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>obj.y</code>放在一个匿名函数之中，这使得<code>obj.y</code>在<code>obj</code>的作用域执行，而不是在全局作用域内执行，所以能够显示正确的值。</p><p>另一种解决方法是，使用<code>bind</code>方法，将<code>obj.y</code>这个方法绑定在<code>obj</code>上面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.y.bind(obj), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><code>setInterval</code>函数的用法与<code>setTimeout</code>完全一致，区别仅仅在于<code>setInterval</code>指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p><p><code>setInterval</code>指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，<code>setInterval</code>指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。</p><p>为了确保两次执行之间有固定的间隔，可以不用<code>setInterval</code>，而是每次执行结束后，使用<code>setTimeout</code>指定下一次执行的具体时间。即双重<code>setTimeout</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(f, <span class="number">2000</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><hr><p><code>setTimeout</code>和<code>setInterval</code>函数，都返回一个整数值，表示计数器编号。将该整数传入<code>clearTimeout</code>和<code>clearInterval</code>函数，就可以取消对应的定时器。</p><p><code>setTimeout</code>和<code>setInterval</code>返回的整数值是连续的，也就是说，第二个<code>setTimeout</code>方法返回的整数值，将比第一个的整数值大1。</p><p>利用这一点，可以写一个函数，取消当前所有的<code>setTimeout</code>定时器。先调用<code>setTimeout</code>，得到一个计算器编号，然后把编号比它小的计数器全部取消。</p><h5 id="定时器的实现逻辑"><a href="#定时器的实现逻辑" class="headerlink" title="定时器的实现逻辑"></a>定时器的实现逻辑</h5><p><code>setTimeout</code>和<code>setInterval</code>的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。</p><p>这意味着，<code>setTimeout</code>和<code>setInterval</code>指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，<code>setTimeout</code>和<code>setInterval</code>指定的任务，一定会按照预定时间执行。</p><hr><h5 id="页面防抖处理-debounce"><a href="#页面防抖处理-debounce" class="headerlink" title="页面防抖处理 debounce"></a>页面防抖处理 debounce</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;textarea&#x27;</span>).on(<span class="string">&#x27;keydown&#x27;</span>, debounce(ajaxAction, <span class="number">2500</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>; <span class="comment">// 声明计时器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，只要在2500毫秒之内，用户再次击键，就会取消上一次的定时器，然后再新建一个定时器。这样就保证了回调函数之间的调用间隔，至少是2500毫秒。</p><hr><h3 id="24-Promise对象（重要）"><a href="#24-Promise对象（重要）" class="headerlink" title="24.Promise对象（重要）"></a>24.<code>Promise</code>对象（重要）</h3><p>Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p><p>Promise 是一个对象，也是一个构造函数。传统的写法可能需要把<code>f2</code>作为回调函数传入<code>f1</code>，比如写成<code>f1(f2)</code>，异步操作完成后，在<code>f1</code>内部调用<code>f2</code>。Promise 使得<code>f1</code>和<code>f2</code>变成了链式写法。不仅改善了可读性，而且对于多层嵌套的回调函数尤其方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line">step1(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</span><br><span class="line">  step2(value1, <span class="function"><span class="keyword">function</span>(<span class="params">value2</span>) </span>&#123;</span><br><span class="line">    step3(value2, <span class="function"><span class="keyword">function</span>(<span class="params">value3</span>) </span>&#123;</span><br><span class="line">      step4(value3, <span class="function"><span class="keyword">function</span>(<span class="params">value4</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 的写法</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Promise</span>(step1))</span><br><span class="line">  .then(step2)</span><br><span class="line">  .then(step3)</span><br><span class="line">  .then(step4);</span><br></pre></td></tr></table></figure><hr><h5 id="Promise对象的状态"><a href="#Promise对象的状态" class="headerlink" title="Promise对象的状态"></a><code>Promise</code>对象的状态</h5><p>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</p><ul><li>异步操作未完成（pending）</li><li>异步操作成功（fulfilled）</li><li>异步操作失败（rejected）</li></ul><p>上面三种状态里面，<code>fulfilled</code>和<code>rejected</code>合在一起称为<code>resolved</code>（已定型）。</p><p>因此，Promise 的最终结果只有两种。</p><ul><li>异步操作成功，Promise 实例传回一个值（value），状态变为<code>fulfilled</code>。</li><li>异步操作失败，Promise 实例抛出一个错误（error），状态变为<code>rejected</code>。</li></ul><hr><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>（异步操作成功时调用）和<code>reject</code>（失败时调用）。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。</p><p>Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。</p><p>而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。</p><p>Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆<code>then</code>，必须自己在<code>then</code>的回调函数里面理清逻辑。</p><p>Promise 的回调函数属于异步任务，会在同步任务之后执行。但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。</p><hr><p>DOM 操作 忽略</p><hr><h3 id="25-鼠标事件"><a href="#25-鼠标事件" class="headerlink" title="25.鼠标事件"></a>25.鼠标事件</h3><p>鼠标事件主要有下面这些，所有事件都继承了<code>MouseEvent</code>接口</p><p>（1）点击事件</p><p>鼠标点击相关的有四个事件。</p><ul><li><code>click</code>：按下鼠标（通常是按下主按钮）时触发。</li><li><code>dblclick</code>：在同一个元素上双击鼠标时触发。</li><li><code>mousedown</code>：按下鼠标键时触发。</li><li><code>mouseup</code>：释放按下的鼠标键时触发。</li></ul><p><code>click</code>事件可以看成是两个事件组成的：用户在同一个位置先触发<code>mousedown</code>，再触发<code>mouseup</code>。因此，触发顺序是，<code>mousedown</code>首先触发，<code>mouseup</code>接着触发，<code>click</code>最后触发。</p><p>双击时，<code>dblclick</code>事件则会在<code>mousedown</code>、<code>mouseup</code>、<code>click</code>之后触发。</p><p>（2）移动事件</p><p>鼠标移动相关的有五个事件。</p><ul><li><code>mousemove</code>：当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。</li><li><code>mouseenter</code>：鼠标进入一个节点时触发，进入子节点不会触发这个事件（详见后文）。</li><li><code>mouseover</code>：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件（详见后文）。</li><li><code>mouseout</code>：鼠标离开一个节点时触发，离开父节点也会触发这个事件（详见后文）。</li><li><code>mouseleave</code>：鼠标离开一个节点时触发，离开父节点不会触发这个事件（详见后文）。</li></ul><p><code>mouseover</code>事件和<code>mouseenter</code>事件，都是鼠标进入一个节点时触发。两者的区别是，<code>mouseenter</code>事件只触发一次，而只要鼠标在节点内部移动，<code>mouseover</code>事件会在子节点上触发多次。</p><p>（3）其他事件</p><ul><li><code>contextmenu</code>：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文”菜单键时触发。</li><li><code>wheel</code>：滚动鼠标的滚轮时触发，该事件继承的是<code>WheelEvent</code>接口。</li></ul><hr><h3 id="26-键盘事件"><a href="#26-键盘事件" class="headerlink" title="26.键盘事件"></a>26.键盘事件</h3><p>键盘事件由用户击打键盘触发，主要有<code>keydown</code>、<code>keypress</code>、<code>keyup</code>三个事件，它们都继承了<code>KeyboardEvent</code>接口。</p><ul><li><code>keydown</code>：按下键盘时触发。</li><li><code>keypress</code>：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发<code>keydown</code>事件，再触发这个事件。</li><li><code>keyup</code>：松开键盘时触发该事件。</li></ul><p>如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。</p><ol><li>keydown</li><li>keypress</li><li>keydown</li><li>keypress</li><li>…（重复以上过程）</li><li>keyup</li></ol><p><code>KeyboardEvent</code>接口用来描述用户与键盘的互动。这个接口继承了<code>Event</code>接口，并且定义了自己的实例属性和实例方法。</p><p>浏览器原生提供<code>KeyboardEvent</code>构造函数，用来新建键盘事件的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> KeyboardEvent(type, options)</span><br></pre></td></tr></table></figure><p><code>KeyboardEvent</code>构造函数接受两个参数。第一个参数是字符串，表示事件类型；第二个参数是一个事件配置对象，该参数可选。除了<code>Event</code>接口提供的属性，还可以配置以下字段，它们都是可选。</p><ul><li><code>key</code>：字符串，当前按下的键，默认为空字符串。</li><li><code>code</code>：字符串，表示当前按下的键的字符串形式，默认为空字符串。</li><li><code>location</code>：整数，当前按下的键的位置，默认为<code>0</code>。</li><li><code>ctrlKey</code>：布尔值，是否按下 Ctrl 键，默认为<code>false</code>。</li><li><code>shiftKey</code>：布尔值，是否按下 Shift 键，默认为<code>false</code>。</li><li><code>altKey</code>：布尔值，是否按下 Alt 键，默认为<code>false</code>。</li><li><code>metaKey</code>：布尔值，是否按下 Meta 键，默认为<code>false</code>。</li><li><code>repeat</code>：布尔值，是否重复按键，默认为<code>false</code>。</li></ul><hr><h3 id="27-进度事件"><a href="#27-进度事件" class="headerlink" title="27.进度事件"></a>27.进度事件</h3><p>进度事件用来描述资源加载的进度，主要由 AJAX 请求、<code>&lt;img&gt;</code>、<code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;style&gt;</code>、<code>&lt;link&gt;</code>等外部资源的加载触发，继承了<code>ProgressEvent</code>接口。它主要包含以下几种事件。</p><ul><li><code>abort</code>：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。</li><li><code>error</code>：由于错误导致外部资源无法加载时触发。</li><li><code>load</code>：外部资源加载成功时触发。</li><li><code>loadstart</code>：外部资源开始加载时触发。</li><li><code>loadend</code>：外部资源停止加载时触发，发生顺序排在<code>error</code>、<code>abort</code>、<code>load</code>等事件的后面。</li><li><code>progress</code>：外部资源加载过程中不断触发。</li><li><code>timeout</code>：加载超时时触发。</li></ul><p>注意，除了资源下载，文件上传也存在这些事件。</p><hr><h3 id="28-表单事件"><a href="#28-表单事件" class="headerlink" title="28.表单事件"></a>28.表单事件</h3><ul><li><p><code>input</code>事件当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>的值发生变化时触发。</p></li><li><p><code>select</code>事件当在<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>里面选中文本时触发。</p></li><li><p><code>change</code>事件当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>的值发生变化时触发。它与<code>input</code>事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发，另一方面<code>input</code>事件必然伴随<code>change</code>事件。具体来说，分成以下几种情况。</p><ul><li>激活单选框（radio）或复选框（checkbox）时触发。</li><li>用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。</li><li>当文本框或<code>&lt;textarea&gt;</code>元素的值发生改变，并且丧失焦点时触发。</li></ul></li><li><p><code>invalid</code>事件当用户提交表单时，如果表单元素的值不满足校验条件时触发。</p></li><li><p><code>reset</code>事件当表单重置（所有表单成员变回默认值）时触发。</p><p><code>submit</code>事件当表单数据向服务器提交时触发。注意，<code>submit</code>事件的发生对象是<code>&lt;form&gt;</code>元素，而不是<code>&lt;button&gt;</code>元素，因为提交的是表单，而不是按钮。</p></li></ul><hr><h3 id="29-触摸事件"><a href="#29-触摸事件" class="headerlink" title="29.触摸事件"></a>29.触摸事件</h3><p>触摸引发的事件，有以下几种。可以通过<code>TouchEvent.type</code>属性，查看到底发生的是哪一种事件。</p><ul><li><code>touchstart</code>：用户开始触摸时触发，它的<code>target</code>属性返回发生触摸的元素节点。</li><li><code>touchend</code>：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的<code>target</code>属性与<code>touchstart</code>事件一致的，就是开始触摸时所在的元素节点。它的<code>changedTouches</code>属性返回一个<code>TouchList</code>实例，包含所有不再触摸的触摸点（即<code>Touch</code>实例对象）。</li><li><code>touchmove</code>：用户移动触摸点时触发，它的<code>target</code>属性与<code>touchstart</code>事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。</li><li><code>touchcancel</code>：触摸点取消时触发，比如在触摸区域跳出一个模态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。</li></ul><p>浏览器的触摸 API 由三个部分组成。</p><ul><li>Touch：一个触摸点</li><li>TouchList：多个触摸点的集合</li><li>TouchEvent：触摸引发的事件实例</li></ul><p><code>Touch</code>接口的实例对象用来表示触摸点（一根手指或者一根触摸笔），包括位置、大小、形状、压力、目标元素等属性。有时，触摸动作由多个触摸点（多根手指）组成，多个触摸点的集合由<code>TouchList</code>接口的实例对象表示。<code>TouchEvent</code>接口的实例对象代表由触摸引发的事件，只有触摸屏才会引发这一类事件。</p><p>很多时候，触摸事件和鼠标事件同时触发，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。如果想避免这种情况，可以用<code>event.preventDefault</code>方法阻止发出鼠标事件。</p><p>Touch 接口代表单个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。</p><p>浏览器原生提供<code>Touch</code>构造函数，用来生成<code>Touch</code>实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> touch = <span class="keyword">new</span> Touch(touchOptions);</span><br></pre></td></tr></table></figure><p><code>Touch</code>构造函数接受一个配置对象作为参数，它有以下属性。</p><ul><li><code>identifier</code>：必需，类型为整数，表示触摸点的唯一 ID。</li><li><code>target</code>：必需，类型为元素节点，表示触摸点开始时所在的网页元素。</li><li><code>clientX</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的水平距离，默认为0。</li><li><code>clientY</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的垂直距离，默认为0。</li><li><code>screenX</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的水平距离，默认为0。</li><li><code>screenY</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的垂直距离，默认为0。</li><li><code>pageX</code>：可选，类型为数值，表示触摸点相对于网页左上角的水平位置（即包括页面的滚动距离），默认为0。</li><li><code>pageY</code>：可选，类型为数值，表示触摸点相对于网页左上角的垂直位置（即包括页面的滚动距离），默认为0。</li><li><code>radiusX</code>：可选，类型为数值，表示触摸点周围受到影响的椭圆范围的 X 轴半径，默认为0。</li><li><code>radiusY</code>：可选：类型为数值，表示触摸点周围受到影响的椭圆范围的 Y 轴半径，默认为0。</li><li><code>rotationAngle</code>：可选，类型为数值，表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间，默认值为0。</li><li><code>force</code>：可选，类型为数值，范围在<code>0</code>到<code>1</code>之间，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力，默认为<code>0</code>。</li></ul><hr><h3 id="30-拖拉事件"><a href="#30-拖拉事件" class="headerlink" title="30.拖拉事件"></a>30.拖拉事件</h3><p>在网页中，除了元素节点默认不可以拖拉，其他（图片、链接、选中的文字）都可以直接拖拉。为了让元素节点可拖拉，可以将该节点的<code>draggable</code>属性设为<code>true</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div draggable=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">  此区域可拖拉</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>当元素节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件。</p><ul><li><code>drag</code>：拖拉过程中，在被拖拉的节点上持续触发（相隔几百毫秒）。</li><li><code>dragstart</code>：用户开始拖拉时，在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。</li><li><code>dragend</code>：拖拉结束时（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。它与<code>dragstart</code>事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，<code>dragend</code>事件总是会触发的。</li><li><code>dragenter</code>：拖拉进入当前节点时，在当前节点上触发一次，该事件的<code>target</code>属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。</li><li><code>dragover</code>：拖拉到当前节点上方时，在当前节点上持续触发（相隔几百毫秒），该事件的<code>target</code>属性是当前节点。该事件与<code>dragenter</code>事件的区别是，<code>dragenter</code>事件在进入该节点时触发，然后只要没有离开这个节点，<code>dragover</code>事件会持续触发。</li><li><code>dragleave</code>：拖拉操作离开当前节点范围时，在当前节点上触发，该事件的<code>target</code>属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。</li><li><code>drop</code>：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许<code>drop</code>，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。</li></ul><h5 id="关于拖拉事件，有以下几个注意点。"><a href="#关于拖拉事件，有以下几个注意点。" class="headerlink" title="关于拖拉事件，有以下几个注意点。"></a>关于拖拉事件，有以下几个注意点。</h5><ul><li>拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发。</li><li>将文件从操作系统拖拉进浏览器，不会触发<code>dragstart</code>和<code>dragend</code>事件。</li><li><code>dragenter</code>和<code>dragover</code>事件的监听函数，用来取出拖拉的数据（即允许放下被拖拉的元素）。由于网页的大部分区域不适合作为放下拖拉元素的目标节点，所以这两个事件的默认设置为当前节点不允许接受被拖拉的元素。如果想要在目标节点上放下的数据，首先必须阻止这两个事件的默认行为。</li></ul><hr><h3 id="31-资源事件"><a href="#31-资源事件" class="headerlink" title="31.资源事件"></a>31.资源事件</h3><ul><li><code>beforeunload</code>事件在窗口、文档、各种资源将要卸载前触发。它可以用来防止用户不小心卸载资源。</li><li><code>unload</code>事件在窗口关闭或者<code>document</code>对象将要卸载时触发。它的触发顺序排在<code>beforeunload</code>、<code>pagehide</code>事件后面。<code>unload</code>事件发生时，文档处于一个特殊状态。所有资源依然存在，但是对用户来说都不可见，UI 互动全部无效。这个事件是无法取消的，即使在监听函数里面抛出错误，也不能停止文档的卸载</li><li><code>load</code>事件在页面或某个资源加载成功时触发。注意，页面或资源从浏览器缓存加载，并不会触发<code>load</code>事件。页面的<code>load</code>事件也可以用<code>pageshow</code>事件代替。</li><li><code>error</code>事件是在页面或资源加载失败时触发。</li><li><code>abort</code>事件在用户取消加载时触发。</li></ul><hr><h3 id="32-session历史事件"><a href="#32-session历史事件" class="headerlink" title="32.session历史事件"></a>32.<code>session</code>历史事件</h3><ul><li><code>pageshow</code>事件在页面加载时触发，包括第一次加载和从缓存加载两种情况。如果要指定页面每次加载（不管是不是从浏览器缓存）时都运行的代码，可以放在这个事件的监听函数。</li><li><code>pagehide</code>事件与<code>pageshow</code>事件类似，当用户通过“前进/后退”按钮，离开当前页面时触发。它与 unload 事件的区别在于，如果在 window 对象上定义<code>unload</code>事件的监听函数之后，页面不会保存在缓存中，而使用<code>pagehide</code>事件，页面会保存在缓存中。</li></ul><p>注意，这两个事件只在浏览器的<code>history</code>对象发生变化时触发，跟网页是否可见没有关系。</p><ul><li><p><code>popstate</code>事件在浏览器的<code>history</code>对象的当前记录发生显式切换时触发。注意，调用<code>history.pushState()</code>或<code>history.replaceState()</code>，并不会触发<code>popstate</code>事件。该事件只在用户在<code>history</code>记录之间显式切换时触发，比如鼠标点击“后退/前进”按钮，或者在脚本中调用<code>history.back()</code>、<code>history.forward()</code>、<code>history.go()</code>时触发。</p><p>该事件对象有一个<code>state</code>属性，保存<code>history.pushState</code>方法和<code>history.replaceState</code>方法为当前记录添加的<code>state</code>对象。</p></li><li><p><code>hashchange</code>事件在 URL 的 hash 部分（即<code>#</code>号后面的部分，包括<code>#</code>号）发生变化时触发。该事件一般在<code>window</code>对象上监听。</p><p><code>hashchange</code>的事件实例具有两个特有属性：<code>oldURL</code>属性和<code>newURL</code>属性，分别表示变化前后的完整 URL。</p></li></ul><hr><h3 id="33-网页状态事件"><a href="#33-网页状态事件" class="headerlink" title="33.网页状态事件"></a>33.网页状态事件</h3><ul><li><p>网页下载并解析完成以后，浏览器就会在<code>document</code>对象上触发 DOMContentLoaded 事件。这时，仅仅完成了网页的解析（整张页面的 DOM 生成了），所有外部资源（样式表、脚本、iframe 等等）可能还没有下载结束。也就是说，这个事件比<code>load</code>事件，发生时间早得多。</p><p>注意，网页的 JavaScript 脚本是同步执行的，脚本一旦发生堵塞，将推迟触发<code>DOMContentLoaded</code>事件。</p></li></ul><hr><h3 id="34-窗口事件"><a href="#34-窗口事件" class="headerlink" title="34.窗口事件"></a>34.窗口事件</h3><ul><li><p><code>scroll</code>事件在文档或文档元素滚动时触发，主要出现在用户拖动滚动条。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, callback);</span><br></pre></td></tr></table></figure><p>该事件会连续地大量触发，所以它的监听函数之中不应该有非常耗费计算的操作。推荐的做法是使用<code>requestAnimationFrame</code>或<code>setTimeout</code>控制该事件的触发频率，然后可以结合<code>customEvent</code>抛出一个新事件。</p></li><li><p><code>resize</code>事件在改变浏览器窗口大小时触发，主要发生在<code>window</code>对象上面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resizeMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.body.clientWidth &lt; <span class="number">768</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;移动设备的视口&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, resizeMethod, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>该事件也会连续地大量触发，所以最好像上面的<code>scroll</code>事件一样，通过<code>throttle</code>函数控制事件触发频率。</p></li><li><p><code>fullscreenchange</code>事件在进入或退出全屏状态时触发，该事件发生在<code>document</code>对象上面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;fullscreenchange&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">document</span>.fullscreenElement);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>fullscreenerror</code>事件在浏览器无法切换到全屏状态时触发。</p></li></ul><hr><h3 id="35-剪切板事件"><a href="#35-剪切板事件" class="headerlink" title="35.剪切板事件"></a>35.剪切板事件</h3><p>以下三个事件属于剪贴板操作的相关事件。</p><ul><li><code>cut</code>：将选中的内容从文档中移除，加入剪贴板时触发。</li><li><code>copy</code>：进行复制动作时触发。</li><li><code>paste</code>：剪贴板内容粘贴到文档后触发。</li></ul><p>举例来说，如果希望禁止输入框的粘贴事件，可以使用下面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputElement.addEventListener(<span class="string">&#x27;paste&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> e.preventDefault());</span><br></pre></td></tr></table></figure><p>上面的代码使得用户无法在<code>&lt;input&gt;</code>输入框里面粘贴内容。</p><p><code>cut</code>、<code>copy</code>、<code>paste</code>这三个事件的事件对象都是<code>ClipboardEvent</code>接口的实例。<code>ClipboardEvent</code>有一个实例属性<code>clipboardData</code>，是一个 DataTransfer 对象，存放剪贴的数据。具体的 API 接口和操作方法，请参见《拖拉事件》的 DataTransfer 对象部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;copy&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.clipboardData.setData(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">  e.clipboardData.setData(<span class="string">&#x27;text/html&#x27;</span>, <span class="string">&#x27;&lt;b&gt;Hello, world!&lt;/b&gt;&#x27;</span>);</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使得复制进入剪贴板的，都是开发者指定的数据，而不是用户想要拷贝的数据。</p><hr><h3 id="36-焦点事件-FocusEvent"><a href="#36-焦点事件-FocusEvent" class="headerlink" title="36.焦点事件 FocusEvent"></a>36.焦点事件 FocusEvent</h3><p>焦点事件发生在元素节点和<code>document</code>对象上面，与获得或失去焦点相关。它主要包括以下四个事件。</p><ul><li><code>focus</code>：元素节点获得焦点后触发，该事件不会冒泡。</li><li><code>blur</code>：元素节点失去焦点后触发，该事件不会冒泡。</li><li><code>focusin</code>：元素节点将要获得焦点时触发，发生在<code>focus</code>事件之前。该事件会冒泡。</li><li><code>focusout</code>：元素节点将要失去焦点时触发，发生在<code>blur</code>事件之前。该事件会冒泡。</li></ul><hr><h3 id="37-CustomEvent-接口"><a href="#37-CustomEvent-接口" class="headerlink" title="37.CustomEvent 接口"></a>37.CustomEvent 接口</h3><p>CustomEvent 接口用于生成自定义的事件实例。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。</p><p>浏览器原生提供<code>CustomEvent()</code>构造函数，用来生成 CustomEvent 事件实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CustomEvent(type, options)</span><br></pre></td></tr></table></figure><p><code>CustomEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。<code>CustomEvent</code>的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。</p><ul><li><code>detail</code>：表示事件的附带数据，默认为<code>null</code>。</li></ul><hr><h3 id="38-script-元素"><a href="#38-script-元素" class="headerlink" title="38.script 元素"></a>38.<code>script</code> 元素</h3><p>正常的网页加载流程是这样的。</p><ol><li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li><li>解析过程中，浏览器发现<code>&lt;script&gt;</code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</li><li>如果<code>&lt;script&gt;</code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li><li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li></ol><ul><li>为了解决脚本文件下载阻塞网页渲染的问题，一个方法是对<code>&lt;script&gt;</code>元素加入<code>defer</code>属性。它的作用是延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;a.js&quot;</span> defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>解决“阻塞效应”的另一个方法是对<code>&lt;script&gt;</code>元素加入<code>async</code>属性。它会并行下载脚本，先下载完的先执行。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;a.js&quot;</span> <span class="keyword">async</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>defer</code>属性和<code>async</code>属性到底应该使用哪一个？</p><p>一般来说，如果脚本之间没有依赖关系，就使用<code>async</code>属性，如果脚本之间有依赖关系，就使用<code>defer</code>属性。如果同时使用<code>async</code>和<code>defer</code>属性，后者不起作用，浏览器行为由<code>async</code>属性决定。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳到下一个舒适圈，真舒适啊</title>
      <link href="/record/2022/11/17/ssn0010/"/>
      <url>/record/2022/11/17/ssn0010/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1df3567834d4362e3f671655e8d5efd9be17ec7ab6c5b0e3d699c0157dd08183">73ec4e90604b298de70b40cddedb7a1361b462f307d9ce1a3289179ffa3c1997bd72ea975af972ca1aad91f29dcde3cc7b1bd79a58eea6fec13a97277a160956e2d9e8601fa14c819de3cc8aa134810991794698410dc2bad5306b05a4d5a7bd56e117eb51498888067af5df67174fd4c2fb52b75d9d2468e9a996203db533177050bec035d9da051d16d4bed81e0ab182c905879d85b65d2cf5bfe5bdf6254b01db903b1f777badda2312ceb40d98a975036896ad049fb524d196a4696fbbfac0d03ec7060e3060cf82fb8d38846bafd8575da71079a536ede736e58ac56b90233079628116d759e408a3ccb192165f4e5a39b554a8fbf512a81af8099df94303e7e5954991c5a759c9f4ce735a49ce095a772025a6486306bebe41df5c8a0cd9f687e72f0404ff626e1804f5e6fcc170e1fba7206ca39b19fb9ccf6ae6e8dbbd4fbc4c33deb0c40b5a57e7485ae9bd8256c1646c4cb73f23f613552a5d8ef8ec2c53c4e192d9a90a90247f2c55bb8179d78f5b417fbd463d1ea9c60759c7e7e2c23f4d748c17844e49b5fff5990563053aa72b5135121d61d86ff04de9e9173e9ea23c27513d1112430bde864e292cd7e1a0a9b8be5ef2a3e03378195a937a5606e5f7d5f7714c190e8cae64f1bb45a84a14bc4de4045d5bb32e2cb30fecb277e4547cde69db630c1e5817d840d70fac5631f57a620d4bafbed77770efbbc7328c25536a4983435d509cce83de53451b76cabc58bdf855d6cbf7594e88ed3114f0bdbf7c6651b727e7c7e34fccc337c2e75e585b7986bb6d368e768b117e48b4116734da188f6593acdbce3f2c16331659df7df2272ffe5193adeb9654c7e6e3110c73f2e66431e3e06bf970adfb2fb948485dbec008c36cbb4474a36366de183742f1574d0d072b6f77dd265dbdb81c2e1d4d173837f11290ff5cd58314f6a04119ea8bdb7b37a30da0fb373fcb43b18cb79cb64fa9c3ef7d3e60a365774c0ab775f26aba52bef27fe100ab93e3140d091ef82ef61c5a4786954156cca9228f8fc464925a6563e02a8567384b6d64366f27381f828a97f2e1bef9dc1d343e4e13a5d1dff559883f667c61b1115fe93b4e2fff092c9b4a0d59c1365748a855d23f8a8d9e1c1b7c65117a6b1403660bd08edc0d7a0cbf1800fb9c816e0cebb1d8905a9a3b1bc574a2cc9c4a6bed570aaea300147938a19e99565fbf17976546d62fbce25d1b769175f5013eafa1adc5da787f5195e14d7fc624dfc1a8bcd0c755f74830c61faa13e3d9e12eed1ac0d34eddf12ceced8b3e0bdc23dd97c309b4dc753418ee1205aada6143bedc0a6f75256d9ee534c3450c5d8d20518f39a0a6285cf99ca6a42614c8008c4a344f1d98205cd387a6613c8a1b24f0bf5de2c35824d6f932fa40c1aa8add061a54b8a81736996c38b8961d74e6a119300f069dcbb1bb89506bc96eed8095392d10c009c4f1d01c013978b65d685d7e0919f74ddf5a9a1f882ec267256e7a9a32dc28f8709b6c7924f317c3e7fbdfb7852be7827dbca8021a59a0641dfe7fb47619d5db874e3fcfb954a543f66c454832fd010a11ab7a42ac40ac0f19fa1c3fb457eff0468843490d3f483b758fc8a8a304f3e4a6301759395f789ae982dd04c18b93498272b3a5f002f97409d6e9b6209b6ed9ce41cb65aa23325d1c4c2f0b42226e45d6dea9d096f9fc3ee469cd2932b1a5abd197adca0ead789e8022c2e1d55733b15f7f2ef7921fc23334240379f61f4e784228eea813a31a801f681682116fedc1d4a9c37cc424661ac0b62f7619a04b559d904f1aabe4e23b9cabe75ad82b5da287c9de3fb85b9856f43bfb0119bc90f0849a5644d0556a11783f308c675e11c90e6afed936a336832a1a1b55765058d80769e561164626de36b7043c9c3afc6b22ec1b14b3dbba73cfd589e691d39b8cd087c76398da07786c500cd794989f381a5e2d5071eac60ac6eca848cfcb681538def97eca481dd81fb1ba44ebd52cf7bbeeeca5ec5ed92ba02f57079aec1d469a604fbf8dece9e9dada94d7e9b0777b47aed21cb1ad4ebcef1fc75a67057dd28e4addfebc163e2a7ecf970ec4b9e926300e6bc5e03cf3d2a6eebe494ebe1dcd48372ac49fe66d94bbbfa78aa7fc2dd8000426a7b0aed441215d995e57809d1cc576e6c1647dd0f705a1b1f805525364ccb1ac4cbb1617b309dc525868987ceade137850082880e68e28d2fe182adacdfb3b899f1fd3d25bc137cc2178c0ad62d676cc40ad548b0697af8b1c81a27e3e3e155b8ad43cbb59f9baff03001e56feecc6715e1793d899a6fc3c2c1fd69f5cda10493ecd30754dc642af8d747a5e17f6b5c238725672aaafe2cc58aebb888be5ddcc80d5b5b6cfb5277bc3c835541e0ea88ba3a66b8052dd01fec0c9542fd976f38dcb6c1a4f0162de56665d390f0994854a2ecf92d28c9d43f3215e8457f4f6eb976c2645a14d6bb69f973d5405dd17979aa253ff75eb71cc798fbc5f0881e5cba99f2ac55c8024da7a6d40371e431e9173c9bdc650b12f60e90708bd457983a10fc76d28ed967242e7e86885c5981d2b58e0f8f77ec1bdfc1fe193c3f99c14451b486260e78279de49e8c6afc67280c390edb4ee58d5232207d4ceb48871b182ab655d5d02a9f8549adbabcafaa542c07cf832dc26f7c19f31d4ed5c6c6e1235cb00643a2399fbe16ace4e7f3693f7b97c5f5cf400ffc3a4a8e37dfe78b1437e4717be662b82eb4f311d81c815affa4674679790dce1a76d237af8ff7814c4753acea9e5161186411235e723ac4c12940bbb9d30b2d25eb87579737ca6b4f1b0841dca99789a58c2dc0174c690373ec53a17e8b6a9241a5f0b288073e81b2f492c8b82121e47829c474413a05b8f12808e48189ffe38c21c813e10d338488a8f6ced5efb9bd5df5c0928f1e19792d2959c31262f00ecfa7e003643099d5a3a44235f5728bb5772d08df14442201f0ee5a9c97c826fcdac50fe9c8dddfb40fe4e1c6a3e5408beff38a70c7beace1bc760a980bd486fb91fe7543f4ae888cce9c35a42b507f14d57a23e9cca995280eb30e312589ca3a8587b69056a29d8192c276162875624212369114b65b751a5858fabc33d4ddf68e5f5903ddfa02591c24064f7fa368b0b36df361888001d0d9f38903a2bc4650c2aee00d68ffb7d92f6d93be5f5de145b349b8a397f3bea72446b209523f931f8dab456a48a91e3cd0dc2f4b2d6898dbd77472d814948aeef7c3b2770c48480ac862ae870dcfcfe082cb9c84ce153a25233912bbd100e63c8f5f8d965d6d59b52b828a2bf5de88ecaabf35df491c446be26f2286bef2e0c142c3bfe46ff15a625b8aa57addda5b94806307c765717a16d1e01edeb23b24306c7b19bc6c75631e3a1d567f3918e6639268c2359759e0317eacc738705ce1986fe6d0a8e79f1caf8ab8373b3adbe3d1a7a1b452dae488885f69f4d636d6df0a08e935b0b81d1fc79ad07cc2b6a572be391581287096807abf1dfad6965caa9a6e76021af2115e89f9bf345d5939457ef82a5e5cc8547f0a367f3ffbdc8dc7b35d7129d2cb60aafe936b38ced5e081c4a0455c4a8a5b51f5fc8024f294abe6dcdd01bd9c0b6aa9bc2ac110c4d4aaaf226f75fd66f5f3ba1eae8301fd5a54404640eedf696146cab181dd1537c6f3407ecb7c2d831b88937cfe9b620fb18b4060bfaab0736faca992da7f60a8b1a5a78f1dc14e43a661b5339479a04dc09f2a3169b0fab8ec7533c15b23d51d2678037d43701aa67dbe6fda5df21518f997e28c5b9a9f8415f28e42df993a16b2decf77e95f208fd30fcc92d135e145131ceda625f7f3894c33876692bb3308b8d98e470efe8bb25e0ee4d4642af538b755c0402f4a6f9203a97c448cdf493c18b8ef23c57bde0ba8eab44012b96893f3c1a525ccbb580e4a7570bda10d51705bc648b8eff90bdfe451eec4cb2bea8c60f3a13715eedee5e49665787e3cd11658d0c4f107825dfdc7ead2d75fc62a001870e91c0615fb852f9a0cde0a43dc38d547ccdcd0fe5ca63422d64140973126df636482bc98c2cd3b1ce73e7b3d914fabee69fcf764f30aa22d81be0ab1b2239210d92f3ddb7b45c1f509a7e75aacd33d4f8cf59075dcc89f535861473528ee0cd6bf4b2b315dfef8eb61864bba5d34e156aed2baad1e2a2fad2fc6604725c1a336bcda0e0e9b145f7c89e45c6977f68a67d1e9733002a14c274a6c6b3994d0b60ccccc3b66a9ae1ffaeb60803744754e0d77fb106256a646af4108fa06df5ae33b8ab68a37708f38532389dae6053db1c824b32c434fa5307b2ce5879980a78ce0728e2b4bc358415f7c1965b15b18bc955bda8ac9af3131c1c626ef4d17cade70d76c4a7484ec912e061706a57a67e75f9f5c69aef78c45150a430b312b72599b2e1eb06718c23def63ab46830d5c0aeda538e3d2c350db5278ee68d71eb649da524654b92d05413b2b509d7c8495b149e0b8c39b2952407f005270e20446c8393593883c7ef810f118be102a15c7efdcf215570d76e44cb1e96a311f853ab5eeece71cbda291a81a9e7b4dc9c380663f43bde0b50efa2cb970089c7d2dc37edcf23bd6aa9a655b285a1a6c0f1211a7c6ab00299d6cd3ec8914be5286ec60d5ed3ba7820ada228e231c2cefa41d6f0a7b229472a5a8703d6faf2ddfa8d75e443b66de657da25c850cd2e4533bb9f9b64c25fcc04ad8557d81843062b83c54d79b095030b3e2a3b5799a4609a6d7c318f78f907bff6fd27093b1b388ae3c8271e871d27532721432d47ec31fc644c6a39548d0bb686ce8541ff318b1d107201646e207646c4f637d508a9af7f05bba3e27e70769f7d425d07819ca7a6b051885f52726d5af80d4ff07871a29387b14ee7cc9616eb011df8b29fae0a132b6b64adede2bd247f2467413492a3dc48a44bb8dbca026ac216c82f12008e71b21e3213d360c8e5bacae71c14896c3425f498e0c63cd003dab4e2436d7cdbdd751a85b8bf1be7757285ba071c9faf323ed832102c4e816ea804c6eccb6a8fd4b381626e79f22ead52b08e203abb62ee0b61b54cc9e40271b10af075674fb85aa3f74a95a0dc2b5d5fe3edd8084de975d4c89124718926036f9e2ab9e327c60358236cd4380b6ad71fcddef714113fb548fdfd1d0a875f1065222689b9d69245df3419bfadf44505be5ee09684bdee82dc632b72c7773a345dca8e123850c948c076f635332518877c0c8263a43b83eda408c72e6227fa2852094e6d03be249a1163c056664eee97c8bce907b914d02636f9f6f9d14c91471dab1a892b927eaebfa2d193f891a3899efbc871b18dfb838967c3cd2417bc77884accd240f16e935f41914e3412efabd7edf873cf2ba43942dce1965640b14107b1683e3a1e7f36f78c7f7d811f0549a4328cde5a8e5211552476ec3c1f9e1672243016e0ececf28589d37c8544a6c4d05dd2182952f6faf0d0653d6106118d9cddcb847e678df8e823520c8f02474d2a51a4e375f437b7e7b89e66c9281840ed707f54969ad4c1df4bebc61bf253d585c49822443645350bfd44304d4e94d0e29c4bf86d8d39cf79169e8fff91659a69c4b45eea0ce1caaf8c96d46510c5dab945a6e463e2e535f46ff5b0ef5ea99d95d18fc6cf4067c313ef6817898ca5d5b50b54e5a6eaedc981c134ce335977ba26972ffef861ff708ec592310f82f9c0857e7018a3911156c8956cc0afd30daa3aec7eece81a95bc550f30823b08ce33284192bac9232354bd8e7827906d304bd91607e3f71b9f645f112009a855ab6b1cee281a712f8842b138cfae121520bb0c3ed85136d56e0bcbd712183f4215e35ac691d5a31def45a7d33630a0ca939c4b0fc668c9559bb0023b4e7cfb4a2b06331e0d3ff03be67f579e4f5dcba06b7c3a11903c7455d4dac27e7c1d893f7f9f7ab627144421c4cc580379826967cf503486d7ea2337cbd19445b509ea5508c36e3eb680545b7fc598b4fca23d7c2f06ad01b16ee6fd1597f5a8d45c73723a395a17d4b2335155ece0f68655511bc433cbaebacf997171fa3df5edd200d490eb54fabdcfa4c60e8f55ba65d2801ca91bf82183c386c7550156673461d9edaafc2ac45d243e20ad60c2cb702417c5b78e03c9ed05d824fa9f2d589bca07c032762be3a710007d002d176119518deaea37914f35d668ee134b6620941fe6fb1b01c6c6b12388f0b87fe5fe04982656b5b6e04c3f2081de8e5fd99ff49d3ca6000c4261209ddc23396dd88fd6b3876d2eff56d7d077c0720e63ee93de7a46598a7d9a7bda1c659dae6603e7a4251d2d3224e74c962197d1a073a52e16c40d1d56ba9b1527496788e3911a6a3679717e9bd32858584a31ee56d95c9bdf0006c4f8e48d46386eb581d7221c7692b12303515bf01f4be5ba0cab961ddc8495824e30be349aac89e86b8405637fc9e16a49e0b23c54e206848008759b37b0db6553900748633b31e11799174d75bfba92600b552994af5489850e32517cec6ff825774e058c208108f23349c4b348888a4a2783afe6671650e092ef730b8e86dbe7c5ca5c61ebad405f3d3001487a5e53fce07d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/record/lib/hbe.js"></script><link href="/record/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次生产慢查询优化实例</title>
      <link href="/record/2022/11/15/%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%AE%9E%E4%BE%8B/"/>
      <url>/record/2022/11/15/%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>背景：项目上线后，发现某查询接口比较慢，定位到是SQL查询问题，查询时间大约在<code>3～5s</code>。数据库是<code>Oracle</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--待优化SQL</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  STRATEGY_ID,</span><br><span class="line">  CIF_NO,</span><br><span class="line">  BIZ_TYPE,</span><br><span class="line">  T_TYPE,</span><br><span class="line">  FINANCE,</span><br><span class="line">  START_TIME,</span><br><span class="line">  END_TIME,</span><br><span class="line">  STRATEGY_NAME,</span><br><span class="line">  DIRECTION,</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  XXX_XXX_STRATEGY</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  (</span><br><span class="line">    CIF _NO <span class="operator">=</span> ?</span><br><span class="line">    <span class="keyword">and</span> T_TYPE <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> DIRECTION <span class="operator">=</span> ?</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">or</span> T_TYPE <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line">  <span class="keyword">and</span> START_TIME <span class="operator">&lt;=</span> ? <span class="keyword">and</span> END_TIME <span class="operator">&gt;=</span> ? <span class="keyword">order</span> <span class="keyword">by</span> START_TINE <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p><code>XXX_XXX_STRATEGY</code>表的索引情况：</p><p>​    唯一索引：<code>STRATEGY_ID</code></p><p>​    普通索引：<code>CIF_NO,BIZ_TYPE,END_TIME,STRATEGY_NAME</code></p><p>定位原因：</p><p><code>OR</code>前半段查询条件相对比较精确，查询结果是比较少的。</p><p><code>OR</code>后半段的<code> T_TYPE =&#39;B&#39;</code> 在生产上查出了大量数据（万级），但是在后续业务处理时大部分被去重了（剩余数据为 百级）。</p><hr><p>这里同事给出方案一：分表：将<code>TYPE = &#39;B&#39;</code>的数据存放在一个新建的表中，但这样问题是不管放在哪总是查询出了大量数据，总是快不了的。由于数据量大肯定走了全表扫描，使用索引也是无效的。</p><p>所以要将优化重点放到<code>SQL</code>本身上。</p><p>首先肯定需要拆成两个<code>SQL</code>，首先将<code>OR</code>优化为 <code>UNION ALL</code>试试情况：查询时间还是跟之前一样。</p><p>这时，我们看到这里的查询结果其实都被之后的去重逻辑给去掉了，我们能不能在查询的时候就给他去重呢？</p><p>答案是肯定的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--拆分出来的SQL</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  STRATEGY_ID,</span><br><span class="line">  T_TYPE,</span><br><span class="line">  FINANCE,</span><br><span class="line">  START_TIME,</span><br><span class="line">  END_TIME,</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  XXX_XXX_STRATEGY</span><br><span class="line"><span class="keyword">WHERE</span>  </span><br><span class="line">  T_TYPE <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> START_TIME <span class="operator">&lt;=</span> ? <span class="keyword">AND</span> END_TIME <span class="operator">&gt;=</span> ? <span class="keyword">ORDER</span> <span class="keyword">BY</span> START_TINE <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p>根据业务逻辑，类型为<code>&#39;B&#39;</code>的数据主要使用到的字段是<code>FINANCE</code>，生产中推送入库时推送了大量的该字段的重复数据进来。这一点在<code>UAT</code>环境中是没有预料到的。我们立马就想到了用分组来过滤，但是需要将<code>FINANCE</code>字段相同的数据取最新的一条，这样分组同时还需要排序。先看最后优化的<code>SQL</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      STRATEGY_ID,</span><br><span class="line">      T_TYPE,</span><br><span class="line">      FINANCE,</span><br><span class="line">      START_TIME,</span><br><span class="line">      END_TIME,</span><br><span class="line">      ...,</span><br><span class="line">      <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> e.FINANCE <span class="keyword">order</span> <span class="keyword">by</span> e.START_TIME <span class="keyword">desc</span>) rankNo</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      XXX_XXX_STRATEGY e</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">      e.T_TYPE <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span> <span class="keyword">AND</span> START_TIME <span class="operator">&lt;=</span> ? <span class="keyword">and</span> END_TIME <span class="operator">&gt;=</span> ? </span><br><span class="line">  ) r</span><br><span class="line">  <span class="keyword">where</span> r.rankNo <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>我们主要使用了<code>over()</code>函数:它给<code> partition by</code>的分组结果给提供了一个封闭的区间，而<code>row_number()</code>函数：会在<code>over()</code>的每个区间范围内重新分配一个递增的行号。这里我们取行号为<code>1</code>的数据即是取按时间排序第一位的数据。</p><p><code>SQL</code>去重后在十万级的数据量下查询速度约为<code>0.4s</code>，虽然还是不算快，但是已经算解决了问题啦。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ消息状态异常问题排查</title>
      <link href="/record/2022/10/09/RocketMQ%E6%B6%88%E6%81%AF%E7%8A%B6%E6%80%81%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
      <url>/record/2022/10/09/RocketMQ%E6%B6%88%E6%81%AF%E7%8A%B6%E6%80%81%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p><code>MQ</code>一般问题发现的流程是发现消息收不到，然后到控制台去查询消息状态。结果发现可能是<code>XXXX</code>。这里就明确一下消息投递的异常状态，和造成这种异常状态的常见的原因。本文的<code>MQ</code>指的是<code>RocketMQ</code>。</p><h3 id="消息状态"><a href="#消息状态" class="headerlink" title="消息状态"></a>消息状态</h3><ul><li><p><code>NOT_ONLINE</code></p><p>订阅端不在线（未启动）</p></li><li><p><code>CONSUMED</code></p><p>已消费（正常状态）</p></li><li><p><code>CONSUMED_BUT_FILTERED</code></p><p>消息已经被投递且被过滤。（一个消费组能同时订阅多个 tag，但一个消费组的不同消费者不能分开订阅不同的tag，即同一个消费组的订阅关系必须保持一样。）</p></li><li><p><code>NOT_CONSUME_YET</code></p><p>暂未消费（尝试多次消费失败）</p></li><li><p><code>UNKNOWN</code></p><p>未知状态（原因比较多）</p></li></ul><h3 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h3><ul><li><p>走定时任务时同时走<code>MQ</code>导致消息消费失败，查询消息状态为<code>NOT_CONSUME_YET</code>。</p><p>原因：跑定时任务的时候机器涉及大量数据库操作占有大量的核心内存资源，导致同时跑<code>MQ</code>的时候机器资源不够用了，导致消息消费多次失败。</p></li><li><p>修改<code>MQ</code>配置后，再接收消息在控制台发现消息状态为<code>NOT_ONLINE</code></p><p>原因：要么是订阅端没有启动要么就是订阅端对<code>MQ</code>没有心跳，建议查端口，然后启动一下。</p></li><li><p>待补充…</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream流常见方法浅析</title>
      <link href="/record/2022/09/11/Stream-%E6%B5%81%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%B5%85%E6%9E%90/"/>
      <url>/record/2022/09/11/Stream-%E6%B5%81%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Stream流常见方法浅析"><a href="#Stream流常见方法浅析" class="headerlink" title="Stream流常见方法浅析"></a><code>Stream</code>流常见方法浅析</h2><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><p><code>flatMap</code>方法用于将流中的每个元素转换成其他类型元素的流，比如，当前有一个订单(Order)列表，每个订单又包含多个商品<code>(itemList)</code>，如果要得到所有订单的所有商品汇总，就可以使用该方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Item&gt; allItemStream = orderList.stream().flatMap(order -&gt; order.itemList.stream());</span><br></pre></td></tr></table></figure><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p><code>distinct</code>方法用于对流中的元素去重，判断元素是否重复使用的是<code>equals</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; numStream = Stream.of(-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//不重复的数字流，uniqueNumStream -&gt; (-2, -1, 0, 1, 2, 3)</span></span><br><span class="line">Stream&lt;Integer&gt; uniqueNumStream = numStream.distinct();</span><br></pre></td></tr></table></figure><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p><code>sorted</code>有一个无参和一个有参的方法，用于对流中的元素进行排序。无参方法要求流中的元素必须实现<code>Comparable</code>接口，不然会报<code>java.lang.ClassCastException</code>异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; unorderedStream = Stream.of(<span class="number">5</span>, <span class="number">6</span>, <span class="number">32</span>, <span class="number">7</span>, <span class="number">27</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//按从小到大排序完成的流，orderedStream -&gt; (4, 5, 6, 7, 27, 32)</span></span><br><span class="line">Stream&lt;Integer&gt; orderedStream = unorderedStream.sorted();</span><br></pre></td></tr></table></figure><p>有参方法<code>sorted(Comparator&lt;? super T&gt; comparator)</code>不需要元素实现<code>Comparable</code>接口，通过指定的元素比较器对流内的元素进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; unorderedStream = Stream.of(<span class="string">&quot;1234&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;12&quot;</span>, <span class="string">&quot;12345&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="comment">//按字符串长度从小到大排序完成的流，orderedStream -&gt; (&quot;1&quot;, &quot;12&quot;, &quot;123&quot;, &quot;1234&quot;, &quot;12345&quot;, &quot;123456&quot;)</span></span><br><span class="line">Stream&lt;String&gt; orderedStream = unorderedStream.sorted(Comparator.comparingInt(String::length));</span><br></pre></td></tr></table></figure><h4 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h4><p><code>peek</code>方法可以不调整元素顺序和数量的情况下消费每一个元素，然后产生新的流，主要是用于对流执行的中间过程做debug的时候使用，因为<code>Stream</code>使用的时候一般都是链式调用的，所以可能会执行多次流操作，如果想看每个元素在多次流操作中间的流转情况，就可以使用这个方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>)</span><br><span class="line">     .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line">     .peek(e -&gt; System.out.println(<span class="string">&quot;Filtered value: &quot;</span> + e))</span><br><span class="line">     .map(String::toUpperCase)</span><br><span class="line">     .peek(e -&gt; System.out.println(<span class="string">&quot;Mapped value: &quot;</span> + e))</span><br><span class="line">     .collect(Collectors.toList());</span><br><span class="line">     </span><br><span class="line">输出：</span><br><span class="line">Filtered value: three</span><br><span class="line">Mapped value: THREE</span><br><span class="line">Filtered value: four</span><br><span class="line">Mapped value: FOUR</span><br></pre></td></tr></table></figure><h4 id="skip-long-n"><a href="#skip-long-n" class="headerlink" title="skip(long n)"></a>skip(long n)</h4><p><code>skip</code>方法用于跳过前n个元素，如果流中的元素数量不足n，则返回一个空的流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;-2&quot;</span>, <span class="string">&quot;-1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="comment">//跳过前3个元素，subStringStream -&gt; (&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)</span></span><br><span class="line">Stream&lt;String&gt; subStringStream = stringStream.skip(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="forEachOrdered"><a href="#forEachOrdered" class="headerlink" title="forEachOrdered"></a>forEachOrdered</h4><p><code>forEachOrdered</code>方法可以保证顺序遍历，比如这个流是从外部传进来的，然后在这之前调用过<code>parallel</code>方法开启了多线程执行，就可以使用这个方法保证单线程顺序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;-2&quot;</span>, <span class="string">&quot;-1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="comment">//顺序遍历输出元素</span></span><br><span class="line"><span class="comment">//单线程操作流的时候它与forEach()是一致的。</span></span><br><span class="line">stringStream.forEachOrdered(System.out::println);</span><br><span class="line">stringStream.forEach(System.out::println);</span><br><span class="line"><span class="comment">//多线程遍历输出元素，下面这行跟上面的执行结果是一样的</span></span><br><span class="line">stringStream.parallel().forEachOrdered(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p><code>reduce</code>有三个重载方法，作用是对流内元素做累进操作</p><p>第一个<code>reduce(BinaryOperator&lt;T&gt; accumulator)</code></p><p><code>accumulator</code> 为累进操作的具体计算</p><p>单线程等价如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> foundAny = <span class="keyword">false</span>;</span><br><span class="line">T result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="keyword">this</span> stream) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!foundAny) &#123;</span><br><span class="line">      foundAny = <span class="keyword">true</span>;</span><br><span class="line">      result = element;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      result = accumulator.apply(result, element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> foundAny ? Optional.of(result) : Optional.empty();</span><br><span class="line">Stream&lt;Integer&gt; numStream = Stream.of(-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//查找最小值</span></span><br><span class="line">Optional&lt;Integer&gt; min = numStream.reduce(BinaryOperator.minBy(Integer::compareTo));</span><br><span class="line"><span class="comment">//输出 -2</span></span><br><span class="line">System.out.println(min.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤出大于5的元素流</span></span><br><span class="line">numStream = Stream.of(-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).filter(num -&gt; num &gt; <span class="number">5</span>);</span><br><span class="line"><span class="comment">//查找最小值</span></span><br><span class="line">min = numStream.reduce(BinaryOperator.minBy(Integer::compareTo));</span><br><span class="line"><span class="comment">//输出 Optional.empty</span></span><br><span class="line">System.out.println(min);</span><br></pre></td></tr></table></figure><p>第二个<code>reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></p><p><code>identity</code> 为累进操作的初始值<br><code>accumulator</code> 同上</p><p>单线程等价如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T result = identity;</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="keyword">this</span> stream)</span><br><span class="line">  result = accumulator.apply(result, element)</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">Stream&lt;Integer&gt; numStream = Stream.of(-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//累加计算所有元素的和，sum=3</span></span><br><span class="line"><span class="keyword">int</span> sum = numStream.reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure><p>第三个<code>reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code></p><p><code>identity</code>和<code>accumulator</code>同上<br><code>combiner</code>用于多线程执行的情况下合并最终结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; numStream = Stream.of(-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">int</span> sum = numStream.parallel().reduce(<span class="number">0</span>, (a, b) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;accumulator执行:&quot;</span> + a + <span class="string">&quot; + &quot;</span> + b);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;, (a, b) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;combiner执行:&quot;</span> + a + <span class="string">&quot; + &quot;</span> + b);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;最终结果：&quot;</span>+sum);</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">accumulator执行:<span class="number">0</span> + -<span class="number">1</span></span><br><span class="line">accumulator执行:<span class="number">0</span> + <span class="number">1</span></span><br><span class="line">accumulator执行:<span class="number">0</span> + <span class="number">0</span></span><br><span class="line">accumulator执行:<span class="number">0</span> + <span class="number">2</span></span><br><span class="line">accumulator执行:<span class="number">0</span> + -<span class="number">2</span></span><br><span class="line">accumulator执行:<span class="number">0</span> + <span class="number">3</span></span><br><span class="line">combiner执行:<span class="number">2</span> + <span class="number">3</span></span><br><span class="line">combiner执行:-<span class="number">1</span> + <span class="number">0</span></span><br><span class="line">combiner执行:<span class="number">1</span> + <span class="number">5</span></span><br><span class="line">combiner执行:-<span class="number">2</span> + -<span class="number">1</span></span><br><span class="line">combiner执行:-<span class="number">3</span> + <span class="number">6</span></span><br><span class="line">最终结果：<span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p><code>collect</code>有两个重载方法，主要作用是把流中的元素作为集合转换成其他<code>Collection</code>的子类，其内部实现类似于前面的累进操作</p><p>第一个<code>collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</code></p><p><code>supplier</code> 需要返回开始执行时的默认结果<br><code>accumulator</code> 用于累进计算用<br><code>combiner</code> 用于多线程合并结果</p><p>单线程执行等价于如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R result = supplier.get();</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="keyword">this</span> stream)</span><br><span class="line">  accumulator.accept(result, element);</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>第二个<code>collect(Collector&lt;? super T, A, R&gt; collector)</code></p><p><code>Collector</code>其实是对上面的方法参数的一个封装，内部执行逻辑是一样的，只不过JDK提供了一些默认的<code>Collector</code>实现，对于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; numStream = Stream.of(-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">List&lt;Integer&gt; numList = numStream.collect(Collectors.toList());</span><br><span class="line">Set&lt;Integer&gt; numSet = numStream.collect(Collectors.toSet());</span><br></pre></td></tr></table></figure><h4 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h4><p><code>anyMatch</code>方法用于匹配校验流内元素是否有符合指定条件的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; numStream = Stream.of(-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//判断是否包含正数，hasPositiveNum=true</span></span><br><span class="line"><span class="keyword">boolean</span> hasPositiveNum = numStream.anyMatch(num -&gt; num &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h4><p><code>allMatch</code>方法用于匹配校验流内元素是否所有元素都符合指定条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; numStream = Stream.of(-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//判断是否全部是正数，allNumPositive=false</span></span><br><span class="line"><span class="keyword">boolean</span> allNumPositive = numStream.allMatch(num -&gt; num &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h4><p><code>noneMatch</code>方法用于匹配校验流内元素是否都不符合指定条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; numStream = Stream.of(-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//判断是否没有小于0的元素，noNegativeNum=false</span></span><br><span class="line"><span class="keyword">boolean</span> noNegativeNum = numStream.noneMatch(num -&gt; num &lt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h4><p><code>findFirst</code>方法用于获取第一个元素，如果流是空的，则返回Optional.empty</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; numStream = Stream.of(-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//获取第一个元素，firstNum=-2</span></span><br><span class="line">Optional&lt;Integer&gt; firstNum = numStream.findFirst();</span><br></pre></td></tr></table></figure><h4 id="findAny"><a href="#findAny" class="headerlink" title="findAny"></a>findAny</h4><p><code>findAny</code>方法用于获取流中的任意一个元素，如果流是空的，则返回Optional.empty，因为可能会使用多线程，所以不保证每次返回的是同一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; numStream = Stream.of(-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Optional&lt;Integer&gt; anyNum = numStream.findAny();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 Time包浅析</title>
      <link href="/record/2022/08/27/java8-Time%E5%8C%85%E6%B5%85%E6%9E%90/"/>
      <url>/record/2022/08/27/java8-Time%E5%8C%85%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<ul><li>本文时对Java8 Time包中做一个简单的解析，适用于对Time包不甚了解/快速上手的人。</li></ul><h4 id="1-从api上理解"><a href="#1-从api上理解" class="headerlink" title="1. 从api上理解"></a>1. 从api上理解</h4><table><thead><tr><th>包</th><th>说明</th></tr></thead><tbody><tr><td><code>java.time</code></td><td>核心时间类</td></tr><tr><td><code>java.time.chrono</code></td><td>其他地方的纪年法</td></tr><tr><td><code>java.time.format</code></td><td>时间格式化相关的类</td></tr><tr><td><code>java.time.temporal</code></td><td>定义时间的基础接口</td></tr><tr><td><code>java.time.zone</code></td><td>时区相关的类</td></tr></tbody></table><ul><li>基类：</li></ul><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td><code>Duration</code></td><td>表示持续时间，从一个时间点持续到另一个时间点，比如：数据结构课从<code>8:00</code>上到<code>10:00</code></td></tr><tr><td><code>Instant</code></td><td>时间点</td></tr><tr><td><code>LocalDate</code></td><td>本地日期，默认时区，精确到日</td></tr><tr><td><code>LocalTime</code></td><td>本地时间，默认时区，精确到秒</td></tr><tr><td><code>LocalDateTime</code></td><td>本地日期时间，默认时区，上二者相加</td></tr><tr><td><code>MonthDay</code></td><td>月份中的日期，不存年， 例如：<code>12</code>月<code>3</code>日</td></tr><tr><td><code>OffsetDateTime</code></td><td>在<code>ISO-8601</code>日历系统中的<code>UTC</code> /格林威治偏移的日期时间，如<code>2007-12-03T10:15:30+01:00</code>。      旨在使用<code>ZonedDateTime</code>或<code>Instant</code>在较简单的应用中对数据进行建模。 当更详细地建模日期时间概念时，或者当与数据库或网络协议进行通信时，可以使用此类。</td></tr><tr><td><code>OffsetTime</code></td><td>同上，但仅是时间：如<code>10:15:30+01:00</code></td></tr><tr><td><code>Period</code></td><td>表示时间段，最小单位是天，开始结束时间点不确定，比如：国庆放7天假</td></tr><tr><td><code>Year</code></td><td>年</td></tr><tr><td><code>YearMonth</code></td><td>一年中的月，不存日， 例如：<code>2022</code>年<code>3</code>月</td></tr><tr><td><code>ZonedDateTime</code></td><td>时区的日期时间，精度为纳秒，</td></tr><tr><td><code>ZoneId</code></td><td>时区<code>ID</code>，比如<code>Asia/Shanghai</code></td></tr><tr><td><code>DayOfWeek</code></td><td>一周的天，枚举类</td></tr><tr><td><code>Month</code></td><td>月，枚举类</td></tr><tr><td><code>DateTimeFormatter</code></td><td>日期格式化</td></tr></tbody></table><h4 id="2-具体使用场景"><a href="#2-具体使用场景" class="headerlink" title="2. 具体使用场景"></a>2. 具体使用场景</h4><h5 id="2-1-创建时间及查询"><a href="#2-1-创建时间及查询" class="headerlink" title="2.1 创建时间及查询"></a>2.1 创建时间及查询</h5><ul><li>创建年月日</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line"><span class="comment">//2022-10-27</span></span><br><span class="line">LocalDate birthday = LocalDate.of(<span class="number">2008</span>,<span class="number">8</span>,<span class="number">12</span>);</span><br><span class="line"><span class="comment">//2008-05-12</span></span><br></pre></td></tr></table></figure><ul><li>创建时分秒</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalTime nowTime = LocalTime.now();</span><br><span class="line"><span class="comment">//10:55:02.057948</span></span><br><span class="line">LocalTime workTime = LocalTime.of(<span class="number">8</span>,<span class="number">30</span>);</span><br><span class="line"><span class="comment">//08:30</span></span><br><span class="line">LocalTime lunchTime = LocalTime.of(<span class="number">12</span>,<span class="number">1</span>,<span class="number">21</span>,<span class="number">999999</span>);</span><br><span class="line"><span class="comment">//12:01:21.000999999</span></span><br><span class="line"><span class="comment">//ps:最后一位单位为纳秒，九位小数</span></span><br></pre></td></tr></table></figure><ul><li>创建完整体</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime nowDateTime = LocalDateTime.now();</span><br><span class="line"><span class="comment">//2022-10-27T11:15:35.839724</span></span><br><span class="line">LocalDateTime cakeTime = LocalDateTime.of(birthday,lunchTime);</span><br><span class="line"><span class="comment">//2008-08-12T12:01:21.000999999</span></span><br><span class="line">LocalDateTime supperTime = LocalDateTime.of(<span class="number">2022</span>,<span class="number">10</span>,<span class="number">27</span>,<span class="number">13</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//2022-10-27T13:10:10.000000001</span></span><br></pre></td></tr></table></figure><ul><li>查询</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以查的非常细致，这里举例几个常用的</span></span><br><span class="line">nowDateTime.getDayOfMonth();</span><br><span class="line">nowDateTime.getDayOfWeek();</span><br><span class="line">nowDateTime.getYear();</span><br></pre></td></tr></table></figure><h5 id="2-2-时间比较"><a href="#2-2-时间比较" class="headerlink" title="2.2 时间比较"></a>2.2 时间比较</h5><ul><li>相同格式时间比较</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">now.isAfter(birthday);</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">LocalTime workTime1 = LocalTime.of(<span class="number">8</span>,<span class="number">30</span>);</span><br><span class="line">workTime.equals(workTime1);</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">nowDateTime.isBefore(cakeTime);</span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li><p>不同格式时间转化比较</p><p><code>LocalDate</code>/<code>LocalTime</code>/<code>LocalDateTime</code>三者不能相互直接比较。<br>其中<code>LocalDateTime</code>可以通过<code>toLocalDate()</code>/<code>toLocalTime()</code>进行转化再进行比较。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nowDateTime.isAfter(ChronoLocalDateTime.from(now));</span><br><span class="line"><span class="comment">//Error</span></span><br></pre></td></tr></table></figure><ul><li>与1.7用的时间<code>java.util.Date</code>进行比较</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">Date nowOldDate = calendar.getTime();</span><br><span class="line"><span class="comment">//Thu Oct 27 14:44:25 CST 2022</span></span><br><span class="line"><span class="comment">//需要将nowOldDate转化为LocalDateTime才能比</span></span><br><span class="line">Instant startTime = nowOldDate.toInstant();</span><br><span class="line">ZoneId zoneId = ZoneId.systemDefault();</span><br><span class="line">LocalDateTime nowNewDate = LocalDateTime.ofInstant(startTime, zoneId);</span><br><span class="line"><span class="comment">//2022-10-27T14:47:56.468</span></span><br></pre></td></tr></table></figure><h5 id="2-3-时间转化"><a href="#2-3-时间转化" class="headerlink" title="2.3 时间转化"></a>2.3 时间转化</h5><ul><li><p>本包内互转</p><ul><li><p><code>ZonedDateTime</code>与<code>LocalDateTime</code>互转</p><p><code>ZonedDateTime</code>相对与后者多表示时区，所以：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime BeijingTime = nowDateTime.atZone(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line"><span class="comment">//2022-10-27T15:11:41.466572+08:00[Asia/Shanghai]</span></span><br><span class="line">nowDateTime = BeijingTime.toLocalDateTime();</span><br><span class="line"><span class="comment">//2022-10-27T15:12:05.377544</span></span><br></pre></td></tr></table></figure><ul><li><p><code>OffsetDateTime</code>与<code>LocalDateTime</code>互转</p><p><code>OffsetDateTime</code>相对后者多表示偏移量，偏移量(<code>ZoneOffset</code>) 的意思是时间相对与 <code>UTC</code> 标准时区的偏移的时间。</p><p><code>UTC</code> 偏移量 仅仅只记录了时分秒而已，除此之外没有任何其他信息。举个例子 ，<code>+08:00</code> 的意思时超前于 <code>UTC</code> 八个小时，而 <code>-05:45</code> 意思是落后于 <code>UTC</code> 五小时四十五分钟,偏移量最大<code>+18:00</code>,最小<code>-18:00</code>。</p><p>偏移量和时区的关系。<code>Asia/Shanghai</code>，也称东8区 <code>+08:00</code>。但是在某些时间场景下时区有时会对应着与之前不同的偏移量。时区跟人类社会有关，比如说以后曹县很牛，可能就会有个<code>Asia/Caoxian</code>,对应的偏移量可能就是<code>+07:40</code>。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OffsetDateTime offsetDateTime = nowDateTime.atOffset(ZoneOffset.MIN);</span><br><span class="line"><span class="comment">//2022-10-27T15:55:09.871589-18:00</span></span><br><span class="line">nowDateTime = offsetDateTime.toLocalDateTime();</span><br><span class="line"><span class="comment">//2022-10-27T15:55:09.871589</span></span><br></pre></td></tr></table></figure></li><li><p>转其他格式</p><ul><li><p>与字符串互转之格式化</p><ul><li>转时间戳</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Timestamp timestamp = Timestamp.valueOf(nowDateTime);</span><br><span class="line"><span class="comment">//时间戳转LocalDateTime</span></span><br><span class="line">nowDateTime = timestamp.toLocalDateTime();</span><br><span class="line"><span class="comment">//2022-11-13T13:46:47.851677</span></span><br></pre></td></tr></table></figure><ul><li>转时间点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Instant point = nowDateTime.toInstant(ZoneOffset.ofHours(<span class="number">8</span>));</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-4-时间调整"><a href="#2-4-时间调整" class="headerlink" title="2.4 时间调整"></a>2.4 时间调整</h5><ul><li><p>加减天/周/月/年/秒/分/时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nowDateTime.minusDays(<span class="number">1</span>);</span><br><span class="line">nowDateTime.minusWeeks(<span class="number">1</span>);</span><br><span class="line">nowDateTime.plusHours(<span class="number">1</span>);</span><br><span class="line">nowDateTime.plusMinutes(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//..</span></span><br></pre></td></tr></table></figure></li><li><p>加减 另一个时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nowDateTime = nowDateTime.plus(Period.of(<span class="number">10</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line"><span class="comment">//-before-plus: 2022-10-27T17:08:29</span></span><br><span class="line"><span class="comment">//--after-plus: 2032-11-28T17:08:29</span></span><br><span class="line"><span class="comment">//同理有minus()方法。</span></span><br></pre></td></tr></table></figure></li><li><p>最后放一张图总结一下</p><p><img src="https://github.com/dianedii/picBed/blob/main/20210117101208962.png?raw=true"></p></li><li><p>缺陷</p><p>笔者在使用过程中发现新的时间包缺少对季节的相关处理：比如说查询当前时间在是哪个季节。</p><p>这里可以自己写一个简易的方法，示例如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询当前月份所在季节code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> month (1~12)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> (1~4)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSeasonValueByMonth</span><span class="params">(<span class="keyword">int</span> month)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (month == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  (month -<span class="number">1</span>) /<span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>参考文章</p><p><a href="https://juejin.cn/post/6897143007108136973"><code>java 8</code> 中的 <code>ZoneOffset</code> 与 <code>ZoneId</code></a></p><p><a href="https://blog.csdn.net/weixin_55305220/article/details/121924826"><code>LocalDateTime</code>、<code>OffsetDateTime</code>、<code>ZonedDateTime</code>互转</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> Time </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collectors方法详解</title>
      <link href="/record/2022/07/20/Collectors%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/record/2022/07/20/Collectors%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Collectors方法详解"><a href="#Collectors方法详解" class="headerlink" title="Collectors方法详解"></a>Collectors方法详解</h2><h3 id="零、准备"><a href="#零、准备" class="headerlink" title="零、准备"></a>零、准备</h3><ul><li>本文的解释是基于JDK11版本，JDK8之后新增的方法会标识出来。</li><li><code>Collectors</code>类是<code>java.util.stream</code>下的类，主要作用就是对流的处理，需要明确一点的是该类的方法与stream类中有一些方法作用相同，比如说<code>stream.count()</code>和<code>stream.collect(Collectors.counting())</code>。这里相同的两个方法使用<a href="https://stackoverflow.com/questions/68017820/what-is-the-difference-between-stream-count-vs-collectors-counting">场景</a>不同：比如说当你想分组时计数则就需要用到<code>Collectors.counting()</code>方法了。</li><li>我们创建两个用于演示的集合<code>list</code>和<code>stuList</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">        int age;</span><br><span class="line">        String name;</span><br><span class="line">        String gender;</span><br><span class="line">        //构造</span><br><span class="line">        //set get</span><br><span class="line"> &#125;</span><br><span class="line"> Student s1 = new Student(11,&quot;s1&quot;,&quot;man&quot;);</span><br><span class="line"> Student s2 = new Student(18,&quot;s2&quot;,&quot;man&quot;);</span><br><span class="line"> Student s3 = new Student(16,&quot;s3&quot;,&quot;woman&quot;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> ArrayList&lt;Student&gt; stuList = new ArrayList&lt;&gt;(Arrays.asList(s1,s2,s3));</span><br><span class="line"> ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;1&quot;,&quot;2&quot;,&quot;7.34&quot;));</span><br></pre></td></tr></table></figure><h3 id="一、计算操作"><a href="#一、计算操作" class="headerlink" title="一、计算操作"></a>一、计算操作</h3><h4 id="1-求平均数"><a href="#1-求平均数" class="headerlink" title="1.求平均数"></a>1.求平均数</h4><ul><li><code>Collectors.averagingDouble();</code></li><li><code>Collectors.averagingLong();</code></li><li><code>Collectors.averagingInt();</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将String转成Double求平均数</span><br><span class="line">Double res = list.stream().collect(Collectors.averagingDouble(Double::parseDouble));</span><br><span class="line">//将list中元素做处理再转成Double求平均数</span><br><span class="line">Double res1 = list.stream().collect(Collectors.averagingDouble(d -&gt; Double.parseDouble(d) *2));</span><br><span class="line">//同理有averagingInt，不过他返回一个Float</span><br><span class="line">//同理有averagingLong，他返回一个Double</span><br></pre></td></tr></table></figure><h4 id="2-求总和"><a href="#2-求总和" class="headerlink" title="2.求总和"></a>2.求总和</h4><ul><li><code>Collectors.summingInt();</code></li><li><code>Collectors.summingLong();</code></li><li><code>Collectors.summingDouble();</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer res7 = list.stream().collect(Collectors.summingInt(Integer::parseInt));</span><br></pre></td></tr></table></figure><h4 id="3-求个数"><a href="#3-求个数" class="headerlink" title="3.求个数"></a>3.求个数</h4><ul><li><p><code>Collectors.counting();</code></p><p>用于统计流中元素的个数。（因为在流的处理中会对集合的元素个数有影响，当流没结束时，直接获取集合size会出现问题）<br>不过他返回的类型是<code>Long</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Long res2 = list.stream().collect(Collectors.counting());</span><br><span class="line">//在没有对集合进行例如filter等操作时，他是相等于直接获取size()的</span><br></pre></td></tr></table></figure><h4 id="4-求最大最小值"><a href="#4-求最大最小值" class="headerlink" title="4.求最大最小值"></a>4.求最大最小值</h4><ul><li><code>Collectors.maxBy();</code></li><li><code>Collectors.minBy();</code></li></ul><p>​       接受一个比较器(比较方式)作为参数，用于计算流中所有元素的最大值和最小值。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stuList.stream().collect(Collectors.maxBy(Comparator.comparingInt((Student o) -&gt; o.age)));</span><br></pre></td></tr></table></figure><h4 id="5-汇总"><a href="#5-汇总" class="headerlink" title="5.汇总"></a>5.汇总</h4><p>返回一个统计对象<code>IntSummaryStatistics</code>，该对象里包含【平均值，最大值，总和，最小值，长度】</p><ul><li><code>Collectors.summarizingInt();</code></li><li><code>Collectors.summarizingLong();</code></li><li><code>Collectors.summarizingDouble();</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics res8 = stuList.stream().collect(Collectors.summarizingInt(Student::getAge));</span><br><span class="line">res8.getAverage();</span><br><span class="line">res8.getCount();</span><br><span class="line">res8.getMax();</span><br><span class="line">res8.getMin();</span><br><span class="line">res8.getSum();</span><br></pre></td></tr></table></figure><h3 id="二、处理操作"><a href="#二、处理操作" class="headerlink" title="二、处理操作"></a>二、处理操作</h3><h4 id="1-映射规约"><a href="#1-映射规约" class="headerlink" title="1.映射规约"></a>1.映射规约</h4><ul><li><p><code>Collectors.mapping();</code></p></li><li><p><code>Collectors.reducing();</code></p><p><code>maping</code> 方法指将一个流中的内容进行映射变换操作，<code>reducing</code>方法指对流中数据进行规约处理操作。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stuNameList = Stream.of(studentA,studentB,studentC)</span><br><span class="line">        .collect(Collectors.mapping(Student::getName,Collectors.toList()));</span><br><span class="line">Optional&lt;Integer&gt; res = Stream.of(studentA, studentB, studentC)</span><br><span class="line">        .map(student -&gt; student.name.length())</span><br><span class="line">        .collect(Collectors.reducing(Integer::sum));</span><br><span class="line">Integer resInt = res.get();</span><br></pre></td></tr></table></figure><ul><li><p><code>Collectors.collectingAndThen();</code></p><p>集合先进行第一个参数 map（映射）操作，再进行第二个参数的reduce（归约）操作。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//下例是将数组中元素先 *2 再求平均数的一个操作。</span><br><span class="line">Double res4 = list.stream().</span><br><span class="line">        collect(Collectors.collectingAndThen(Collectors.averagingDouble(Double::parseDouble),d -&gt; d *2));</span><br></pre></td></tr></table></figure><h4 id="2-处理"><a href="#2-处理" class="headerlink" title="2.处理"></a>2.处理</h4><ul><li><p><code>Collectors.joining();</code></p><p>可以以顺序拼接元素。我们可以传递可选的拼接字符串、前缀和后缀。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String res6 = list.stream().collect(Collectors.joining(&quot;-&quot;,&quot;[&quot;,&quot;]&quot;));</span><br><span class="line">//res6 = [1-2-7.34]</span><br></pre></td></tr></table></figure><ul><li><p><code>Collectors.groupingBy();</code></p><p>对集合进行分组操作</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; res5 = stuList.stream().collect(Collectors.groupingBy(Student::getGender));</span><br></pre></td></tr></table></figure><ul><li><p><code>Collectors.groupingByConcurrent();</code><br>相对于<code>groupingBy(),</code>它更能满足：不要求顺序（无序），更需要并发的分组操作。</p></li><li><p><code>Collectors.filtering();</code>       Java 9</p><p><code>Collectors.filtering()</code>方法类似于<code>Stream filter()</code>方法，后者用于过滤输入元素，但两者的使用场景不同。<code>Stream filter()</code>在stream链接方法中使用，而<code>Collectors.filtering()</code>方法被设计和 <code>groupingBy</code>一起使用。</p></li><li><p><code>Collectors.flatMapping(); </code>   Java9 </p><p>它允许我们处理嵌套的集合，在其中再进行流处理</p></li><li><p><code>Collectors.partitioningBy();</code></p><p>是一种将流的元素始终分为两部分的方法。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; stdByClass =</span><br><span class="line">            stuList.stream().collect(Collectors.partitioningBy(s -&gt; s.getAge() &gt; 15));</span><br></pre></td></tr></table></figure><h3 id="三、转化操作"><a href="#三、转化操作" class="headerlink" title="三、转化操作"></a>三、转化操作</h3><h4 id="1-基本转化"><a href="#1-基本转化" class="headerlink" title="1.基本转化"></a>1.基本转化</h4><ul><li><p><code>Collectors.toCollection();</code></p><p>返回一个Collection集合，（集合层次结构中的基类）</p></li><li><p><code>Collectors.toMap();</code></p></li><li><p><code>Collectors.toSet();</code></p></li><li><p><code>Collectors.toList();</code></p></li></ul><h4 id="2-其他"><a href="#2-其他" class="headerlink" title="2.其他"></a>2.其他</h4><ul><li><p><code>Collectors.toConcurrentMap();</code></p><p>返回一个支持并发的Map,代价则是它是无序的。</p></li><li><p><code>Collectors.toUnmodifiableList();</code>   java10 </p></li><li><p><code>Collectors.toUnmodifiableSet();</code></p></li><li><p><code>Collectors.toUnmodifiableMap();</code></p><p>返回一个不可变的集合，即不能对它进行增删改操作。与<code>stream.toList();</code>一样。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业环境中使用RocketMQ进行消费的常见问题</title>
      <link href="/record/2022/06/11/%E4%BC%81%E4%B8%9A%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8RocketMQ%E8%BF%9B%E8%A1%8C%E6%B6%88%E8%B4%B9%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/record/2022/06/11/%E4%BC%81%E4%B8%9A%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8RocketMQ%E8%BF%9B%E8%A1%8C%E6%B6%88%E8%B4%B9%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>消息队列主要适用于 解耦、异步、削峰的业务场景。</p><p>它可以优化业务的逻辑链路，对高数据量高并发场景进行优化。</p><p>它主要分为生产-存储-消费 三个阶段，这篇文章来说一下使用<code>MQ</code>进行消费会遇到的常见问题。</p><p>本篇以<code>RocketMQ</code>为场景，它是一个比较成熟的消息队列，并且在不同的业务场景的需求都有一些已经封装好的实现。</p><h4 id="1-消费消息时消息丢失"><a href="#1-消费消息时消息丢失" class="headerlink" title="1. 消费消息时消息丢失"></a>1. 消费消息时消息丢失</h4><ul><li><p>生产者丢数据：</p><p>只要消息正常发送出去就不会在生产者这里丢。</p></li><li><p><code>MQ</code>丢数据：</p><p>原因：<code>MQ</code>宕机，网络抖动等。</p><p>解决：</p><ul><li><p>做集群处理（一主多从）</p></li><li><p>修改消息保存机制为同步刷盘方式，即消息存储磁盘成功，才会返回响应。</p></li><li><p>集群复制改为同步复制（默认是异步，这个会慢）</p></li></ul></li></ul> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## master 节点配置</span></span><br><span class="line"><span class="string">flushDiskType</span> <span class="string">=</span> <span class="string">SYNC_FLUSH</span></span><br><span class="line"><span class="string">brokerRole=SYNC_MASTER</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## slave 节点配置</span></span><br><span class="line"><span class="string">brokerRole=slave</span></span><br><span class="line"><span class="string">flushDiskType</span> <span class="string">=</span> <span class="string">SYNC_FLUSH</span></span><br></pre></td></tr></table></figure><ul><li><p>消费者丢数据：</p><p>原因：消费业务执行过程中丢了</p><p>解决：</p><ul><li>优化业务逻辑，参见<code>3. 4.</code></li><li>业务逻辑真正执行成功，我们再返回消费成功状态： <code>ConsumeConcurrentlyStatus.CONSUME_SUCCESS</code>。</li></ul></li></ul><h4 id="2-消息队列的消费策略选择"><a href="#2-消息队列的消费策略选择" class="headerlink" title="2. 消息队列的消费策略选择"></a>2. 消息队列的消费策略选择</h4><ul><li><p>集群模式(常用)</p><p> 一条消息只会被多台消费者中的一台收到并消费（控制台可以查询每条消息被谁消费）</p></li><li><p>广播模式</p><p> 一条消息会被发送给每个消费者（会有重复消费的问题）</p></li></ul><h4 id="3-对于消息实时性要求较高出现的消费消息积压高延迟问题"><a href="#3-对于消息实时性要求较高出现的消费消息积压高延迟问题" class="headerlink" title="3. 对于消息实时性要求较高出现的消费消息积压高延迟问题"></a>3. 对于消息实时性要求较高出现的消费消息积压高延迟问题</h4><ul><li><p>原因：</p><ul><li>消费时处理太慢，导致收到消息后花了大量时间进行导致阻塞。</li><li>消息队列数据量特别大，并发较高。</li></ul></li><li><p>解决:</p><ul><li><p>优化业务逻辑，以去重场景为例（以消息内容的某几个字段来进行判断去重）：</p><p>​    入库如果数据量大的话去重可以用联合主键的方式进行去重，如果数据量不大可以进行<code>HashSet</code>去重。</p></li><li><p>增加消费者的数量（服务器台数）。</p></li><li><p>设置消费者线程数量，适当设置消费者线程（根据机器配置设定）。</p><ul><li><code>PS</code>：<code>RocketMQ</code>的消费逻辑有并发消费（<code>ConsumeMessageConcurrentlyService</code>）与顺序消费（<code>ConsumeMessageOrderlyService</code>）两种，并发消费会导致消息读取顺序乱的问题，如果对此有业务要求，则不能进行多线程消费。</li></ul></li><li><p>存<code>Redis</code>并设置过期时限，<code>Redis</code>中数据慢慢向数据库中同步，数据先从<code>Redis</code>读取，最终保持数据都能落到数据库中。</p></li></ul></li></ul><h4 id="4-消费者重复消费问题"><a href="#4-消费者重复消费问题" class="headerlink" title="4. 消费者重复消费问题"></a>4. 消费者重复消费问题</h4><ul><li><p>消息本身重复：</p><p>解决：根据消息内容做去重处理</p></li><li><p>消息重复发送：</p><p>解决：根据消息的<code>MsgId</code>为主键建立一个对照表，接收消息的时候拿<code>MsgId</code>插表，插入失败即为重复。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随想</title>
      <link href="/record/2022/04/14/%E9%9A%8F%E6%83%B3/"/>
      <url>/record/2022/04/14/%E9%9A%8F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>​    晚上总是会思考自己的一些东西，有时候会看别人生活分享的一些视频，不同于往日看到的一些正能量、像电视剧一样每个人都衣冠楚楚看起来就是家境优渥的一些博主分享自己的生活的视频，近些时间晚上看偏向普通人生活记录的视频更多一些，有三和大神、大中专进厂、大猛子、大厂员工等等。我是普通人，看这些我仿佛看到了走了不同路的自己。</p><p><img src="https://raw.githubusercontent.com/dianedii/picBed/main/1531649916380_.pic.jpg" alt="Pasted Graphic.tiff"></p><p>​    如果现在还在读高中，未来的路是很多的，有大把的选择。但是比如在选择了要学计算机的时候，其他的路就会突然消失不见，就是只要做出了选择，就会丧失其他所有的路。突然想起来，几年前我叔在吃饭时时常提起科学的尽头时神学之类的东西，谈及这些详细展开便总是谈到科学家根据爱因斯坦的相对论提出的时间穿梭理论：时间向只能向过去穿梭，穿梭的话就是跑马灯似得时间倒流，但是如果向未来穿梭，却什么都看不到。因为找不到未来的路，未来如百风溯流一般，有无限的分支。</p><p>​    所以，我看他们的分享的生活，就感觉在看做出了不同选择的自己在给自己诉说，假如我大学念了土木，我就是大猛子。于是我就像在审视自己一样。到这里发现大部分的分享中是有一些相同的生活的内核在里面的，这个内核是悲剧。人的欲望、人的欲望得不到满足、人的身老病死、人的无能为力，这些其实是占据生活中的大部分，而幸福感、快乐是作为生活的一个调味品和点缀。</p><p>​    我想说这个是因为我发现我在我最有精力充沛、最应该美好的年纪里，我并没有感受到愉悦。当然，这个是与个人的感受更相关，我肯定比乌克兰人民要幸福，但是我想说的是一个追求的问题，什么阻拦着我感受到生活的幸福？</p><p>​    其实我是想说社会环境的，当然自身问题占一半，就外在来说，现在环境（对大部分人）不好，不巧我就是芸芸众生之一，新冠感觉可以陪我十年甚至更久，看到了社会的更多灰面让我觉得我党也只是一个普通的政党，我应该赶上了中国人口最多的时期，也是最内卷的时代， 不知道该在这个时代中怎么以适合的方式生存下去，但也念了些书不想就如此庸庸碌碌一辈子。想了一年多也没想出什么结果来，或者潜意识刻意避免去想这个问题：我该如何生活？</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被吐槽代码风格</title>
      <link href="/record/2022/03/26/%E8%A2%AB%E5%90%90%E6%A7%BD%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
      <url>/record/2022/03/26/%E8%A2%AB%E5%90%90%E6%A7%BD%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p>前几天被同事吐槽代码风格差，说的还是相对比较婉转的，但是当事人十分尴尬。</p><p>总结一下<code>Code Review</code>时的问题，有的是我的，有的是别人的。有则改之，无则加勉。</p><ul><li>判断不完整：判断逻辑没有<code>else</code>导致部分情况没有处理。</li><li>代码中经常出现类似<code>&quot;1&quot;</code>这种常量：需要定义常量然后再去使用常量提高代码可读性。</li><li>一个工具类实现了两遍：即创造新函数/类时，先看看是否既有方法已经实现过。</li><li>开发时尽可能多打日志。</li><li>命名规范问题：就算是临时变量也需要规范命名，禁止出现<code>tmp</code>、<code>tmp1</code>之类的变量。</li><li>代码注释：写不了好的代码就多写注释。</li><li>日志打印级别：不要都打<code>info</code>….。</li><li>善用枚举：提高代码可读性，规范性。</li><li>尽量避免循环调用<code>SQL</code>/接口：<code>SQL</code>多用<code>IN</code>等，接口尽量规避这个问题。循环调用会十分影响性能，因为你不知道会循环多少遍。</li><li>避免方法过长：考虑做拆分，优化逻辑，也为了更好的单元测试。</li><li>空值检查：对于一个不确定来源的值，一定要做空值判断。值判断这部分最好在Controller中统一去做（注解很全面也很方便）。</li><li>重要/核心逻辑一定要有单元测试。先设计测试再写逻辑。</li><li>不要写双重否定的逻辑：<code>!isNotBlank(param)</code>。</li><li>方法命名规范：英文不好去找翻译…不要怕名字长，就怕意思不对。</li><li>配置禁止写死在代码中：拿到配置去。</li><li>定义数字类常量推荐：<code>ONE_DAY = 24 * 60 * 60</code>，而不是<code>ONE_DAY = 86400</code>这种。</li><li>避免维护是直接修改原来方法的逻辑：尽量用静态代理的方式去写新逻辑。</li><li>代码顺序的问题：尽量写块状代码，逻辑分散会非常影响可读性。</li><li>不要用<code>System.out.println()</code>和这种类似的东西。</li><li>不要过于追求好看/简洁：写一行长长的不如把它分解成多行易懂的。</li><li>提交前删除掉注释的代码。</li></ul><p>这几天总在意代码风格的问题，之前都不甚在意，只觉得按期能上就行。现在看之前自己写的东西，吐槽都不知道从哪开始。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码风格 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>率土之滨游戏资源文件提取和我的回忆</title>
      <link href="/record/2022/02/21/%E7%8E%87%E5%9C%9F%E4%B9%8B%E6%BB%A8%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E6%8F%90%E5%8F%96/"/>
      <url>/record/2022/02/21/%E7%8E%87%E5%9C%9F%E4%B9%8B%E6%BB%A8%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E6%8F%90%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p>前因：</p><p>​    上初中的时候和朋友玩网游「征途2S」，武侠的世界让我痴狂，尤其是背景音乐更是觉得莫名的好听。之后用听歌识曲也识别不出。</p><p>​    上了大学后，突然又想起这点回忆，又下载了这个游戏，可惜昔日的好朋友已经变成了陌生人，我一个人又重新注册了账号，玩了半天。回忆过后，又拿识曲软件辨识半天还是没有结果，灵机一动打开游戏安装后的文件，翻了翻找到了存音乐的文件夹，完全没有加密，我把所有地图的背景音乐都拿出来传到我的网易音乐云盘上面，一直听到现在。</p><p>​    上大学几年后又开始接触「率土之滨」，武将的立绘很符合我的审美，但是游戏里只能看到左半边无遮挡的图，我想能不能像取之前的文件一样，把游戏里的图片资源取出来呢？结果网易给我上了一课，他们把所有的资源文件都加密成了<code>.npk</code>，解密的话要逆向破解出密钥，我从「吾爱破解」上学习怎么逆向，但这是一条很深的路，我从<code>C++</code>，看到虚幻引擎，到抓包工具，再到<code>unity</code>，最后到逆向教程。我试了三天，没弄成功。</p><p>​    前几天机缘巧合之下，在新浪博客看到一个大佬，和他的网易游戏资源读取软件。试了一下，发现逆向失败，但没完全失败。软件执行了一半就报错，执行不下去了。但是在半成品中我看到了些有点像图片的文件，但是这些文件大部分是没有后缀的，所以只有几张可以打开，没错，就是我要的东西。</p><p>​    我写了个程序，给所有没有后缀的文件加上.jpg，然后根据图片尺寸把它们分类，就有了现在的结果，大部分的任务立绘都是方的，我整理出来它们的皮肤，放到了<a href="https://github.com/dianedii/GameWallPaper">这里</a>。总算是达成愿望。</p><p>PS：王异的立绘很棒，我尤其喜欢她的脸，英姿飒爽又知性温柔的感觉，不好的地方是大腿漏太多感觉对于整个的人物形象有些负面作用。</p><p><img src="https://github.com/dianedii/GameWallPaper/blob/main/002_card-000253-0445D584-00025588.jpg?raw=true" alt="王异"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈(11期)</title>
      <link href="/record/2022/01/30/%E6%9D%82%E8%B0%88-11/"/>
      <url>/record/2022/01/30/%E6%9D%82%E8%B0%88-11/</url>
      
        <content type="html"><![CDATA[<p>杂谈：</p><ul><li><p>最近母亲看我现状好像不太好的样子，对我之后能否娶到老婆比较发愁。我在各个社交软件（<code>soul</code>、贴吧、<code>QQ</code>等）上观察发现，不仅是我，有很多女生单身，有很多男生单身，但是他们都热衷于找对象。我找到了以下原因：</p><ol><li>对于大部分女性，她们一般会倾向于找比自己强的另一半，由于身边与网络上优质男性资源多，于是就导致<code>80%</code>的女性只想找前<code>20%</code>的优质男性。在满足不了要求的时候，也不会看剩下<code>80%</code>的男性，而是继续找。</li><li>未婚的青年也能很清楚的看到婚后的情况，尤其是会主观的放大婚后的缺点。并且会与目前的单身生活去做对比，得到一直单身一直爽的结论。</li><li>对于大部分男性，找对象是为了结婚，而结婚会让男性和其原生家庭有了一笔很大的支出（彩礼、车房…）。</li></ol><p>我觉得这三点是比较基本的问题，其实究其根本大家还是发现结婚并不能让我过的更好，从利益上来讲是<code>1+1&lt;=2</code>的概率更大。</p></li><li><p>喜欢的一样东西，突然超量满足我的时候，我突然就不喜欢了。</p></li><li><p>基金赔了好多，现在心态好了很多，赔好多也不会很心疼，可能是还不够多吧。</p></li></ul><p>言论：</p><ul><li>她并不物质，但打动她的每个环节都需要钱。</li><li>生活原本很沉闷，但跑起来就会有风。</li><li>不要给别人提人生建议。</li><li>一切总会有个结束，只有自己会陪着自己。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 期刊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天津-元旦记</title>
      <link href="/record/2022/01/03/%E5%A4%A9%E6%B4%A5-%E5%85%83%E6%97%A6/"/>
      <url>/record/2022/01/03/%E5%A4%A9%E6%B4%A5-%E5%85%83%E6%97%A6/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4f599787bd29ba43c94304017bea8670ff2ad2e65cb389b1fe771d06eaf918b1">73ec4e90604b298de70b40cddedb7a133c8d90d361cd2f1c12937babcdc202f7f9c7662826c69a7493c0ec2531642e579be06f52e0ee8f584fd1f580e221e5181d7a447ca15776b405f27d2d9e42fa95840226810fc519b7a745f08a3d9e09ecf352bcaea74d23cdf7ddc87d44eb6d1c361e5bdaa5bb25282289e06d3b0a485f7c2abb1f82d6c45e70df6dae390db108285d8558c0d75318b44e2cf18ff1cd1e98816db60897c9c0830244a252bb05dbd1f115a3939616100b2e11a75f1ca8370549fb3a74818f1112a979f693defa56a7c5dbae14c55d4bfbdd008293077b8fe978529884e7e169c4a3a8a8c1a0ac5136726865c31b5fbbb8a08d7a1d6f3da109802d14e35430dcfddcc965c3157cd61957437f85883c7ab03902c26457674903bce2880675543a89d6a9953027f2780b16c2b9818751523bd9d2c000785111dd01b841638a289f7a0824c3fc9145c5f8e72beda1e9fba9e1cc365364b1ef16b675f1ef014412ef15b768f749b56b9d4842faf48a6d941ddef1bd73fc0103275d378cd220c397c39ad66215445fe16c71885528df5b2b61a5812c4fdb9ae49a05f4eb08eca37b598facabb5693c377c4d14955f072442a635027f70075a47d572a0ea0ace0f66b368b211462b7f843b9f8a70ea5e097b5f94763bfff18e1967b2173ca8294c3aa6158650f916d2c80db38553724ffdcd97a54e8600b521ec5e244f0c1bbaab9134dc555fac26236d670fa473b630607ef7cfe622952e4759f2361d584486bbac3fc90ceb0fda87fd16ebacf529990d34c75f929a7c0aceee7237115914a253a38075b81b3609920629dff748b95051e9efe2109078b5b1fe422db1f72bed140a1122352c58a778111de3daed80c2ceab50eac88172394aee37c7df0bbb135f416caee72e68bd29b99defb6f40fbe544d5d35eb9b153086757e592352dd17837d461a5ec950e6216b38efcda5ea5f4047c35e88fb4d5fafd3772500b2eea8375edf5bc4bf3d845e19eb9067d5b2ff0397ee882cd93b815a8c078860dd53d545c300b276ca5f14bf0b430d935b1566cb86a191f78c0dd6f599b604f4910b8345ed17314f1ddaa805c26c05c227c4d2c7cf0dee68a6f3bdccbe12436a07d4e221bc16aff4013a27d61fd22f038212a2d8a5b9903ac33581d3559b70d1fa5de018f5b08481ec334157447c0e7f64d2389966d87ea160cb61ed9fa68c0a75a4eda564cb4a3bb97b7b9cc9c3ec221831e98df6e650fa4c44ea9825cab8756c492e5a668218cb05a55989c53b61a90b99b09a9dda7128d0ee74fc1302b0eee7d6bb8b018defd8eb611dce21bcb221a58d88b8f1d4ded8b1afa8259a3486b38e7e0e37a181fcea0af2ea2040bfc45ac7b621fd63c196d9dc7e66a2d700fa2bfcd68d708e97b82a120810fbe8f7e878f2a660a6fca09fd65fc76b06012b2dbee67375ae343310a9c0b78b464b36fd1f4db8340049e1d1b461fd8ce9648be432ef1c8a2c20d1076d48652929cdb3401411d68f022f949ff9b27482548885d8828f00c4503c83fcfe98a8512e8bb8a4913b0066bde4f5eec7dcabb06a0fe6dd9650fefa88a217fd38479f1bb16d2272ddbf432f400ee2b26f8035950bf0ab593392500adbab398fe9c6f69f4529c0e9a1212de3678e143060ba16c8da1f23da4b929c995af1a846bbb91547cdab11fc9cdb444054c97831a01406f38460e434ae40ada568620dfbad261f2576923bc5582998c2ec4517256bb550a62aaece182fc99ebd489e0ed27d51c629930623cafbb1ad71e86499e117aca0e0fda363636694e7bab6e691ef96a013f6de4a7c2c07db2a58847e8d663165b342dbe993b857fb43aab549fe1fd790f05602a68ab0d73179334f02427e8b6e9449623c406ae3e238f676fc239e8cf788db6dacc0b160c56f2af0b02c3e84f854edae74071375478651304f286e64103e7125447cde14fa9fe06857e0ba51e157f37e47c7a2b0ccdc620f15b34013b1daf27fe7e3acd603599464ed71648fa694e3c9b234d40dfe176614e62d407bbde95e53c9d9720a20a4112b6aa119c7ade8899a56400504c6d9decc739ff717c9fcff8d664105c51810c993688e43e9e907a52a21ab87645e116ff5ae5d6e0d4c0b1fc1430c8b300b564f159c14438f511dd491b74876ace5537526b577eba355e2d241c0f97bc9d3680cf2bede3ab534a1ac72840eda697907a87d7c0194d3e4fc2a2ff122b42410738f7bd7c9da94aae487a2f2fbbc32d60ed02947fa95a385d69874d7f05c0379a93c1b97369e126fcedd24aad6980f1be4c52ee849233012bde4369d26dca423fb6bcfff0f57602bdbb653e2f84dd78038c15000ecf31c6b75c4b1cfcd515c0bac5179c14bdc65684941019512e7c82d40d0900cabca3e27d9278baefa4a05b6b0bf355f5f3619757a959d3998c64a5ca971bd9441428655fd08033e263cbfc948cb1af2681ab79835f0a38cb5c636d76b09b5485fd13a196e7ecc66872dcf4db09b0f20589c8d120c336fb7c1cceffa102534862b035b87925495de4c302c9dc7001a0b01f9b44d1c77fe44f6b560bdb26619bfd79118708f7bc21d27c888fe5d20324983febba38ff87e819f1fa031c7bff22ef597bd753ac7ce42a69db3853f333b3cb6e1c3667ebae554382d9ef29fe3a8846533f8877d07c3372e70146079655bb15e5f01d4149c3c79ff9b8f405a127646bcf05f752274a02c1c269dce6e2d77f200a1ca08db3437db14cf4e0d53ac179907d56f585064a2bbfc77501a4b6cb1c0f8a91c7554ef48195ba373cf079e1bb2a4f64f8fe07027308a44d194f6e11762338cdfeabd8a7e0e81798ba4e1354a3cbb82a382dcb166d11781af794bdb877add46a064556c95b891c3889f5f8f23f64cf99ab78f7524a916401eff19fbd68dcfbd6430799ba64faa04e489f619f7837168af146880e4b2267350912321beefcdb415afb087435f21059f1902fce6c1cef43a98294c213a63d73e53fd3bc9fd014fb3419d7cb373ea8bc2749ff18f772bec86df8082ce41c211dd90f2b4051796f94bcd18c1b9e77e6fcb38c4ed298d2b1ca9e3b41401d9dd47289703bcce344761758d3971f6592681875b22c0b1670ba06429203e60e684ccd4eeb1eac11e97d29f6d7cf2d01584420bdbf6f79c47d156026a83c32c8d428147420bcdcd008c84b6556e072019b93e9e34292f8f7c6f3d80c82e945386d76b6ee872a626ae467569bcd07954896584327886741ea8cd1cfd05f9742d66cbac107c9e665d5db65f3f89c0c27217138effb1342925cce0ae4cdb0935ba11b1bde3107f1d418d792ab46f01c95e42188881942120e16ba650451b3b480a4403a6d694a6f25c86b5ea92745cd2ae058c90ffeca4de01beefcabcbf9783f196c92603d7b8bff1e94d1e5c341529c83066705635e21725cdf4f4eac85b07e554129ef506d9a8f9b501a3148c27bdad0905ff18d002dee1c45efd4867af6a772080464a731021f5dbe19a1a731ccf1154862257d2d68df62db068d326d38c2bed6aa8e61235af6dac0b1457bc976ddf433a77dabc20c4d14f8e1cc1ea7599ab2a0992cd28873c57a0d8cc79302f6f93a7942a9f52af98a88fa1bb5b4d6526bb62e7b1a0292048c8ef0125dcb9048f4e9ce71a1df2b504c0e02a665715075a36f049d3903b17eac33bef9fd8aa76dc6323e4a7734ae1378d772877b86de25d4b5e07980b8010cb17d3b570581049594a23dedaedade572bfd7244705de45abb2238bec2278b4fbfc9e209cc8cf291d4c3018569759c2177b6ac01c86940609dd4ba9cd6d2dbb4825707a6c7a97f4cf7f02e036ca1c3846049c9ff56dc0653fe268d34a48c9cbb623469a1ce0060cd1575ea6311439fa72cfc668d259c3a2b1fb9157325dce3f5393991b18f59a3f7ee90cdb21bb626ed91ad99bdc2efec75c8814b647a4096a4bb8a171c8343c10d707875665213e1a5a4b87924795c225cc791a2be1fe513f169b442a5030522903e35d8520fdb78e27dfad730494e89d5f0489f9a831f5279ec4621e8743554a4a4fa628b30de0999f42b0343f343641e5a7299f51f6da2228dbdfb2b4f007edb59719c0a9a1fa3938ed83346854a52b5266706e93f796aa09b9b152d09779b6300c956cd0426570ee42f018435d0553744777153bf7e306fc2278885f6508988b5ffc8f6a1c41832aebcf5b9c42ef2c2f9b772d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/record/lib/hbe.js"></script><link href="/record/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冬梦-1</title>
      <link href="/record/2021/12/19/%E5%86%AC%E6%A2%A6-1/"/>
      <url>/record/2021/12/19/%E5%86%AC%E6%A2%A6-1/</url>
      
        <content type="html"><![CDATA[<p>​    在玩手机的时候突然回到了日本侵华战争前期。我住在大城市，城市里有租界，里面有日本人、沙俄人、还有英国人，美国人。我是晚清清的最后一批举人之一。我穿越回来的场景就是我的穿越身体正在家里看书的时候。明天日本人就要接管这座城市了，接管后每家门口，单元楼门口，小区门口火车站门口都会有日本兵。我穿越过来是手里还拿着手机，一看屋里还有一人，正是母亲，我想了一会决定今天就跑去美国避难，但是母亲不同意，觉得好好的为什么要走。我跪下磕头边求边说日本人来了会折磨死我们的。明天他们就要接管这里了，今天赶紧跑。母亲同意了，我们带了所有的钱和一些衣服一共两个大包就到了小区门口。门口有好多外国人，然后有个沙俄人示意让我过去，他自称约翰.诺森，想给我发一枚勋章，我说这勋章干嘛的？他说给我的，我说拿了他要承担什么责任吗？他说要每年参加比赛，我说算了我不要了，他也说算了，不来也行，勋章还是给你了。我带着母亲出了小区就往前走，走到公交站台这里，刚开没多久6路车就来了，这站是始发站，我们的第一个目的地火车东站是终点站，我们找了末尾的两个位置，长舒了一口气，我那手机查1935年去美国能干啥，手机竟然还有网。</p><p>​    梦醒了，这个梦梦的很精细，所以主线推进的就慢一些，我还大致能回想起梦中刚看到母亲第一眼的场景，<code>3D</code>建模了属于是。</p>]]></content>
      
      
      <categories>
          
          <category> 梦 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记一次上线事故</title>
      <link href="/record/2021/12/18/%E4%B8%80%E6%AC%A1%E4%B8%8A%E7%BA%BF%E4%BA%8B%E6%95%85/"/>
      <url>/record/2021/12/18/%E4%B8%80%E6%AC%A1%E4%B8%8A%E7%BA%BF%E4%BA%8B%E6%95%85/</url>
      
        <content type="html"><![CDATA[<ol><li>事件描述</li></ol><p>背景：一个月会进行两次上线，上线前四天会进行代码封板。</p><p>在上线前一天我提交了和本次上线无关的代码（修复其他问题代码提交），但是由于没有测试到位，这次提交的代码会引发新的问题，影响项目上线。在上线当天晚上，运维同学拉取了最新的提交打包制作镜像。在上线后部署就产生了生产问题。</p><ol><li>总结</li></ol><ul><li><p>代码提交没有进行完整的测试仅是本地自测通过就直接提交仓库，这个完完全全是我的问题。</p></li><li><p>没有重视上线的规章制度和没有严格实行封板的要求，运维同学应该拉取的是封板那天的包来打镜像。</p></li></ul><p>规章制度都是前人总结出的能在项目进行中的最佳实践的总结，不能怕麻烦或者嫌多余就忽略或跳过规章制度。被DISS的感觉很不好受，虽然不完全是我的原因，但是总归是我引发的这个问题。:&lt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冬梦</title>
      <link href="/record/2021/12/11/%E5%86%AC%E6%A2%A6/"/>
      <url>/record/2021/12/11/%E5%86%AC%E6%A2%A6/</url>
      
        <content type="html"><![CDATA[<p>​    我是一个没念过书的青年，整天浑浑噩噩的。有一天我去找别人打乒乓球，有两桌人，我在一桌排队打了一阵子，然后跟我一块打的一个人的姐姐来了，他们姐弟关系不太好，姐姐说弟弟没出息，当场起了点小争执。打完球回去用微信跟一个女人聊天，然后她不知道为啥就过来我这了。在我家院子里，我把她杀了，杀了但是没有血也没有尸体，只有衣服杂物。我想起了隔壁房间有个红色很老式有两个扣子的那种箱子，我坐在炕边准备把这些东西放到箱子里。在一股脑的把东西都扔进去，在箱子里她的钱包从衣服里划了出来，我在钱包里找到<code>4800</code>现金，钱包里还有很多卡：购物卡，机动车驾驶证，还有两张银行卡。全部放完后，我准备用药水连箱子一块腐蚀掉，药水效果奇佳，药效是溶解所有东西能连渣都不剩。这会母亲突然回来了，说要我去城干份力气活，我答应着但是脑子里想的都是怎么在她不被发现的情况下把箱子烧掉。家里穷，少个箱子一定会被发现。我想早点走，带着箱子装作行李。我找母亲说帮我联系每天早上五点去城里的车客，她说太早了吧，我表现出挣钱心切的样子。</p><p>​    梦醒了，刚醒的那一恍惚间，我怀疑我是不是真的杀过人。</p><hr><p>​    做梦好像体验了一段不属于自己的人生，可惜梦醒时记忆如潮水般消退，我趁着刚醒赶紧记下这段杀人的经历，梦中具体杀人并没有细节方面的演绎，中间空白了一段就直接跳转到销毁遗留证据的场景了。</p>]]></content>
      
      
      <categories>
          
          <category> 梦 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql索引设计建议</title>
      <link href="/record/2021/11/28/Mysql%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/record/2021/11/28/Mysql%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<ol><li><code>MySQL</code>索引类型</li></ol><ul><li>按字段特性来划分有：主键索引，唯一索引，普通索引</li><li>按字段个数划分有：单列索引，组合索引</li><li>按数据结构划分有：B+tree、Hash、全文索引</li><li>按物理存储划分有：聚簇索引，辅助索引</li></ul><ol start="2"><li>常用查看/优化索引的命令</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看某个表中已有索引情况</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> TABLE_NAME;</span><br><span class="line"># 栗子</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> `<span class="keyword">user</span>`;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>table</code></td><td>表示创建索引的数据表名。</td></tr><tr><td><code>non_unique</code></td><td>表示该索引是否是唯一索引。若不是唯一索引，则该列的值为 1；若是唯一索引，则该列的值为 0。</td></tr><tr><td><code>key_name</code></td><td>表示索引的名称。</td></tr><tr><td><code>seq_in_index</code></td><td>表示该列在索引中的位置，如果索引是单列的，则该列的值为 1；如果索引是组合索引，则该列的值为每列在索引定义中的顺序。</td></tr><tr><td><code>column_name</code></td><td>表示定义索引的列字段。</td></tr><tr><td><code>collation</code></td><td>表示列以何种顺序存储在索引中。在 <code>MySQL</code> 中，升序显示值“<code>A</code>”（升序），若显示为 <code>NULL</code>，则表示无分类。</td></tr><tr><td><code>cardinality</code></td><td>索引中唯一值数目的估计值。基数根据被存储为整数的统计数据计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，<code>MySQL</code> 使用该索引的机会就越大。</td></tr><tr><td><code>sub_part</code></td><td>表示列中被编入索引的字符的数量。若列只是部分被编入索引，则该列的值为被编入索引的字符的数目；若整列被编入索引，则该列的值为 <code>NULL</code>。</td></tr><tr><td><code>packed</code></td><td>指示关键字如何被压缩。若没有被压缩，值为<code>NULL</code>。</td></tr><tr><td><code>NULL</code></td><td>用于显示索引列中是否包含 <code>NULL</code>。若列含有 <code>NULL</code>，该列的值为 <code>YES</code>。若没有，则该列的值为 <code>NO</code>。</td></tr><tr><td><code>index_type</code></td><td>显示索引使用的类型和方法（<code>BTREE</code>、<code>FULLTEXT</code>、<code>HASH</code>、<code>RTREE</code>）。</td></tr><tr><td><code>comment</code></td><td>显示评注。</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看<span class="keyword">SQL</span>命中索引情况</span><br><span class="line">EXPLAIN <span class="keyword">SQL</span>;</span><br><span class="line"># 栗子</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>`;</span><br></pre></td></tr></table></figure><p>字段解释见<a href="https://www.cnblogs.com/xuanzhi201111/p/4175635.html">这里</a>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看当前数据库中索引使用情况</span><br><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Handler_read%&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>索引设计的原则</li></ol><ul><li>适合索引的列是出现在<code>where</code>子句中的列，或者连接子句中指定的列；</li><li>基数较小的类，索引效果较差，没有必要在此列建立索引；</li><li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间；</li><li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li></ul><ol start="4"><li>索引优化的建议</li></ol><ul><li>查询返回结果大于全表总量的30%，别建索引走走全表扫描吧。</li><li>前导模糊查询不能命中索引，如果想要优化可以根据情况看是否能优化为非前导。</li><li>复合索引的情况下，查询条件不包含索引列最左边部分（不满足最左原则），不会命中符合索引。</li><li><code>union</code>、<code>in</code>、<code>or</code>都能够命中索引，建议使用in。</li><li>用<code>or</code>分割开的条件，如果<code>or</code>前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到。</li><li>负向条件查询不能使用索引（比如说&lt;&gt;,<code>not in</code>），可以优化为<code>in</code>查询。</li><li>范围条件查询可以命中索引。范围条件有：&lt;、&lt;=、&gt;、&gt;=、<code>between</code>等。</li><li>数据库执行计算不会命中索引。（计算最好不要放在<code>sql</code>中，而应该放在业务逻辑中）。</li><li>建立索引的列，不允许为<code>NULL</code>，其实数据表设计都尽量不要有<code>NULL</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集群环境下的多定时任务处理</title>
      <link href="/record/2021/11/07/%E5%A4%9A%E5%AE%9E%E4%BE%8B%E4%B8%8B%E7%9A%84%E5%A4%9A%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/"/>
      <url>/record/2021/11/07/%E5%A4%9A%E5%AE%9E%E4%BE%8B%E4%B8%8B%E7%9A%84%E5%A4%9A%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>​        当我们在单体环境下写定时任务是一个简单的事情。但是当定时任务不止一个的时候就会出现一个问题，怎么管理这些定时任务？不进行管理，让他在代码中随意纷飞？如果过段时间出了问题就很尴尬，所以要想优雅的处理定时任务，我们需要达到以下几点。</p><ul><li>统一处理</li><li>定时任务可配置化，即不能为了修改定时任务而重启系统</li></ul><p>​        统一处理是为了便于定位解决问题和提高代码质量，定时任务可配置化是为了更优雅，举个栗子：当需求变更说定时任务的时间需要从一天一次变为一周一次时，我们去改动代码然后重新部署上线真的很繁琐。这样的话定时任务就最好不要写在业务代码中。这里来说一下常用的解决办法，使用<a href="https://www.xuxueli.com/xxl-job/">xxl-job</a>，这是一个常用的分布式任务调度平台，它的思路就是把专门有一个微服务去做任务监控与管理，项目则是另一个服务，当然当定时任务不超过十个的情况下用它还是有点过度引用的感觉，具体使用可以去看官方文档，作者是中国人文档易读。</p><p>​        当然如果定时任务比较少而不用一些三方平台的话，定时任务配置化这块就不太方便了。我们需要用再项目中将定时任务写到一个包里，切忌多人开发时分散的去写定时任务，这些应该是在项目开始就应该规划与约定好的。Java中对于实现定时任务的方式也有很多，比如说：<code>Quartz</code>，<code>Spring-Task</code>，还有<code>Java</code>本身的<code>Timer</code> 。在<code>SpringbBoot</code>下，由于<code>Spring-Task</code>的以注解形式实现比较方便，所以我们一般用它实现定时任务。</p><p>​        这会我们说的定时任务都是在单机上执行的，如果说系统需要多实例运行，即一个<code>nginx</code>负载着多个后端节点，那么这时的定时任务还能正常执行吗？那得看定时任务干什么了，定时任务删东西还好，多个定时任务同时删除一些数据，前一个定时任务删除完后，后一个定时任务可能判断好像没什么要删除了，有时候会造成资源浪费，并不会造成可视的问题，不过我们最好也需要做处理。但是比如说多个定时任务一起发邮件那可就出大问题了。用户会收到数份一模一样的邮件。</p><p>​        所以说写定时任务的前就要想到这里，那怎样去预防这个问题呢，答案就是上锁！我们需要设置一个锁，每次到约定时间时，仅有一个实例可以拿到锁去执行定时任务。常见的几种定时任务实现：</p><ul><li><code>redis</code>分布式锁</li></ul><p>​        我们使用<code>redis</code>的<a href="https://www.runoob.com/redis/strings-setnx.html">setnx</a>命令,我们可以通过<code>setnx</code>将一个<code>key</code>和<code>value</code>写到<code>redis</code>中，当这个<code>key</code>不存在时，<code>redis</code>会正常写入，返回<code>1</code>。当在其中已经存在当前准备写入的<code>key</code>时，<code>redis</code>会插入失败，返回<code>0</code>。</p><p>​        当多个实例准备执行定时任务时，通过<code>setnx</code>用同一个<code>key</code>去插入数据，仅有插入成功返回1的实例去执行任务。</p><p>​        我们简单写一下伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskUtil</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//引入RedisTemplate对象</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//竞争锁方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Boolean <span class="title">getRedisLock</span><span class="params">(String key, String value, Long limitTime)</span></span>&#123;</span><br><span class="line">      <span class="comment">//尝试向redis写入key</span></span><br><span class="line">      <span class="keyword">if</span>(redisTemplate.opsForValue().setIfAbsent(key,value))&#123;</span><br><span class="line">            <span class="comment">// 设置锁的有效时间，防止死锁</span></span><br><span class="line">            redisTemplate.expire(key,limitTime,TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定时任务类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledService</span> </span>&#123;</span><br><span class="line">  <span class="comment">//引入刚写的工具类</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TaskUtil util;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/5 * * * * *&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduled</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(util.getRedisLock(<span class="string">&quot;lock&quot;</span>,<span class="string">&quot;lock1&quot;</span>,<span class="number">1L</span>))&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;1号实例的定时任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>mysql</code>锁</p><p>​    我的思路是新建一张<code>TASK_LOCK</code>表。</p><table><thead><tr><th>ID</th><th>TASK_NAME</th><th>LOCK_TMP</th></tr></thead><tbody><tr><td>主键</td><td>定时任务标识</td><td>锁</td></tr></tbody></table><p>​    <code>LOCK_TMP</code>字段，默认为0。有几个定时任务就加几行数据，定时任务设置仅<code>LOCK_TMP = 0</code>时执行定时任务。执行时根据<code>TASK_NAME</code>查询<code>LOCK_TMP</code>，当查到<code>LOCK_TMP</code>字段为<code>0</code>时，修改它为<code>1</code>。再执行定时任务，执行完成后再将它的值改成<code>0</code>。</p></li><li><p><code>zookeeper</code>等其他调度中心</p><p>既然都用上一些调度中心了，项目体量也算比较大了，这里经验不足，不做推荐，但感觉直接<code>xxl-job</code>挺好。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次接口分析优化实例</title>
      <link href="/record/2021/10/31/%E4%B8%80%E6%AC%A1%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E5%AE%9E%E4%BE%8B/"/>
      <url>/record/2021/10/31/%E4%B8%80%E6%AC%A1%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>​    之前写的一个交易调用的接口今天在用的时候发现接口调用的响应时间竟高达15～17s左右，之前埋的坑到现在爆发了，还是得解决。</p><p>​    先简单描述一下接口内容（伪代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口的service层</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  JSONArray <span class="title">trans</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">JSONArray res = <span class="keyword">new</span> JSONArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.调用其他接口A</span></span><br><span class="line">JSONArray tmp = A(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.对tmp做处理</span></span><br><span class="line">JSONArray convert  = convert(tmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.将convert作为接口B入参，调用接口B</span></span><br><span class="line"><span class="keyword">for</span>(Object o : convert)&#123;</span><br><span class="line">res.add(B(convert));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>​    我们再来描述一下接口的内容：这个接口不涉及数据库的操作，我把它分为三个部分：在1.处由于A接口是一个分页查询的问题，这里要获取完整A接口的内容会执行多次A接口。在2.处这里会对tmp做处理转换，会用到双重for循环。3.处其实就是将A接口查出的数据作为入参来对B接口进行多次查询。</p><p>​    整个接口的响应时间是十多秒，首先我应该判断是哪一部分耗费了大量时间，于是我修改了一下接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口的service层</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  JSONArray <span class="title">trans</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">JSONArray res = <span class="keyword">new</span> JSONArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.调用其他接口A</span></span><br><span class="line">  Long begin1 = System.currentTimeMillis();</span><br><span class="line">JSONArray tmp = A(data);</span><br><span class="line">  Long end1 = System.currentTimeMillis();</span><br><span class="line">  System.out.println(<span class="string">&quot;time1 = &quot;</span>+ (end1-begin1)/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.对tmp做处理</span></span><br><span class="line">  Long begin2 = System.currentTimeMillis();</span><br><span class="line">JSONArray convert  = convert(tmp);</span><br><span class="line">Long end2 = System.currentTimeMillis();</span><br><span class="line">  System.out.println(<span class="string">&quot;time2 = &quot;</span>+ (end2-begin2)/<span class="number">1000</span>);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//3.将convert作为接口B入参，调用接口B</span></span><br><span class="line">  Long begin3 = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(Object o : convert)&#123;</span><br><span class="line">res.add(B(convert));</span><br><span class="line">&#125;</span><br><span class="line">Long end3 = System.currentTimeMillis();</span><br><span class="line">  System.out.println(<span class="string">&quot;time3 = &quot;</span>+ (end3-begin3)/<span class="number">1000</span>);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>​    在这里我分别计算了三部分代码块执行的时间，得出结论是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time1 = 1</span><br><span class="line">time2 = 0</span><br><span class="line">time3 = 16</span><br></pre></td></tr></table></figure><p>​    这里我们发现是接口慢主要是由于多次调用其他接口造成的，而在接口中的一些for循环并没有我们想象中的更浪费时间。事实上，在postman中单独调用一次B接口耗时约500ms，这个成本是很大的，我需要尽可能的少调用接口或者说一次请求尽可能请求更多内容。</p><p>​    在这个接口中，我发现convert中的内容很多是重复的，它们仅需要请求一次接口即可，我这里通过优化2.中的代码根据业务逻辑简化并给转换时顺便过滤去重了一下，convert的长度从几十降低到了个位数，我再次请求这个接口，耗时大约在2-3秒，目前也算是能用了，如果不修改AB接口或者整体的调用逻辑的话，其实也没有多少优化空间了。</p><p>​    PS：今天顺便跟前辈讨论了一下这个问题，主要是吐槽目前项目拉的很这个接口一样，很大一部分原因就是很多内容应该是包含在前端中而不应该全部都去请求后端接口，这样搞不卡才怪，奈何前端莫的经验，我也莫的经验且人微言轻且重构真的很费时间和资源，还是就这样吧hh。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三分钟认识单例模式</title>
      <link href="/record/2021/10/17/%E4%B8%89%E5%88%86%E9%92%9F%E8%AE%A4%E8%AF%86%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/record/2021/10/17/%E4%B8%89%E5%88%86%E9%92%9F%E8%AE%A4%E8%AF%86%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>1.什么是单例模式</p><p>​    在单例模式下，一个类只能有一个实例对象。</p><p>2.什么场景需要使用单例模式</p><ul><li>需要频繁实例化然后销毁的对象。 </li><li>创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 </li><li>有状态的工具类对象。 </li><li>频繁访问数据库或文件的对象。 </li></ul><p>具体工作场景举例</p><ul><li>计数器</li><li>应用程序日志</li><li>数据库连接池/多线程的线程池</li></ul><p>2.单例模式的实现思路及方式</p><ul><li>饿汉模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.other;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span>: ESingleTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 饿汉实现单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: diane</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/10/11</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESingleTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缺点：占内存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ESingleTest</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 刚开始先初始化一个实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ESingleTest instance = <span class="keyword">new</span> ESingleTest();  </span><br><span class="line">    <span class="comment">// 需要的时候直接取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ESingleTest <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>懒汉模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.other;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span>: LSingleTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 懒汉实现单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: diane</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/10/11</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LSingleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LSingleTest</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 创建一个null的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LSingleTest instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒汉</span></span><br><span class="line">    <span class="comment">// 缺点：方法上加锁，慢</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LSingleTest <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//当多线程都取到instance为null时，这里单例就蚌埠住了</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LSingleTest(); <span class="comment">// 需要的时候再创建</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进化版懒汉(双检锁)</span></span><br><span class="line">    <span class="comment">// 把方法上的锁拿进去了。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LSingleTest <span class="title">getInstancePlus</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;  <span class="comment">// 一检</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LSingleTest.class)&#123;  <span class="comment">// 二检</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LSingleTest();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>总结</p><p>正常来说，使用饿汉单例即可，遇到内存瓶颈需要优化的时候再去考虑双检锁实现单例。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秋梦</title>
      <link href="/record/2021/10/04/%E7%A7%8B%E6%A2%A6/"/>
      <url>/record/2021/10/04/%E7%A7%8B%E6%A2%A6/</url>
      
        <content type="html"><![CDATA[<p>我在大学念书。</p><p>有天我在教学楼三楼宿舍想小解，三楼有个公共卫生间，没想到只有女卫生间，无奈，我只能去二楼找找。</p><p>二楼有个阶梯教室，我下来需要穿过它，里面是低年级的学生们的课，现在正是课间，教室人挺多，我便让他们抬一抬脚的往下走，隐隐约约的我听见有个声音在说这个人好像我初恋啊。这股声音很熟悉，不过我没有第一时间找到声音的来源。</p><p>我继续往下走，去找卫生间。解决之后，我去窗户那看看，看到了一男一女，那女人又在跟男人说好像看见一个侧脸很像初恋的人的事，我看到她，没想到是佳琦。我的小学同学，也是我的初恋。</p><p>我当时脑子里在想什么我已经记不清了，我没有立马上去和她打招呼，可能看到她男朋友心理因素在搞怪。</p><p>我装作没看见的慢慢绕下去，渐渐走到他们附近，走到他们前面，等她认出我，我再跟她打招呼之类的。</p><p>一切都在按照我的想法进行，在他们面前晃悠了一会，她认出了我，我也顺理成章的跟她和她男朋友打了招呼。她在中间，我和她男朋友分别在右左两侧，我们就绕着校园随便瞎逛着。</p><p>走着走着，她悄悄跟男友说想拉一下我的手，回忆一下往昔，他很大度的答应了，我听到了他们的说话，一方面感觉到意外的狂喜，另一方面感受到她男友还是介意的，只不过不好表达。</p><p>她速度减慢，到了我的后面，我跟她男友并肩而行，然后她又突然加速追上了，不经意却又预谋已久的碰到了我的手，我心中触电，不敢看左边，拉了两秒中我就挣脱开了。</p><p>我不知道当时他是什么表情，不过当我再看他的时候他以一切回复如常。佳琦也好像意识到了什么变得乖巧起来，她走到最左边，让他在中间，拉起他的手。</p><p>就这样走着走着，路边有个小摊，他提议有些饿了想吃一点儿，小摊挺小的，我就说要不去远点地方吃，我请客。他同意了。</p><p>梦醒了。</p><p>PS：我对她的记忆也只有名字了，现实中我的初恋也不是她。</p>]]></content>
      
      
      <categories>
          
          <category> 梦 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器磁盘100%占用问题</title>
      <link href="/record/2021/08/03/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A3%81%E7%9B%98100-%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/"/>
      <url>/record/2021/08/03/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A3%81%E7%9B%98100-%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>今天服务器/home下挂载的磁盘占用100%告警，我在线上排查问题。</p><p>我先一套三连甩过去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br><span class="line">du -h --max-depth=1</span><br><span class="line">ds -sh *</span><br></pre></td></tr></table></figure><p>发现目前<code>/home</code>下文件占的内容只占总容量的30%左右，那剩下的磁盘占用去哪了呢？</p><p>不得已，继续排查哪里有大文件，找一下之前删除的文件占用的磁盘。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof | grep delete</span><br></pre></td></tr></table></figure><p>一查下一跳，之前删除的文件基本都是假死脱身，然后就开始扫垃圾，杀掉这些进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 `lsof | grep delete | awk &#x27;&#123;print $2&#125;&#x27;` </span><br></pre></td></tr></table></figure><p>事情就告一段落，问题就解决了，但是为什么会出现这个问题呢？</p><p>这是因为要删除的文件还在被别的程序引用，<code>rm</code>掉这个文件只是删去了文件系统对它的一个索引，导致不能在文件夹中找到。实际上，它仍然存在，创建这个文件的进程往往存在对该文件的索引并且可能还在使用它。</p><p>举个例子，后台启动一个<code>jar</code>包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar test.jar &amp;</span><br></pre></td></tr></table></figure><p>启动成功后，我们将删除它打印的日志文件<code>nohup.out</code>，但是<code>test.jar</code>对它实际上是依然有引用的，所以在<code>test.jar</code>运行期间删除<code>nohup.out</code>文件实际上是没有删掉的。</p><p>那么正确的删除方式是什么呢？</p><p>仅在没有链接时删除才释放该空间，用上面这个例子来说就是在<code>test.jar</code>停止运行的时候删除<code>nohup.out</code>文件才是真正被删除。当然我们在大多时候不清楚它究竟有没有被引用，但是需要了解这类情况以便我们能更好的解决问题。</p><p>顺便记住这个命令吧！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof | grep delete</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七月末了回顾一下本月</title>
      <link href="/record/2021/07/28/%E4%B8%83%E6%9C%88%E5%9B%9E%E9%A1%BE/"/>
      <url>/record/2021/07/28/%E4%B8%83%E6%9C%88%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<ol><li><p>这个月开始了我的加班生涯。</p></li><li><p>加班工资很低有点难受。</p></li><li><p>这个月体重并没有下降，因为加班和没有运动。</p></li><li><p>换了一个MacBook，M1芯片就是感觉不错，虽然是带风扇，但是目前用了一段时间风扇还没转过。我发现它好就好在尽可能的会给你一个沉浸的体验。</p></li><li><p>开始看Java核心技术卷I，不过是在断断续续的看，读的很慢。</p></li><li><p>禅与摩托车维修艺术，这本书我看了一半就扔下了，这本书是在我手机上看到。但是突然有一天我没看，之后就顺其自然的不看了。书写的有点枯燥，谈论哲学往往没有诙谐幽默的，扔了几天再拾起来就很困难了，因为这阵子没有刚开始看的那种一股作气的状态了（这是骗自己的借口），总之就是感觉无聊需要反复品味作者的想法表达的意思并试着接受它，这种感觉不喜欢。</p></li><li><p>最近北京又出现疫情，离我不远，小区戒严，只留一个远门作为出口，重新启用出入证，感觉疫情可能还会恶化，感觉又回到了去年五六月时的状态。</p></li><li><p>买了吉他好久没有摸过了。</p></li><li><p>突然想说一下工作：最近遇到的困扰就是在我准备干活的时候老有人烦我做各种支持。是那种每半个小时就有人拿或小或更小的找我，或者说有闲的没事干的人溜达到我这边准备跟我闲聊几句。真的有些难受，但是又不方便明说。每天晚上做总结的时候，回顾一下今天白天我做了什么，我就会发现，我早上就在做支持，下午大概能敲一个小时代码，其他时间就会被各种打断。</p></li><li><p>在知乎看到一个回答：</p><p>人是身体的奴隶。我们饿了需要吃饭，渴了需要喝水，肚子痛了需要排泄，看到漂亮的异性想要交配。人更是思维的奴隶。我们总是以为，是自己在控制着自己的大脑，是自己在想着这样那样复杂的事情，是自己想要得到这样那样的东西。但其实并不是。是思维在控制着我们。对于思维简单的人而言，他的思维只会让他追寻吃饱喝足。对于思维普通的人，他的思维会催使他追寻钱，权，性等世俗意义上的成功。而对于思维高深的人，他的思维已经无法满足于此了。他需要追寻自身和这个世界存在的意义。然而很可惜，并没有这么个玩意儿。任何事物从出生，到毁灭，都没有任何的意义。基因控制着思维，思维控制着我们，如是而已。但是，即使他们的头脑非常明白这一点，他们依旧无法停下来。这就像饿了要吃饭，渴了要喝水一样，只要自己的思维还存在，就需要追寻那些该死的东西。所以他们需要去冒险，去寻找刺激，去创造，去毁灭，去伤害他人，去麻痹自己。一边满不在乎的干着各种残忍的事，一边饱受着良心的谴责，然后继续干着同样的事。他们不得不想方设法满足自己思维的饕餮。即便那饕餮将伤害他人，也将吞噬自己。越想要证明自己的强大，就越无法忍受自己的脆弱。拥有再多的东西，也无法填补自己内心的黑洞。很多时候，太过聪明并不是一个好事。当一只狗产生了超越狗的思维时，他就注定无法当一条好狗了。</p></li><li><p>再谈谈现在的项目，之前有说过我认为的项目上的几大坑，再补充两条。</p><ol><li>在开发上，几个人用一个分支进行开发，就没有分支管理这一说，导致代码混乱问题。提交混乱，提交不是按功能提交而是随便提，我看了就挺难受的，我就感受到这是一个根本不重视代码质量的一个团队，可能是我出淤泥而不染？不至于，我觉得我应该只是基本的素养吧。当然也没有 CodeReview，有一天我都叫他们来看一下我的代码（那会并不忙），但是被我哪看的懂啊一句话应付过去了。</li><li>我也兼职这个项目的运维工作，当前之前说的老打扰我的事情，就有很多是有关运维的问题。运维刚开始还是比较清晰的。当项目中后期的时候，本项目需要对接很多的其他系统，对接的时候可能就需要再部署一套新的环境来进行调试等操作。运维就是手动运维。我操作过的内容，我会记一个表格。但是其他人可能也部署了东西，但不更新文档。只是口头知会我一声，慢慢的我也有的内容就不清楚了。我烦的不是部署了杂七杂八的内容，而是没有一个运维的规范。这是一个由于规则缺少导致的混乱局面。</li></ol></li><li><p>最近还看了一本开源的书叫《凤凰架构》，里面描述的场景让人十分的心潮澎湃：有种把握住了行业发展脉动的奇妙感觉。</p><p>​        原始分布式时代-&gt;单体系统时代-&gt;SOA时代-&gt;微服务时代-&gt;云原生时代-&gt;无服务时代 </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二进制的应用与亮剑</title>
      <link href="/record/2021/07/22/ssn0009/"/>
      <url>/record/2021/07/22/ssn0009/</url>
      
        <content type="html"><![CDATA[<p>​        最近看到我一个程序设计中对二进制数一个有意思的应用。他的场景是一个多选框有五个多选项，怎么简洁的表示每次这个多选框勾了哪几个选项呢？</p><p>​        他们构造了一个八位二进制数，分别对应五个选项和三个预留位置。当选项勾选的时候其所对应的二进制位为1，未勾选和预留位默认为0，然后用这个二进制数转化为十六进制，即用两位数就可以表示这个多选框的勾选情况。</p><hr><p>​        最近随意看了几集亮剑，看到一个配角感概颇多。剧情大概是：山本的特种部队抓秀芹之前先抓了一个团里的保卫科干事朱子明严刑拷打搜集情报。朱子明在刚开始被严刑逼问没有松口，只求一死，但是比死更痛苦的是求死不能，在山本介绍完凌迟的刑罚后，朱子明的心态崩溃，交代了情报，当了叛徒。之后看着山本杀了赵家峪的乡亲，心里又一次的崩溃，过了两天又走出阴影彻底心死做了叛徒。</p><p>​        并没有”样板戏”里那样的宁死不屈。我觉得这才是亮剑拍出精彩的地方。拍出一个普通人被俘虏到变成叛徒的一个残酷现实。如果没有被俘虏，我相信他肯定是一个不怕牺牲不畏艰难的优秀八路军战士，就凭刚被俘虏被严刑拷打闭口不言的姿态已经超越了大部分人。不是所有八路军都是刘胡兰，看到朱子明残酷的一生，我就觉得他其实不应该被大声批评，真正应该骂应该是像楚云飞准备叛变的一二营长那样的，为了自己利益而当叛徒的人。而朱子明只是一个悲剧罢了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次数据库操作事故</title>
      <link href="/record/2021/07/19/%E5%88%A0%E5%BA%93%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/record/2021/07/19/%E5%88%A0%E5%BA%93%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<ol><li><p>事件描述:</p><p>同事意外删除了测试环境的一张核心表，导致测试环境访问异常。我之前做了数据库的每日备份，我拿出备份的数据文件准备找出被删除的表结构及数据，但是备份文件有二三十兆，打开半天全局搜索到一般就卡住了，断断续续整了半个小时，我决定把原来的库清空，再把备份文件全部导入。很顺利。但是过了一阵别人告诉我数据少了。我去检查的时候定睛一看，我发现备份所在目录挂载的磁盘已经满了，备份在一周之前就停下了。很尴尬我拿一周前的备份恢复了现在的数据。幸好，这个数据库本周内新增的数据只有部分的数据字典项，最后手动把数据给补上了….</p></li><li><p>总结:</p><p>做事最怕做一半，因为做一半最容易出事情。不管是什么环境，数据库备份肯定是必须的，但是我忽略了数据库内容的大小，几个数据库每日备份的文件大小都有几百兆，在做数据库备份的时候都应该想到定时清理。</p><p>定时清理的shell脚本也很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find /xx -mtime +2 -name &quot;*.sql&quot;  -exec -rm -rf &#123;&#125; \;</span><br><span class="line"># /xx 指需要清理目录的路径</span><br><span class="line"># +2 指清理两天前的数据</span><br><span class="line"># “*.sql” 指需要清理的文件格式</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>谈谈Java中的位运算</title>
      <link href="/record/2021/07/04/%E8%B0%88%E8%B0%88Java%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/record/2021/07/04/%E8%B0%88%E8%B0%88Java%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<ol><li><p>我们为什么要了解使用位运算？</p><ol><li>某些场景下使用位运算比普通计算使计算机运算效率更高，更节约内存。</li><li>位运算某些场景比普通方法写出来会更简洁。</li><li>看很多比较底层的实现源码时，很多已经用了位运算，所以为了更好的了解底层实现，需要懂这相关的知识。</li></ol></li><li><p>有关位运算的基本概念。</p><ol><li><p>原码，反码，补码的概念及其意义。</p><p>二进制机器码即可认为是原码，原码的首位是正负位。</p><p>正数的反码与补码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反，负数的补码是在其反码上加1。</p><p>反码与补码的意义是为了尽量简单的解决计算机做减法的问题。</p></li><li><p>位运算的六个运算符号。</p><ul><li><p>&amp; 与运算 两个位都是 1 时，结果才为 1，否则为 0</p></li><li><p>|  或运算 两个位都是 0 时，结果才为 0，否则为 1</p></li><li><p>~  异或运算，两个位相同则为 0，不同则为 1</p></li><li><p>^  取反运算，0 则变为 1，1 则变为 0</p></li><li><p>&gt;&gt; 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位</p></li><li><p>&lt;&lt;  左移运算，向左进行移位操作，高位丢弃，低位补 0</p></li><li><p>&gt;&gt;&gt; 无符号右移运算，若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0</p></li></ul></li></ol></li><li><p>常用示例</p></li></ol><ul><li><p>位操作实现乘除法</p><p>数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 2;</span><br><span class="line">a &gt;&gt; 1; ---&gt; 1</span><br><span class="line">a &lt;&lt; 1; ---&gt; 4</span><br></pre></td></tr></table></figure><ul><li><p>位操作交货两数</p><p>位操作交换两数可以不需要第三个临时变量，虽然普通操作也可以做到，但是没有其效率高</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//普通操作</span><br><span class="line">void swap(int &amp;a, int &amp;b) &#123;</span><br><span class="line">  a = a + b;</span><br><span class="line">  b = a - b;</span><br><span class="line">  a = a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//位与操作</span><br><span class="line">void swap(int &amp;a, int &amp;b) &#123;</span><br><span class="line">  a ^= b;</span><br><span class="line">  b ^= a;</span><br><span class="line">  a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    位与操作解释：第一步：a ^= b —&gt; a = (a^b); </p><p>​    第二步：b ^= a —&gt; b = b^(a^b) —&gt; b = (b^b)^a = a</p><p>​    第三步：a ^= b —&gt; a = (a^b)^a = (a^a)^b = b</p><ul><li><p>位操作判断奇偶数</p><p>只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(0 == (a &amp; 1)) &#123;</span><br><span class="line"> //偶数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>位操作交换符号</p><p>交换符号将正数变成负数，负数变成正数</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int reversal(int a) &#123;</span><br><span class="line">  return ~a + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数</p><ul><li><p>位操作求绝对值</p><p>整数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 0xffffffff），然后根据符号进行相应的操作</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = a &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> i == <span class="number">0</span> ? a : (~a + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上面的操作可以进行优化，可以将 i == 0 的条件判断语句去掉。我们都知道符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负。对于任    何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,因此可以将上面三目元算符转换为((a^i)-i)，即整数时     a 与 0 异或得到本身，再减去 0，负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = a &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> ((a^i) - i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈(10)期</title>
      <link href="/record/2021/07/03/%E6%9D%82%E8%B0%88(10)%E6%9C%9F/"/>
      <url>/record/2021/07/03/%E6%9D%82%E8%B0%88(10)%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>杂谈：</p><ul><li><p>最近认知上的升级比较频繁，突然发现我的技术生涯前路漫漫，而我还在刚开始的路上徘徊。我为自己准备了一个书单，希望自己能在今后两年内先囫囵吞枣的通读一遍。</p><ul><li>计算机组成原理，编译原理，计算机网络，Engineering a Compiler，深入理解计算机系统，现代操作系统，TCP/IP详解 卷1：协议，图解TCP/IP，HTTP权威指南</li><li>算法图解，Java 核心技术：卷1，Effective Java，Java并发编程实战，Java性能权威指南，深入理解Java虚拟机，Java编程思想，大话设计模式，SpringBoot实战</li><li>重构，修改代码的艺术，Google软件测试之道，代码大全，完美软件，代码整洁之道，程序员的职业素养</li><li>UNIX编程艺术，UNIX网络编程，Linux C编程一站式学习，高性能Mysql，MySQL技术内幕，数据库索引设计及优化，MySQL必知必会，NoSQL精粹，HBase权威指南，HBase实战，微服务设计，k8s中文指南</li><li>effective go，C程序设计语言，C语言程序设计现代方法，C陷阱与缺陷</li></ul></li></ul><p>一共四十一本，有的读过，重读一遍也未尝不可，读完一本书可以写一些读后的内容。当然需要时刻谨记并不是为了读书而读，看这些东西是一种深入了解计算机的方法，而不是结果。</p><ul><li><p>说起书，豆瓣一直是一个书籍评价比较综合的网站，其他类型的书也感觉不错，这是<a href="https://book.douban.com/annual/2020">2020年的年度榜单</a>。</p></li><li><p>NAS是一种比较流行的本地的网络附属存储设备，类似的说就是在本地搭了一个阿里云盘仅供一人/一家使用，这是一篇它的<a href="https://post.smzdm.com/p/a4wmxw98/">科普介绍</a>。</p></li><li><p>发现一个奇怪的现象：当我越忙的时候，我越能抠出时间做提升自己的事情，当我周末两天有大把时间的时候我却总是虚度光阴。</p></li><li><p>晚上适合做总结，写东西，思绪纷飞又勿需集中精力，早上适合攻克难题，我想说的是要在适合的时间做适合的事情。</p></li></ul><p>​    </p><p>言论：</p><ul><li><p>Great minds discuss ideas（伟人谈论想法）</p><p>Average minds discuss events（普通人谈论事件）</p><p>Small minds discuss people（庸人谈论他人）</p><p>​                                                                                                                                                                                      – Eleanor Roosevelt</p></li><li><p>世界观代表你是怎么看这个世界的，是左还是右，是激进还是保守，是理想还是现实，是乐观还是悲观。人生观代表你想成为什么样的人，是成为有钱人，还是成为人生的体验者，是成为老师，还是成为行业专家，是成为有思想的人，还是成为有创造力的人。价值观则代表你觉得什么对你来说更重要，是名是利，是过程还是结果，是付出还是索取，是国家还是自己，是家庭还是职业。</p><p>​                                                                                                                                                                                     –陈皓</p></li><li><p>一边工作一边听音乐是没有办法真正思考的，或许他们并不认为自己的工作需要任何的思考                     – 斐德洛</p></li><li><p>如果你对事情有完全的信心，就不太可能产生狂热的态度。就拿太阳来说吧，没有人会为了它明天会升起而兴奋不已，因为这是必然的现象。如果有人对政治或是宗教狂热，那是因为他对这些目标或是教义没有完全的信心                         – 斐德洛</p></li><li><p>他认为像学校、教会、政府和政治组织这种机构，都是想用某种特定的目标而非真理来引导别人的思考，以使他们的机构能够继续存活下去，以控制别人来继续为这些机构服务。                                                                                                     – 斐德洛</p><p>​                                                    </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 期刊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾一下最近的工作</title>
      <link href="/record/2021/07/02/%E5%9B%9E%E9%A1%BE%E4%B8%80%E4%B8%8B%E6%9C%80%E8%BF%91%E7%9A%84%E5%B7%A5%E4%BD%9C/"/>
      <url>/record/2021/07/02/%E5%9B%9E%E9%A1%BE%E4%B8%80%E4%B8%8B%E6%9C%80%E8%BF%91%E7%9A%84%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>回顾一下这两个月的工作情况，我做了什么，遇到了什么问题，等等，大概做一个复盘吧。</p><p>第一个想法：两个月说长也不长，但是我根本想不起来五月初的我具体在做什么，只记得五月搬了个家。幸好有周报这个东西，他还是有意义的，之前一直是把他作为形式上的东西。</p><p>五月上旬到六月下旬我主要是在开发目前系统的通用功能，当前的系统是一个套壳的流程平台：流程引擎是已经现成的。但是目前来说这个项目还是很复杂，这是由于我们目前的情况是客户原来有一个流程平台，大概是2010年开始使用的，到目前超过十年了。用了这么多年的一个系统想要更新换代，这就挺麻烦的，主要麻烦有三个：</p><p>​    第一，多年的旧系统的使用已经让用户形成了使用习惯，客户要求的新系统无时无刻体现着旧系统的影子，旧系统上不管是合理的还是不合理的东西可能就会一股脑的在提需求的时候往新系统上搬，当前我们可以挡掉一部分，但是还是有很多一部分的东西以习惯为由还是需要新系统继续实现，当然这个完全是正常的，客户能依照的参照物只有旧的系统，当前新的系统也需要完全包含旧系统的功能，并在此基础上扩展一些新的特性。</p><p>​    第二，数据迁移的问题，这十年的旧系统运行下来流程业务方面的数据肯定是不能丢的。当前太久远的数据，比如说三年前的数据需要入到数据湖里去，但是三年内的数据还需要迁移到新系统，达到可查到环节的要求。先细说一下，数据迁移。旧系统使用的数据库是<code>Oracle</code>，而新系统使用的是<code>Mysql</code>，并且旧系统的表多且分散（大概四百张），且命名比较随意，很多表的表名基本上就是多前缀+数字，比如说<code>AA_BB_CC024</code>,面对这种数据库，我们首先需要他们问清楚旧系统数据库设计的文档，一边设计新的数据库表，一边还要考虑到设计的新表字段和原数据库表字段的对应关系，还要考虑设计新表时要给现在不用但原数据库有的字段留位置…这样一点一点的全部的弄清楚了，才用Kettle进行数据的迁移。在说一下数据入湖，入湖相对于迁移来说是简单的很多了，我是第一次接触入湖，但我觉得他们这种入湖的方式有些低级？（个人感觉）。他们的入湖的方式大致是这样的：我们首先要安装要求的格式输出由多个数据文件组合成的数据包，每个表的内容就是一个数据文件，在生成一些配置文件的东西，也放到包里，然后就要把数据包放到指定服务器的目录，最后，数据湖人员把包取走，做他们具体的操作。这一套下来有些像民国特务接头的感觉，一旦接受了这个设定….</p><p>​    第三，文档缺失，旧的系统并不是独立的一个系统，它还要跟六个其他系统进行交互，由于各种原因，与旧系统对接的文档，有的内容缺失，有的文档没有更新，版本过老，在这十年中，跟旧系统的对接的接口很多都改过，旧系统中的流程也被各种扩展与修改，然而文档的更新却跟不上，我们浪费了很多时间去找文档，找人确认这些东西，对于我来说，这算是比较痛苦的一件事。</p><p>话说回来，我这两个月主要还是做一些通用的功能，由于当前的流程引擎不能完全满足客户的需求，尤其是部分从老系统传承过来的功能，我主要就是做这个事情，满足这些对不齐的部分。其次就是负责整个项目的运维，这段运维就是基础的运维，我自己为了方便也写了一些<code>shell</code>脚本，但是这只是杯水车薪的工作，没有体验过<code>devops</code>的我现在极度想要运维自动化…还有就是做数据迁移及入湖的工作，写新的文档，还有各种杂七杂八为了让流程满足要求运行下去的脚本…这些事繁复且杂乱，也比较烦这类事情。</p><p>说是复盘，其实算吐槽了，我不知道项目都是这样，还是我的经历比较奇特，我的项目经理不错，说实话大部分的沟通确认是他在承担，当然这是他的工作职责，也许我应该想想我怎么能让这个项目完成的更顺利一点。</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>读陈浩时间管理</title>
      <link href="/record/2021/06/29/%E8%AF%BB%E9%99%88%E6%B5%A9%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
      <url>/record/2021/06/29/%E8%AF%BB%E9%99%88%E6%B5%A9%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>最近在极客时间上看到陈浩的专栏，他工作与学习的理念与方法深深冲击了我。金玉良言，勿需修改，摘抄即可：</p><p>关于如何拒绝需求：</p><blockquote><p>​    当你面对做不到的需求时，你不要说这个需求做不到。尤其是，你不要马上说做不到，你要先想一下，这样让别人觉得你是想做的，但是，在认真思考过后，你觉得做不到，并且给出一个你觉得能做到的方案。</p><p>​    这里的诀窍是：给出另一个你可以做到的方案，而不是把对方的方案直接回绝掉。当你面对过于复杂的需求时，你不要说不。你要反问一下，为什么要这样做？这样做的目的是什么？当了解完目的以后，你可以给出一个自己的方案，或是和对方讨论一个性价比更好的方案。你可以回复说，这个需求好复杂，我们能不能先干这个，再做那个，这样会更经济一些。这里的诀窍是：我不说我不能完全满足你，但我说我可以部分满足你。当你面对时间完全不够的需求时，你也不要说不。既然对方把压力给你，你要想办法把这个压力还回去，或是让对方来和你一同分担这个压力。</p><p>​    这个时候，我惯用的方式是给回三个选择：</p><p>a. 我可以加班加点完成，但是我不保证好的质量，有 bug 你得认，而且事后你要给我 1 个月的时间还债。</p><p>b. 我可以加班加点，还能保证质量，但我没办法完成这么多需求，能不能减少一些？</p><p>c. 我可以保质保量地完成所有的需求，但是，能不能多给我 2 周时间？</p><p>​    这里的诀窍是：我不能说不，但是我要有条件地说是。而且，我要把你给我的压力再反过来还给你，看似我给了需求方选择，实际上，我掌握了主动。这就是学会说“不”的方法。说白了，你要学会在“积极主动的态度下对于不合理的事讨价还价”。只有学会了说“不”，你才能够控制好你的时间。</p></blockquote><p>关于开会：</p><blockquote><p>​    开会，不是讨论问题，而是讨论方案，开会不是要有议题，而是要有议案。所以，作为与会者，如果你发现没有议案，大家海了去说，那么你有两种选择，跳出来帮大家理一理，或者也可以说一下，如果会上讨论不清，要不先线下讨论，有了方案再来评审。也许在一些会上你不敢这么干，但是有些会你是可以这么干的。能影响的这些都能为你争取到很多时间。</p></blockquote><p>关于时间管理：</p><blockquote><p>投资自己的时间</p><p>其实，时间就像金钱一样，你得学会投资时间，把时间投资在有价值有意义的地方，你就会有“更多的时间”。</p><ul><li>花时间学习基础知识，花时间读文档。在参加工作的这 20 年时间里，我发现，很多程序员都把时间都浪费在了查错上。究其根本原因就是基础知识不完整，没有好好地把技术相关的用户文档读完就仓促上手做事情了。其实只要把基础打扎实，认真读一下文档，你会省出很多很多的时间。系统地学习一门技术是非常关键的，所以这个时间是值得投资的。</li><li>花时间在解放自己生产力的事上。在自动化、可配置、可重用、可扩展上要多花时间。对于软件开发来说，能自动化的事，就算多花点时间也要自动化，因为下次就不用花时间了。让自己的软件模块可以更灵活地配置和扩展，这样如果有需求变更或是有新需求的时候，可以不用改代码，或者就算要改代码也很容易。这里，可能很多人会说不要过度设计，对于这个观点，我既同意，也反对。的确，过度设计不好，但是只要是能在未来节省时间的，宁可这个项目延期，我也会做的。花时间在解放自己的事上是最有意义的了。</li><li>花时间在让自己成长的事上。注意，晋升并不代表成长，成长不应该只看在一个公司内，而是要看在行业内，在行业内的成长才是真正的成长。所以，把时间花在能让自己成长，能让自己有更强的竞争力，能让自己有更大的视野，能让自己有更多可能性的事情上。这样的时间投资才是有价值的。</li><li>花时间在建立高效的环境上。我相信你和我会有一样的一个习惯，那就“工欲善其事，必先利其器”。我们程序员在做事之前都喜欢把自己的工作环境整理到自己喜欢的状态下。比如使用趁手的开发工具，使用趁手的设备。这里， 我想把这个事扩大一下，花些时间在影响你身边的人上，比如你的同事，你的产品经理，你的老板，去影响他们，让他们理解你，让他们配合你来建立更好的流程和管理方法。在这个方向上花时间也是很值得的。</li></ul><p>规划自己的时间</p><ul><li>定义好优先级。无论你写不写出来，你一定都会有一个自己的 to-do list。有 to-do list 并不是什么高深的事。更重要的是，你要知道什么事是重要的，什么事是紧急的，什么事重要但不紧急，什么事又重要又紧急。这有利于你划分优先级。</li><li>最短作业优先。对于相同优先级的事，我个人喜欢的是“最短作业优先”的调度算法。理由是，先把可以快速做完的事做完，看到 to-do list 上划掉一个任务，看到任何的数据在减少，对于自己也好，对于老板也好。老板可以看到你的工作进度飞快，一方面有利于为后面复杂的工作争取更多的时间（老板只有在你有 Deliver 的时候才愿意给你更多的时间），另一方面，看到任务列表的减少会让你的心态更为积极。而反过来，你花太多的时间在长作业上，长作业通常很容易出现“意外情况”让你花更多的时间，但此时你发现还有很多别的事没有做，这会让你产生焦虑感，产生更多的压力，进而导致更慢的生产效率。</li><li>想清楚再做。我发现很多时候，我们没有想清楚就开干了，边干边想，这样的工作方式其实很糟糕。你会发现，如果你没有想清楚，你总是要对已完成的工作进行返工，返工好几次，其实是非常浪费时间的。所以，对于一些没想清楚的事，或是自己不太有信心的事，还是先看看有没有已有的成熟解决方案，或是找更牛的人来给你把把关，帮你出出主意，看看有没有更好、更简单的方式。</li><li>关注长期利益规划。要多关注长远可以节省多少时间，而不是当前会花费多少时间。长期成本会比短期成本大得多。所以，宁可在短期延期，也不要透支未来。这里的逻辑是，工作上的事你永远也做不完的，长痛不如短痛。我一年要做 10 个项目，我宁可第 1 或第 2 个项目被老板骂，但是我可以赢得后面 8 个项目，从后面 8 个项目上把之前失去的找回来。而如果反过来的话，我虽然一开始得到了老板的信任，但是后面越来越玩不动，最终搬起一块大石头砸了自己的脚。而且，不关注长远利益的人，基本上来说也是很难有成长的。也就是说，你要学会规划自己的行动计划，不是短期的，而是一个中长期的。我个人建议是按季度来规划，这个季度做什么，达到什么目标，一年往前走四步，而不是只考虑眼下。</li></ul><p>用好自己的时间</p><ul><li>如何将这些时间管理方法形成习惯，因为我坚信：“做”比“做好”更重要。养成一个好习惯通常需要 30 天左右的时间，尤其在最初的几天就更为重要了。这时，不妨将文章中提到的方法和几个要点，写在某本书或者笔记本的扉页上，方便查看，时刻提醒自己。</li><li>形成正反馈。在前面的文章中，我提到过，要有正反馈，也就是成就感，有助于完成一些看似难以完成的事儿。比如，我们说过，学习是逆人性的事儿，但如果在学习过程中不断地有正反馈，就更利于我们坚持下去。要让自己有正反馈，那就需要把时间花在有价值的地方，比如，解决自己和他人的痛点，这样你会收获别人的赞扬和鼓励。反思和举一反三。可以尝试每周末花上点时间思考一下，本周做了哪些事儿？时间安排是否合理？还有哪些可以优化提高的地方？有点儿类似于我们常说的“复盘”。然后思考一下，下周的主要任务是什么？并根据优先级规划一下完成这些任务的顺序，也就是做一些下周的工作规划。这样每周都能及时得到自己做时间管理之后的反馈，并有助于持续优化。通常坚持做时间管理一段时间以后，你都能在每次复盘时得到正反馈，这是有利于我们形成时间管理习惯的。但我这里也想强调一点，我们也要允许偶尔的“负反馈”，因为人的状态总是会有高潮和低谷的，控制好一个合理的度就可以了。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈(09)期</title>
      <link href="/record/2021/06/24/%E6%9D%82%E8%B0%88(09)%E6%9C%9F/"/>
      <url>/record/2021/06/24/%E6%9D%82%E8%B0%88(09)%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<ul><li><p>杂谈</p><ul><li>最近有在想极简生活，在莫名其妙背负很多东西的时代，我觉得这是一种不错的生活方式，可以通过尽可能抛去身边非必须物品的方式来让自己有一个更好的生活状态。当然极简只是相对的极简，我看到践行极简的人做到了令我难以想象的地步，当然，看个人，我不理解，但他们可能甘之如饴。我对自己的物质上和精神关注上把我的所有东西分了个类，陈列展示了一下，发现我本身物质生活好像就挺朴素的，但是脑子里的东西比较混杂，这个需要大大滴扔垃圾。</li><li>接着上一条，我在梳理自己的时候总是很痛苦，粗略的审视自己感觉不错，但得出的结论总是比较简单与单调，彷佛是老生常谈一般。但是向抓住一个方向深挖一下自己干了什么，怎么做的，大脑就会时不时罢工，就像挖矿遇到了石头，稍微前进一会就感觉自己很累需要休息一下，大脑发出休息的指令是如此的自然，然后我自然而然的去找一些简单的快乐放松去了。我感觉这就是大脑好久不用生锈的感觉吧。</li><li>我前几周经常萌生要组装一台台式电脑的想法。像自己买CPU，主板，电源…但是被最近的显卡价格吓回去了。然后接着上一条，我在想，我的脑子就是CPU加GPU，身体就是主板和电源。当然人体的CPU&amp;GPU是能不断升级/降级的。想象大街上走着各种各样的型号的电脑，we`re all robot tonight，感觉很有意思。</li><li>这几天把我的旧笔记本闲鱼出掉了，这是16年的时候大一买的电脑，联想ideapad，那时候联想还是地地道道的美帝良心想，电脑感觉就一般，内存4G,500G机械盘，还好也没啥要求，主要是不怎么学习不咋用电脑，然后凑活凑活用了四年，大修过一次，加了内存条，白色电脑也用成了黄色…对旧物还是有微微不舍。</li><li>最近又搭了<code>hexo</code>的博客，安排在<code>GitHub Pages</code>上了，又把再原来服务器上的博客基本上都迁移过来了，总共花了差不多一天时间。之前心情澎湃自己就用<code>springboot+vue</code>实现了一个博客，又花了100多大洋租了最便宜的服务器，买了域名，还捣鼓着<code>https</code>。这样投入的经历太多了，我只是需要一个记录的地方。当然心里有些小布尔乔亚，感觉稍微还要秀一下，但又不要人尽皆知…人的心思真的奇怪。话扯回来，高成本的搭建博客对我来说就是一年的事情，不能持久。记事本又差点意思，还是老老实实挂在<code>GitHub</code>上….</li></ul></li><li><p>技术</p><ul><li><p>最近在做数据入湖的事情。我要做的就是把数据库大部分表的数据全部遍历出来，生成特殊格式的文件。这个可以用shell脚本完成（不会），也可以写Java的定时任务。所以我遇到了两个问题：</p><ul><li><code>myBatis</code>怎么对数据库做操作？</li><li>怎么在不写实体类的情况下用<code>myBatis</code>获取单表中的所有数据？</li><li>数据入湖分为全量入湖与增量入湖，第二种入湖时怎么区分哪些是增量数据，进行统计呢？</li><li>由于库里表多，表里数据也不少。怎么能对这个程序做优化呢？</li></ul><p>我的一些答案：</p><ul><li><p><code>select table_name from information_schema.tables where TABLE_SCHEMA=(select database())</code></p><p>查询某数据库内所有表的表名</p></li><li><p>Mapper中接收类型设置成<code>List&lt;LinkedHashMap&lt;String,String&gt;&gt;</code>，直接可以以数据表拿到单表所有数据(<code>LinkedHashMap</code>就是保证拿到的数据与数据库表中的数据顺序是一样的)</p></li><li><p>增量入湖的思路肯定是以时间为划分，比如说今天12：00全量入湖一次，下一次增量入湖表里筛数据判断旧肯定是sql判断时间为今日12：00以后的，但是有的表并没有时间字段，由于我目前项目的数基本都是只增加不减少的，所以，我感觉可以统计第一次入湖的表的行数，第二次增量时就拿第一次的行数之后的数据（这个感觉有些不靠谱）。</p></li><li><p>…….</p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 期刊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈（08期）</title>
      <link href="/record/2021/06/18/%E6%9D%82%E8%B0%88(08%E6%9C%9F)/"/>
      <url>/record/2021/06/18/%E6%9D%82%E8%B0%88(08%E6%9C%9F)/</url>
      
        <content type="html"><![CDATA[<ol><li><p>杂谈</p><ul><li><p>发现现在好多app都在做扩展，扩展的内容觉得并不好。<br>以前支付宝蚂蚁森林我就种树，慢慢蚂蚁森林链接出了养鸡，养鸡链接出了种果树，果树链接出了农场种地。好嘞，我现在不玩蚂蚁森林了行不行。<br>淘宝+奇迹暖暖=淘宝人生<br>淘宝+开心农场=芭芭农场<br>淘宝+快手抖音=淘宝逛逛<br>是不是程序员招多了没得干了？淘宝就是举个例子，其他app半斤八两。</p><p>还有提名一下知乎，网易云音乐，尤其是知乎。</p></li><li><p>在v站看到一个人生只有九百月的帖子。看到了一个<a href="https://fgz.cn/life.html">生命日历</a>，我已经过了267个月了，大概已经走了三分之一的路程，一直以为自己还年轻，其实已经不然了。</p><p><img src="https://i.loli.net/2021/06/16/uMRfwP4oHCdIGzh.png" alt="image-20210616225406477"></p></li><li><p>最近用了一次百度网盘下载东西。从百度网盘的下载速度上就能看出百度的紧张态度，目前百度网盘又恢复到了之前的速度水平，由此可见百度网盘对于阿里云盘的入场好像没那么警惕。</p></li><li><p>最近一直想买东西，不知道为什么就是想消费，想买sony xm4，想买mac mini，还想自己组装一个台式，真的很奇怪，扪心自问一下，我对这些东西的确没有刚需，为什么不断的冒出想买他们的念头呢，x想了其中原因之一是我今年对数码产品的关注变多了。怎么才能避免内心被消费主义撩动呢？</p></li><li><p>最近去爬了趟陕西。西安比北京热，目前的温度感觉就是北京之前最热的时候，出去玩一天，身上黏糊糊的，遭不住遭不住。华山不错！</p><p><img src="https://i.loli.net/2021/06/16/hzP5bCmM6GuBkct.jpg" alt="微信图片_20210616230321"><img src="https://i.loli.net/2021/06/16/wOK2y6LIvRmu5z1.jpg" alt="微信图片_20210616230233"></p></li></ul></li><li><p>看到一个大神，叫<code>Richard Hipp</code>,是SQLite作者，他的风格就是开发的作品都是一个c文件。最近一个C语言文件实现了一个web服务器。膜拜！</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 期刊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锚点</title>
      <link href="/record/2021/06/15/ssn0008/"/>
      <url>/record/2021/06/15/ssn0008/</url>
      
        <content type="html"><![CDATA[<p>​        在坐地铁的时候突然冒出一个想法。我是不是该给自己打一个锚点了。这个锚点是什么呢，是发生在自己身上大脑记忆最清楚的一件事。是过很久都磨灭不了的记忆。今天坐四号线的时候，车站音乐响起来，我突然就想起我实习的时候每天坐四号线十几站上班的日子。我的脑子是会偷懒的，他只尽量记下比较深刻的东西，然而日常生活是不够深刻的。<br>​        大脑用Map把时间当做key，把某段时间内深刻的事作为锚点做为value，人生就是一个Map集合。当我回顾自己过去的二十年时，我并不会记得每一个日常，曾经的每天，我只是记得我小学碰到地震，在操场上课了好久，初中中学快倒闭，借宿在别的学校的一段日子…等等，这一段一段的记忆拼成的我的一生，莫名觉得有点可悲啊，但想不到悲从何起。<br>      经常回顾从前是一种老了的表现。我以前总是对喜欢说自己过往的人是嗤之以鼻的。但是我这种不想的其实更不好。经常回顾能够加深记忆。像我这样的人可能到五十岁只能保存二十岁以后的记忆。再之前的东西真真正正的消失掉了，记忆这种东西忘记了该怎么能找回来呢？<br>      今晚，火车上，我想好好想想我的一辈子。<br>      刚刚回想了十分钟，我想起我小时候干的事情我想打死我自己，感谢妈妈。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态代理的简单理解</title>
      <link href="/record/2021/05/28/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
      <url>/record/2021/05/28/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//静态代理的一个简易理解实现，场景是dianedii结婚找了加婚庆公司...</span><br><span class="line"></span><br><span class="line">//“婚庆公司”协助“我”实现“结婚”动作</span><br><span class="line">public class StaticProxy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MarryCompany marryCompany = new MarryCompany(new Person(&quot;你&quot;));</span><br><span class="line">        marryCompany.HappyMarry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//结婚主角</span><br><span class="line">class Person implements Marry</span><br><span class="line">&#123;</span><br><span class="line">    public String name;</span><br><span class="line"></span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void HappyMarry() &#123;</span><br><span class="line">        System.out.println(name+&quot;要结婚啦!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//结婚动作</span><br><span class="line">interface Marry&#123;</span><br><span class="line">    public void HappyMarry();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//婚庆公司</span><br><span class="line">class MarryCompany implements Marry&#123;</span><br><span class="line">    Marry target;</span><br><span class="line">    public void before()&#123;</span><br><span class="line">        System.out.println(&quot;结婚前筹措婚礼&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void after()&#123;</span><br><span class="line">        System.out.println(&quot;结婚后蜜月规划&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MarryCompany(Marry target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void HappyMarry() &#123;</span><br><span class="line">        before();</span><br><span class="line">        this.target.HappyMarry();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//输出：</span><br><span class="line">//结婚前筹措婚礼</span><br><span class="line">//你要结婚啦</span><br><span class="line">//结婚后蜜月规划</span><br><span class="line"></span><br><span class="line">//总结：</span><br><span class="line">//假如说Person类中是本来的实现，那么用静态代理的方式就可以在不修改之前代码的情况下，对其功能进行增强。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周刊停更好久</title>
      <link href="/record/2021/05/20/ssn0007/"/>
      <url>/record/2021/05/20/ssn0007/</url>
      
        <content type="html"><![CDATA[<p>周刊停更一个月了。</p><p>我觉得还不错，其实之前写着写着有种翻垃圾的感觉，当然是信息垃圾。我看了好多文章，好像只有一篇我觉得还可以。其他的相对来说就是翻完扔掉的垃圾。我那会感觉自己是个过滤器。当然我看阮大也是写类似周刊坚持好多年了，一个是他的阅读面比较广，另一个是比较知名，github/weekly下每周都有很多人给他提issue，感觉跟我这种过滤不是一个层级。</p><p>还有就是我把自己限制住了，有一周我可能看到了好多有意思的句子，但是自己设置的周刊格式是比较均衡的，所以有时候有的时候周刊就写的比较痛苦，即有些模块并没有什么值得分享的还需要翻翻垃圾找一找，这种是经常遇到且有些痛苦的一个点。</p><p>第三个原因是我阅读量真的不高，充盈不起来这一个框子，虽说可以逼着自己多看点东西，但总是心理因素作祟，有些懒惰心理与自我怀疑的综合体。</p><p>hh，周刊停更一个月了，我觉得还不错。我更多的是在推上和备忘录里记录一些灵感，突然的想法。自愿做一个事情应该不是痛苦的，当然我的确是有类似周刊想要记录分享在互联网所观感的一个东西。但它不是周刊，应该是一个更自由形式的形式，也许是小文章，emmm，也是一个idea.</p><p>这是给自己的说明，为自己没坚持下去的辩解吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据定时备份</title>
      <link href="/record/2021/05/19/MySQL%E6%95%B0%E6%8D%AE%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD/"/>
      <url>/record/2021/05/19/MySQL%E6%95%B0%E6%8D%AE%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<p>在工作中经常需要接触数据库。为了保证数据安全与突发事件故障恢复，定时备份数据库的数据是十分有必要的。我们以<code>Linux</code>下的<code>Mysql</code>为例聊一聊怎么简单的备份数据。</p><h5 id="一、备份脚本准备"><a href="#一、备份脚本准备" class="headerlink" title="一、备份脚本准备"></a>一、备份脚本准备</h5><p><code>Mysql</code>中自带一个逻辑备份工具<code>mysqldump</code>.我们可以直接在命令行中对mysql数据进行操作。</p><p>以下是常见的命令格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysqldump [选项] 数据库名 [表名] &gt; 脚本名</span><br><span class="line">---举个栗子---</span><br><span class="line">mysqldump -uroot test &gt; /home/backup.db</span><br><span class="line">---解释---</span><br><span class="line">通过用户root将test数据库进行备份到/home目录下的backup.db文件中</span><br></pre></td></tr></table></figure><p>同样的，将所有<code>mysql</code>所有数据库中数据备份即为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump [选项] --all-databases [选项]  &gt; 脚本名</span><br></pre></td></tr></table></figure><p>将以上命令写在shell脚本中，并赋予可执行权限。执行以上脚本的时候，由于没有设置登录密码所以还需要手动设置密码，当然在<code>[选项]</code>中也可以增加密码属性，但是由于安全性考量不建议这样做。</p><p>我们采用将密码放在<code>my.cnf</code>中并且设置该配置文件无读权限（<code>chmod 600 my.cnf</code>）的方式来实现免密备份。</p><p>在<code>my.cnf</code>中增加如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqldump]</span><br><span class="line">user=XXX</span><br><span class="line">password=XXX</span><br></pre></td></tr></table></figure><p>当然这里配置的用户要与脚本中的用户一致，并且在此处配置后，在脚本中不要添加<code>-p</code>的选项。</p><h5 id="二、启动定时任务"><a href="#二、启动定时任务" class="headerlink" title="二、启动定时任务"></a>二、启动定时任务</h5><p><code>linux</code>中有一个定时命令<code>crontab</code>,我们通常使用<code>crontab -e</code>来操作当前用户的定时任务。</p><p>执行以上命令后，在弹出的工作表中编辑脚本的定时规则。</p><p>其格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* * * * * backup.sh</span><br><span class="line">---解释---</span><br><span class="line">前五个 * 分别代表：</span><br><span class="line">分钟 （0-59） </span><br><span class="line">小時 （0-23） </span><br><span class="line">日期 （1-31） </span><br><span class="line">月份 （1-12） </span><br><span class="line">星期 （0-6）//0代表星期天 </span><br></pre></td></tr></table></figure><p>所以，这样就可以很自由的设置定时任务，比如说我定时一个凌晨两点备份数据库信息的任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 2 * * * /home/backup.sh</span><br><span class="line">---解释---</span><br><span class="line">0代表00分</span><br><span class="line">2代表02点</span><br><span class="line">其他没有设置，所以每次到凌晨两点是都会执行这个数据备份脚本。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近一个月</title>
      <link href="/record/2021/04/24/ssn0006/"/>
      <url>/record/2021/04/24/ssn0006/</url>
      
        <content type="html"><![CDATA[<p>我最近在做什么？</p><p>我停止更新了周刊近一个月</p><p>没有push代码一个月</p><p>我这段事件究竟做了什么？</p><p>在工作上，我主要在做需求对接相关的事情。</p><p>我做了目前项目的通用功能的梳理。</p><p>做数据表的设计，和对旧系统数据的一些梳理。学习一个新系统该怎么设计好数据表，学习怎么去做数据迁移。</p><p>还有就是做杂七杂八的一些事情。</p><p>关于其他，跟她清明玩了三四天。母亲大人月中也来北京，周末就基本出去转了。</p><p>还有就是入坑原神…..</p><hr><p>四月末，这个月的确没有做什么事情。</p><p>后悔没有用，下个月立一些flag。</p><ul><li>上下班骑自行车。</li><li>每天编程一小时。（docker）</li><li>（提升自己的技术竞争力）学习一小时（日报）。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间是如何浪费掉的？</title>
      <link href="/record/2021/04/09/ssn0005/"/>
      <url>/record/2021/04/09/ssn0005/</url>
      
        <content type="html"><![CDATA[<p>  几天前，我意识到了一件令人惊讶的事情：浪费时间的最危险方法不是花时间在玩，而是花时间在做假工作。</p><p>  当你花时间玩乐时，你会知道自己在放纵。内心的警报很快就会发出。如果某天早晨我醒来后，整天坐在沙发上看电视，我很快会觉得自己一定是做错了什么。这样一想，就让人不舒服。你只需要在沙发上看电视2个小时，就会有这种不舒服的反应，更不用说整天看电视了。</p><p>  但是，还有一些天，你整天都在忙，等到晚上你问自己今天干了什么，回答是：虽然很忙，做的却没什么意义。</p><p>你的感觉也会因此不好，但是不像整天看电视那样糟糕。如果我整天看电视，我会觉得自己正在走向灭亡，但如果是忙忙碌碌做无意义的事情，这样的警报就不会响起。因为我所做的事情表面上看起来像是真正的工作，比如处理电子邮件。</p><p>  表面上看，你一天都在办公桌前工作，但其实你也是在浪费时间，因为这不会让你的生活发生真正的变化。而且由于你的内心不会发出警报，比起看电视，假工作才是浪费时间最危险的方法。</p><p>  时间要用来做对你真正重要的事情，不要落入假工作的陷阱。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈（07期）</title>
      <link href="/record/2021/04/01/%E6%9D%82%E8%B0%88(07%E6%9C%9F)/"/>
      <url>/record/2021/04/01/%E6%9D%82%E8%B0%88(07%E6%9C%9F)/</url>
      
        <content type="html"><![CDATA[<ol><li>川普卸任总统后剪了一个自我介绍的<a href="https://www.45office.com/">网站</a>，前些天新闻他宣称四年后要继续竞选总统，颇有种老骥伏枥，刘备的那个感觉，不过川普是46年生人，现在已经75岁了，能不能活过四年还是个问题，我倒是希望他能完成目标，如果这样的话，他可能是美国历史上第一个老死在任上的总统。</li><li>最近对币圈关注比较多，也随意买了点（DOGE，NFT…）,不过我发现里面真的是千奇百怪，随便列举几个币的名字（PPT，DNA…），买币我的想法就是拿出你丢了也不心疼的钱去买币即可，顺便推荐一个这方面比较好的浏览器<a href="https://chrome.google.com/webstore/detail/%E5%B0%8F%E5%B8%81/acbboldcmppilbflnijahpgobpkkifkh">插件</a>.(需外网)</li></ol><ul><li><p>工具资源</p><ul><li><p>SpringBoot中配置文件格式<a href="https://www.toyaml.com/index.html">转换</a>  <code>.properties</code>与<code>.yaml</code>互转。</p></li><li><p>Java并发源码视频<a href="https://v2ex.com/t/777374#reply22">讲解</a>，不过看评价挺好的，我还没来及看。</p></li><li><p>github中文项目<a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts">排行榜</a>，emmm，发现榜上很多都是面试、入门教程、推荐、笔记类的内容。国内圈真正硬核类似druid的东西还是不多，希望以后进步。</p></li><li><p>之前我就想过，我对我一直用的IDEA了解多少，我真的会用他？我发现我真的对它并不了解，很多时候项目导入，或者配置的时候出现问题可能解决起来要浪费好多的时间，这些时间被用来做一些没有意义的事，这样的感觉就跟糟糕，所以工欲善其事，必先利其器。看到一个IDEA的使用<a href="https://cdk8s.gitbook.io/github/">教程</a>，值得好好一读</p></li><li><p>github中文项目<a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts">排行榜</a>，emmm，发现榜上很多都是面试、入门教程、推荐、笔记类的内容。国内圈真正硬核类似druid的东西还是不多，希望以后进步。</p></li></ul></li><li><p>之前我就想过，我对我一直用的IDEA了解多少，我真的会用他？我发现我真的对它并不了解，很多时候项目导入，或者配置的时候出现问题可能解决起来要浪费好多的时间，这些时间被用来做一些没有意义的事，这样的感觉就跟糟糕，所以工欲善其事，必先利其器。看到一个IDEA的使用<a href="https://cdk8s.gitbook.io/github/">教程</a>，值得好好一读。</p></li></ul><ul><li><p>最近又看了一遍&lt;不能说的秘密&gt;,路小雨真的是很有气质的那种漂亮。(组织不出别的语言形容她了)<br><img src="https://i.loli.net/2021/05/30/2X9TIYwLUkuKG4b.png" alt="image-20210530151607893"></p></li><li><p>最近看到一个话题—人有没有自由的意志与独立的意识？ 人的行为都是由物质决定的。比如说，胳膊有些被蚊子叮了有些痒，你去挠这是一个没有经过独立意识思考过的一个动作，再比如说，喜欢一个人，可能并不是你喜欢，而是你的身体遵循交配的本能分泌了多巴胺等等一些激素，会让人感觉到喜欢的感觉。去工作是因为不去这具身体会没饭吃…我想吃一个东西真的是我自己想还是我的身体提出了身体缺乏某些营养，于是我得吃点东西的想法放在潜意识里，然后根据哪个意识最强烈进行选择，在现实中即我们做出了选择。我们真的有自由的意志吗？我觉得是有的，在这些层面之上我们应该还有一个“灵魂”，他不遵守物质层面的约定，比如说，思考自己究竟有没有自由意识对这具身体并无帮助，再比如说想起来一个几年前的新闻，大概就是讲大学生跳江救人，最后人救上来，自己没了。他在做出这个决定的时候我相信他的“身体意志”肯定是不同意的。</p><p>但我不知道有多少人向我这样想过，我也相信有很多人一辈子的灵魂困在“身体意志”之中。</p></li></ul><ul><li>其他这样不错，不定时杂谈，欢迎交流评论，懒得发别的频道了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 期刊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随想</title>
      <link href="/record/2021/03/25/ssn0004/"/>
      <url>/record/2021/03/25/ssn0004/</url>
      
        <content type="html"><![CDATA[<p> 晚上听歌，做白天计划的博客内容，歌单很惊喜，听的只想跳舞。编码挺不顺利，不过勉强不算浪费。停下来出去转了一阵，感觉自己越发的超脱，看破红尘，灵魂又出窍高高的俯视这肉身。<br>  就是莫名的超脱，感觉人生不过如此，站的高一眼可以望到头。感觉爱情不过如此，不过是一个人活的艰难，有个人可以相互依靠，然而我并没有经历过大起大落的人生，没有完整的经历过爱情，我为什么会出现那种超脱的感觉？<br>  博客我觉得基本内容就这样了，要做迭代的话就是做一些实验性的迭代，比如说引入redis让每次加载自我介绍的时候不要出现function好几秒才能加载出本来的自我介绍。把博客打成docke r和服务器中其他服务放在服务器中，还有可以试试配置数据库连接池，这很多可以做的，为什么非要盯着前端那点样式不停的改改改呢？</p><p>  做一个助手robot的确是个不错的主意，但是用万事开头难在我不知道怎么下手，怎么敲下第一行代码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次服务器破防</title>
      <link href="/record/2021/03/22/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A0%B4%E9%98%B2/"/>
      <url>/record/2021/03/22/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A0%B4%E9%98%B2/</url>
      
        <content type="html"><![CDATA[<p>今天刚回家下载好了原神就开始玩，下班到家就开始玩，玩到快十点的样子终于感觉到自己有些上头了，然后手机一看aliyun的短信:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">【阿里云】尊敬的dianedii：云盾云安全中心检测到您的服务器：xxxx（xxx...）出现了紧急安全事件：</span><br><span class="line">恶意脚本代码执行，建议您立即登录云安全中心控制台-安全告警处理http://a.aliyun.com/f1.mNLog 进行处理</span><br></pre></td></tr></table></figure><p>不会吧不会吧，数据库不会被人搞掉吧。上线一看系统六点二十四被打….那会我刚玩游戏…还好数据还在…虽说数据也就是博客的一些内容个一些小的服务接口(可能人家看不上)…不过还好还在。</p><p><img src="https://i.loli.net/2021/03/17/xFeOvt1nWUg78Ad.png" alt="img"><img src="https://i.loli.net/2021/03/17/JVxDhjoRNYfCXes.png" alt="img"><img src="https://i.loli.net/2021/03/17/BxwWCcF6uGjd2YP.png" alt="img"></p><p>  进了aliyun控制台也不知道看了一下是被执行了恶意脚本…图省事直接重启.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">告警原因：持久化后门</span><br><span class="line">详情：crontab计划任务导致了该告警的产生。crontab是Linux操作系统中常用的计划任务服务，黑客或恶意程序常常会通过添加修改cron任务使恶意程序定时重复启动，保持驻留。</span><br><span class="line">建议：您可以手动查找crontab中的异常项目进行处理，或使用病毒扫描功能对主机进行全面的扫描清理。</span><br></pre></td></tr></table></figure><p>  原因应该是我为了图省事，开放了服务器的所有端口，这是开放的第二天…以后再也不敢了QAQ，安全之心要一直有，我还需要搞个数据库定时备份脚本….</p><p>  最后，给大家观摩一下这个邪恶的脚本，可以在自己虚拟机试一试，仅供学习观摩使用,点此<a href="https://dianedii-wallpaper.oss-cn-beijing.aliyuncs.com/b.sh">下载</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理想的工作状态</title>
      <link href="/record/2021/03/18/ssn0003/"/>
      <url>/record/2021/03/18/ssn0003/</url>
      
        <content type="html"><![CDATA[<p>今天认真看了湾区日报的一些建设方面的<a href="https://wanqu.co/b/7/%E6%B9%BE%E5%8C%BA%E6%97%A5%E6%8A%A5%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/">文章</a>，作者一个人用业余时间优雅的运行维护这样一个<a href="https://wanqu.co/">网站</a>，并且做的有声有色我真的是五体投地。作者现在的工作的状态正是我的我理想中的工作/编码生活，如何工作，写文字，如何认真的做一件事情。</p><p>同样的发现了菜鸟教程也是一个人在维护与建设而不是一个团队，还有其他很多很厉害的人，他们的生活工作方式突破了我的认知，最大程度的构建工具使大部分工作自动化运行。高效的编码，一个小时来做一次简单的迭代。每天花一到三个钟头来进行阅读。对比一下才发现人和人的差距真的就是在一天天中拉开的。我的一天顶人家高效的一个小时，这感觉特别不舒服。</p><p>我能在我的工作生活中做什么东西？</p><ol><li> 可能也需要构建一个自己的机器人/更多的脚本（docker构建一些内容，免去一些同质化的操作）</li><li>做一个筛选，对我目前从媒体上获取的东西做一个分类与整理。</li><li>idea的管理，与实现，我觉得我开了一个好头，我的想法是编程仅仅为了工作就有点没意思，能用到他帮助到我，才算是编程的意义。（不知道我几年后还会这么想吗）</li><li>身体的管理，这点相当失败。</li></ol><p>​    做完这些东西也相当于检视了自己，有点像玄幻小说中武者突破后有了内视的能力，可以看见丹田内功运行到什么程度，也像监测服务器各项指标的脚本，我们实时的监测服务器是否正常，监测微服务系统的运行。为什么就不能实时监测我们自己呢，完整的把握自己，清晰了解自己的情况。由心理到身体实时监测，并做统计报表，分析并在适合的地方发力。这才是我觉得好的方向，科学进步的方向。</p><p>PS:脑洞大开，想起了刘徽的割圆术，机器就像一个五边形，把它割呀割，割到极致的时候可能就是人这个样子了。所以反过来说人也是机器迭代极致版。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈（06期）</title>
      <link href="/record/2021/03/18/%E6%9D%82%E8%B0%88(06%E6%9C%9F)/"/>
      <url>/record/2021/03/18/%E6%9D%82%E8%B0%88(06%E6%9C%9F)/</url>
      
        <content type="html"><![CDATA[<p>三月的最后一期，心情有些伤感。</p><p>博客园突然的关了一段时间，更加坚定了我独立博客的念头。</p><p>有点摸索到我想分享什么。不想分享新闻，就想探索互联网下的边边角角，走到哪看到哪，记下一部分这个有意思的世界。</p><ul><li>知识</li><li>什么是webservice，对此不太了解的人可以读<a href="https://www.cnblogs.com/xdp-gacl/p/4048937.html">这篇</a>文章，看完基本就懂了。<ul><li>Linux中chown与chgrp具体是做什么的，还记得吗，不太清楚的可以看一下<a href="http://www.voidcn.com/article/p-aprjsdlm-mk.html">这篇</a>文章。</li><li>刚开始学redis的时候，了解了redis的这个那个特性，但不知道怎么在项目中可以用到，这篇<a href="https://www.jianshu.com/p/72b0c4aa89cc">文章</a>讲了在springboot框架下怎么使用redis。</li><li>最近才发现apache实现了Java的很多工具类，很多工具类都是重复的实现一个功能，以下是apache-common常见工具类的一些<a href="https://segmentfault.com/a/1190000020376765?utm_source=tag-newest">介绍</a>。</li></ul></li></ul><ul><li><p>资源</p><ul><li><a href="https://oncetalk.com/login.html">轻说</a>，一个随想记录平台，的确有这个需求，轻社交，有些东西记在手机备忘录总感觉会埋没一样，不过我开始用twitter来满足我的需求。</li><li><a href="https://duibiao.info/">职级对标</a>，一个包括但不限于分享薪酬的网站，好像目前只有大厂，我找到<a href="https://duibiao.info/2020">这里</a>，算了一下在拼多多工作的人，如果每周能休息一天，那他剩下六天里每天要工作11个小时。</li></ul></li><li><p>文章</p><ul><li>2021全球胡润富豪<a href="http://www.jjyc.org/a/d/213389">排行榜</a>，扎克伯格最年轻，39岁。中国最富是农夫山泉的钟睒睒（shǎn）。</li><li>一个程序员在创业公司工作一年的<a href="https://www.cnblogs.com/xdp-gacl/p/5294181.html">经历</a>，真实的写照。</li></ul></li><li><p>言论</p><ul><li>人为什么害怕独处？因为人在独处的时候，总是会听到心灵深处的声音，这个心灵深处的声音会不断地逼问你，“你这一生到底想干嘛，你怎样活着才是有意义的”，当这个声音不断逼问你的时候，你会觉得烦躁，你会觉得焦虑。因为你耳边始终有这种声音，所以你会堵住耳朵，你说，“别说了”。而当这个声音，沉寂的时候，你又会感到空虚，会感到迷茫。所以当你独处的时候，你始终在焦虑迷茫空虚中，周而复始。大部分的人，会选择拒绝倾听心灵深处的追问，他们会选择用忙碌来对抗这种事，放肆娱乐，拼命工作      –罗翔</li><li>今天被工长骂了说我水泥拌的太稀 工长把我的铁锹锤烂了 问我水是不是不要钱 我不敢反驳 他不知道的是 我没有多放水 只是拌水泥时很想你 眼泪掉进了水泥里。 –佚名</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 期刊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何将网站转成https站点</title>
      <link href="/record/2021/03/10/%E5%A6%82%E4%BD%95%E5%B0%86%E7%BD%91%E7%AB%99%E8%BD%AC%E6%88%90https%E7%AB%99%E7%82%B9/"/>
      <url>/record/2021/03/10/%E5%A6%82%E4%BD%95%E5%B0%86%E7%BD%91%E7%AB%99%E8%BD%AC%E6%88%90https%E7%AB%99%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>1.前提条件及准备工作</p><p>​    以阿里云平台为演示：</p><p>​    首先已经准备好：云服务器，已备案域名</p><img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/TB1Fe9fxQP2gK0jSZPxXXacQpXa-1006-109.svg" alt="流程" style="zoom:50%;" /><p>2.申请免费ssl证书</p><p>​    我们选择DV证书，以下是具体流程。</p><p>​    进入aliyun控制台在产品与服务中找到域名入口，</p><img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/image-20210218163801766.png" alt="image-20210218163801766" style="zoom: 33%;" /><p>​    点击进入域名详情</p><img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/image-20210218163920029.png" alt="image-20210218163920029" style="zoom:33%;" /><p>​    点击开启SSL证书，如下，并点击购买证书。</p><img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/image-20210218163405023.png" alt="image-20210218163405023" style="zoom:33%;" /><p>​    出现如下界面，直接点击 ‘ 证书资源包 ’链接。</p><img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/image-20210218164158722.png" alt="image-20210218164158722" style="zoom:33%;" /><p>​    选择相对应的选项如下，证书个数选20就行，一年只用一个。</p><img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/image-20210218163326513.png" alt="image-20210218163326513" style="zoom:33%;" /><p>​    购买后，返回控制台，在‘ 产品与服务 ’中点击‘ SSL证书（应用安全）‘，进入后点击左侧证书资源包，点击证书申请。</p><img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/image-20210218164838734.png" alt="image-20210218164838734" style="zoom:33%;" /><img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/image-20210218164934982.png" alt="image-20210218164934982" style="zoom:33%;" /><p>​    按照提示填写相应个人信息即可申请成功。</p><p>3.服务器安装证书</p><p>​    申请成功后点击’’证书下载’’，下载相应证书，这里以nginx证书为例进行证书的<a href="https://help.aliyun.com/document_detail/98728.html?spm=5176.14113079.0.dexternal.3e4756a7koL93c">安装部署</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈（05期）</title>
      <link href="/record/2021/03/08/%E6%9D%82%E8%B0%88(05%E6%9C%9F)/"/>
      <url>/record/2021/03/08/%E6%9D%82%E8%B0%88(05%E6%9C%9F)/</url>
      
        <content type="html"><![CDATA[<ul><li><p>知识</p><ul><li>常见Mysql方面的面试<a href="https://blog.csdn.net/u014209205/article/details/83051001">知识</a>。</li><li>一个秒杀系统的<a href="https://github.com/zaiyunduan123/springboot-seckill">实现</a>，想了解Redis在SpringBoot中怎么用的可以看一下其实现。</li></ul></li></ul><ul><li><p>资源</p><ul><li>HUBOT,一个可以可扩展的机器人<a href="https://hubot.github.com/">助手</a>,我没添加其他方向上的修饰形容词，是因为它可以可做到的方面太多了，我尝试搭建了hubot，并在slack上操作他。</li><li><a href="https://stackoverflow.com/">stackoverflow</a>，国外比较热门且氛围比较好的论坛，最近论坛逛的太多了：CSDN，博客园，V2EX,吾爱，掘金，语雀。发现的确是CSDN垃圾最多，这点在它的排行榜很容易就看出来。还有得到的教训就是少逛论坛，多敲代码。</li><li>谷歌<a href="https://calendar.google.com/calendar/">日历</a>，最近发现出奇的好用，已替换本地的日历推送。</li><li><a href="https://slack.com/">Slack</a>，办公交流协作平台，整合类似钉钉+QQ+微信随时拉群+各种三方扩展，的确好用，支持国内。</li><li><a href="http://chs.desktopcal.com/chs/">desktopcal</a>，一款好用的windows桌面日历日程软件</li></ul></li><li><p>文章</p><ul><li>一个人怎么在业余时间维护一个网站&amp;APP，湾区日报作者的<a href="https://wanqu.co/b/7/%E6%B9%BE%E5%8C%BA%E6%97%A5%E6%8A%A5%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/">自述</a>。</li></ul></li><li><p>言论</p><ul><li>不要到处宣扬自己的内心，这世上不知你一个人有故事。 –知乎用户</li><li>我无法控制自己对你的难以忘怀，可是我对关于你的一切已经再也没有了期待 –《one day》</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 期刊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>赘婿</title>
      <link href="/record/2021/03/07/ssn0002/"/>
      <url>/record/2021/03/07/ssn0002/</url>
      
        <content type="html"><![CDATA[<p>最近在追这个《赘婿》这个电视剧，分明就是庆余年原班人马凑一块，翻拍了一版低质量的翻版电视剧，我刚开始是在B站上看到有人提这个才想着看一下的态度结果钻进去了….上周一下更新了八集我tm熬夜一下子全给看完了，电视剧逻辑1分（满分10），轻松8分，乐呵8分，看完我也明白了，人家拍着电视剧的就没想着拍出逻辑来，就整一轻喜剧出来，哎，就主打”搞笑”,”轻松”，就是给大家放松来的。看到很多人批评这电视剧不合理，这不行那不行的要么是没看懂人家拍着电视剧意思，要么就是顺着这流量给自己涨涨热度的。</p><p>  这个风老早就有，刚开始就小说嘛，爽文无限升级，扮猪吃老虎，为了读者爽，这种套路多了后，不太吃香了，就在小说上就慢慢就转换形式，但是本质上是不变的啊，反正就是变着法让读者爽，然后前两年就发现有那种动漫（番），就也是这种了，反正无敌啊爽这种套路就从书就到漫画了现在小说改电视剧，本来就一挺爽的文编剧再一加工，再德云社少东家一出来，这电视剧也就开始搞着套路了，这电视剧就是《赘婿》这个样子了，哎我啥都不管，我就管让你能笑出来就行。</p><p>  当然我这样下去是不行滴，这个拍电视剧吧，这个歪风邪气一起，就各路大神就都会跟风效仿，就怕是会越来越无脑了，虽然我如此说吧，我知道这个电视剧不行，但我还是想把它看完。我就吃这一套.</p><p>-–</p><p>看了后半截继续来吐槽，爱奇艺整个超前点播我理解，找个别的渠道也挺方便，边看边跳者看完了，这剧情越来越离谱…..我不禁怀疑自己是不是闲的没事干，我收回之前的话，我吃不了这一套了，这爽剧我看不下去了，完全是《庆余年》的拼多多版，还是9.9包邮那种。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的吉他</title>
      <link href="/record/2021/03/03/ssn0001/"/>
      <url>/record/2021/03/03/ssn0001/</url>
      
        <content type="html"><![CDATA[<p>​    B站上经常看见各种乐器的视频，看越多平台也就推送越多，然后就经常看到弹吉他的视频了，昨天还是前天，脑子里突然就蹦出了个想法，买一把吉他吧。</p><p>​    我做事三分钟热度，我自己深刻了然，但是这个念头还是挥之不去，然后想一想，买一把入门里面最便宜的，如果坚持不下去就走闲鱼….</p><p>​    ok,昨天晚上就下单了，京东基本上最便宜的吉他，卡马D1c,今天晚上到，有点期待。</p><p>​    这会已经下午了，脑子里又不由自主冒起了悲情魔音，呆唯，现在无心工作.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL使用全文索引实现大字段的模糊查询</title>
      <link href="/record/2021/03/02/MySQL%E4%BD%BF%E7%94%A8%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0%E5%A4%A7%E5%AD%97%E6%AE%B5%E7%9A%84%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/"/>
      <url>/record/2021/03/02/MySQL%E4%BD%BF%E7%94%A8%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0%E5%A4%A7%E5%AD%97%E6%AE%B5%E7%9A%84%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<ol><li><p>场景说明 </p><p>有一个需求，用户输入关键字对博客系统内所有含有该字段的文章(标题&amp;简介&amp;内容)进行展示，我自然而然地想到了索引。这里我是在CentOS7下MySql5.7版本的数据库.</p></li><li><p>创建表</p><p>因为是一个全局搜索的的需求，用户输入关键字对博客系统内所有含有该字段的文章(标题&amp;简介&amp;内容)进行展示,(上表只是文章内容表)，由于要对文章内容进行搜素，而文章内容content在数据库中是以text存储的，所以为了查询效率，这里就需要使用索引，由于是查大文本，这里选择使用全文索引(fulltext).</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `tbl_article_content`;</span><br><span class="line">CREATE TABLE `tbl_article_content`  (</span><br><span class="line">  `id` bigint(40) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `article_id` bigint(40) NOT NULL COMMENT &#x27;对应文章ID&#x27;,</span><br><span class="line">  `create_by` datetime(0) NOT NULL COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `modifield_by` datetime(0) NOT NULL COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE,</span><br><span class="line">  INDEX `artid`(`article_id`) USING BTREE,</span><br><span class="line">  FULLTEXT INDEX `content_word`(`content`) WITH PARSER `ngram`</span><br><span class="line">) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</span><br><span class="line"></span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br></pre></td></tr></table></figure><ol start="3"><li>创建索引（使用ngram解析器）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create fulltext index content_word on tbl_article_content(content) WITH PARSER ngram;</span><br></pre></td></tr></table></figure><p><code>ngram</code> 是一个支持中文索引的分词引擎， 在这里我们对<code>tbl_article_content</code>表的<code>content</code>字段建一个叫<code>content_word</code>的全文索引.</p><ol start="4"><li><p>mysql配置（my.cnf） </p><p>mysql默认是没有开启与配置ngram的，所以在建立索引后对mysql进行配置 打开mysql配置文件</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></table></figure><p>在[mysqld]下加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ft_min_word_len=1    #全文索引的最小搜索长度。默认是4</span><br><span class="line">ngram_token_size=1   #分词的大小设置，这里设置越小，索引越大</span><br></pre></td></tr></table></figure><p>在终端重启mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>如果是在已有的表上对某一个字段增加索引，在此需要修复一下之前创的索引.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repair table tbl_article_content</span><br></pre></td></tr></table></figure><ol start="5"><li>如何在项目中使用刚才创建的索引进行查询呢？</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select article_id FROM tbl_article_content WHERE MATCH(content) AGAINST(&#x27;没有了&#x27;);</span><br></pre></td></tr></table></figure><ol start="6"><li><p>总结问题 </p><p>从MySQL 5.7开始，MySQL内置了ngram全文检索插件，用来支持中文分词，并且对MyISAM和InnoDB引擎有效，使用的时候注意自己版本号和配置.</p></li><li><p>   相关命令</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show create table tbl_article_content; //查询当前表信息</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%ngram%&#x27;;  //查询ngram引擎配置信息</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈（04期）</title>
      <link href="/record/2021/03/01/%E6%9D%82%E8%B0%88(04%E6%9C%9F)/"/>
      <url>/record/2021/03/01/%E6%9D%82%E8%B0%88(04%E6%9C%9F)/</url>
      
        <content type="html"><![CDATA[<p>写在前面，周刊有些名不副实了，写这个的时候发现自己一周也没有摄入多少有营养值得分享的东西，就目前来看，周刊已经变成半月谈了hh。</p><ul><li><p>知识</p><ul><li>一篇有意思的讲工作流引擎的实现的<a href="https://www.cnblogs.com/duck-and-duck/archive/2021/03/03/14436373.html">文章</a>，由简入深，文风诙谐。</li><li>解释什么是<a href="https://blog.csdn.net/weixin_43719843/article/details/114610825">微服务</a>,顺便感叹一句，为了解决用户量与并发的问题，使用微服务引入了更多的问题。</li></ul></li></ul><ul><li><p>资源</p><ul><li>一个显示访问IP的<a href="http://pv.sohu.com/cityjson?ie=utf-8">接口</a>,可以用来统计网站访问IP</li><li>电视剧&lt;赘婿&gt;全集观看<a href="https://www.tlyy.cc/dsj/dsj1/zhuixu/bf-0-32.html">地址</a>,其他影视资源也比较齐全。</li><li>一个网络流行语收集查询<a href="https://jikipedia.com/">网站</a>,人老了很多梗也不是实时能追到的,之前一直明白RickRoll是什么梗，辛苦查了半天。</li><li><a href="https://www.v2ex.com/">v2ex</a>,一个创意工作者的社区，基本都是互联网相关，社区比较严格，氛围很棒。</li><li>一个README中的徽标生成<a href="https://shields.io/">网站</a></li></ul></li><li><p>文章</p><ul><li>在银行做软件开发的优劣，别人的<a href="https://www.cnblogs.com/didispace/archive/2021/03/01/14463731.html">经验</a>。</li></ul></li><li><p>言论</p><ul><li>你在这里所做的每一件事情，都会消耗你的时间。倘若一件事情做完之后，无法得到任何有意义的回应，那么这件事情就像是白做了。如果一个人持续做那些无意义的事情，那么他实际上就是在浪费他的时间。 –v2ex</li><li>区块链不会骗人，但有人用区块链骗人。–佚名</li><li>坚持本身就是一种很厉害的能力 –佚名</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 期刊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈（03期）</title>
      <link href="/record/2021/02/18/%E6%9D%82%E8%B0%88(03%E6%9C%9F)/"/>
      <url>/record/2021/02/18/%E6%9D%82%E8%B0%88(03%E6%9C%9F)/</url>
      
        <content type="html"><![CDATA[<ul><li><p>知识</p><ul><li>怎么在GitHub个人页设置个人介绍进行展示，这里是<a href="https://blog.csdn.net/qq945655645/article/details/108745636">教程</a>。</li><li>形象的<a href="https://www.wmyskxz.com/2021/02/16/wang-luo-4/">科普</a>浏览器是怎么运行的。</li><li>工厂模式的一个形象<a href="https://www.cnblogs.com/foxhappy/p/14419557.html">讲解</a>。</li></ul></li></ul><ul><li><p>资源</p><ul><li>算法学习，leecode刷题技巧，<a href="https://labuladong.gitbook.io/algo-en/v/master/">labuladong的算法小抄</a>。</li><li>一个有意思的<a href="https://yihong.run/">博客</a>，它的友链也值得一去。</li><li>bing每日壁纸汇总与<a href="https://bing.ioliu.cn/">下载</a>。</li><li>软件脱壳破解入门<a href="https://www.52pojie.cn/thread-1358649-1-1.html">教程</a>。</li></ul></li><li><p>文章</p><ul><li>对于工作的<a href="https://new.qq.com/omn/20191011/20191011A0RHS400.html">看法</a>。</li><li>别的普通人2020的<a href="https://www.cnblogs.com/Twittytop/p/14421753.html">总结</a>。</li><li>一个有意思面试<a href="https://www.techug.com/post/sorry-cant-hire-you.html">吐槽</a>，看完可以去做一下这道<a href="https://leetcode-cn.com/problems/invert-binary-tree/">题</a>。</li></ul></li><li><p>言论</p><ul><li>开发中遇到越是奇葩的问题，越应该从基础上排查。     – dianedii</li><li>工具好不好主要看用的人。 —-Mantra</li><li>腾讯三分之一的收入是游戏。一年 1000 多亿元的游戏收入，常年在世界游戏公司收入中排名第一。讽刺的是，这个第一既做不出像使命召唤、星际争霸这样征服全球的 3A 游戏，也不能像 Microsoft、任天堂、索尼一样，做出 Xbox、Switch、PS 这样的顶级游戏硬件。这个星球上最赚钱的游戏公司，却对游戏行业的进步提供不了一丝一毫的推动。他是全世界最尴尬的游戏之王。–匿名</li><li>这是一个千年未遇的大时代，大家的温饱都解决了，可是我们却比任何一个时代都更焦虑，这太不可思议了……    –<a href="https://www.huxiu.com/article/376133.html">郑也夫</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 期刊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈（02期）</title>
      <link href="/record/2021/02/08/%E6%9D%82%E8%B0%88(02%E6%9C%9F)/"/>
      <url>/record/2021/02/08/%E6%9D%82%E8%B0%88(02%E6%9C%9F)/</url>
      
        <content type="html"><![CDATA[<ul><li><p>技术知识</p><ul><li>Java中队列queue使用的比较多，这里介绍Java中的双端队列<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265122668445536">deque</a>。</li><li>你真的了解GET请求与POST请求吗，还是只是停留在浅层，这篇文章由浅入深介绍<a href="https://www.cnblogs.com/yinrw/p/10694735.html">GET和POST两种基本请求方法的区别。</a></li><li>作者亲历解决一个SQL注入问题，讲了怎么规避sql注入的一些方法。  <a href="https://www.cnblogs.com/12lisu/p/14403500.html">卧槽，sql注入竟然把我们的系统搞挂了</a></li><li>理解递归<a href="https://blog.csdn.net/allenchenhh133/article/details/80291252">思想</a>，讲的比清晰明了。</li></ul></li><li><p>互联网资源</p><ul><li><p>一个好用的<a href="https://www.mdnice.com/">Markdown排版工具</a>，优点是支持一键转化公众号，知乎掘金等平台。</p><img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/image-20210219205059081.png" alt="image-20210219205059081" style="zoom:50%;" /></li><li><p>Java程序员进阶/面试向的文档<a href="https://github.com/crisxuan/bestJavaer">教程</a>，作者相当认真。</p></li><li><p>一个内容聚合搜索<a href="http://search.kunhai.xyz/">引擎</a>，优点是聚合的引擎相当全面，缺点是搜索结果页面头部优点臃肿，不太好看。</p><img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/image-20210219205015248.png" alt="image-20210219205015248" style="zoom:50%;" /></li><li><p>一个有意思的骗子<a href="http://www.hczwq.com/">网站</a>。（成功学分支）</p><img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/image-20210219204911571.png" alt="image-20210219204911571" style="zoom:50%;" /></li></ul></li><li><p>文章</p><ul><li><a href="https://news.cnblogs.com/n/688057/">网红小游戏割韭菜套路大揭秘</a>，以微信小游戏为主，讲了小游戏发布的乱象，我以前也沉迷过一个开车过关游戏，玩了整整一天，幸好只是看广告和转发。</li><li>电影推荐： <a href="https://www.bilibili.com/bangumi/media/md60452">我在伊朗长大</a>，以一个伊朗家境优渥子女的角度讲解这个国家的不幸与悲哀，关于人的一些思考，动画黑白电影。</li><li><a href="https://lemire.me/blog/2018/12/06/asking-the-right-question-is-more-important-than-getting-the-right-answer/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website">提出一个好问题比得到答案更重要</a>，当你一点一点明确自己要问什么的时候，有时候你就已经能找到答案了。</li><li>这篇文章以讲故事的方法来讲<a href="https://www.cnblogs.com/flashsun/p/14266148.html">什么是网络</a>，比看《计算机网络》有意思多了。</li></ul></li><li><p>言论</p><ul><li>一流的企业卖标准，二流的企业卖品牌，三流的企业卖产品，四流的企业卖苦力 –匿名</li><li>如无必要，勿增实体。 –奥卡姆剃刀原理</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 期刊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈（01期）</title>
      <link href="/record/2021/02/02/%E6%9D%82%E8%B0%88(01%E6%9C%9F)/"/>
      <url>/record/2021/02/02/%E6%9D%82%E8%B0%88(01%E6%9C%9F)/</url>
      
        <content type="html"><![CDATA[<ul><li><p>后端知识</p><ul><li><p>雪花算法的原理及实现，通俗易懂，还有代码<a href="https://zhuanlan.zhihu.com/p/77811438">实现</a>。</p><p><img src="https://pic1.zhimg.com/80/v2-89659f2e11fdbdacd672a26b7be42068_1440w.jpg" alt="img"></p></li><li><p>滑动窗口算法，也叫尺滑法，这里是它的<a href="https://www.cnblogs.com/huansky/p/13488234.html">讲解</a></p><p><img src="https://img-blog.csdnimg.cn/20190305164439172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtMjc4ODU4NDQ1,size_16,color_FFFFFF,t_70" alt="滑动窗口算法基本"></p></li><li><p>计算机网络IP相关知识<a href="https://zhuanlan.zhihu.com/p/138235610">梳理</a>，生动形象，易于理解。</p></li></ul></li></ul><ul><li><p>资源</p><ul><li>github默认头像<a href="https://tools.prodless.com/avatar">api</a>，很有意思，还可以自定义部分参数，<br><img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/image-20210204000722221.png" alt="image-20210204000722221"></li></ul></li></ul><ul><li>一个动漫番剧下载<a href="https://mikanani.me/">网站</a> ，界面友好，中文网站，资源较全，</li></ul><p><img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/image-20210204000347958.png" alt="image-20210204000347958"></p><ul><li><a href="https://www.yuque.com/">语雀</a>，一个质量比较高的程序员论坛/博客园/知识库，界面清爽，大佬多。</li></ul><p>  <img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/image-20210204000534368.png" alt="image-20210204000534368"></p><ul><li><a href="https://www.hutool.cn/">hutool</a>，一个开源工具集，封装一些复杂操作的一个Java工具类集合.</li></ul><p>  <img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/image-20210204000615375.png" alt="image-20210204000615375"></p><ul><li>AdGuard,一个浏览器广告拦截工具，还可以自定义拦截<div>,支持Edge，Chrome，FireFox，在相对应插件商店中下载，这里给出Edge下载<a href="https://microsoftedge.microsoft.com/addons/search/adguard?hl=zh-CN">地址</a></li></ul><p><img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/image-20210205103205221.png" alt="image-20210205103205221"></p><p>  <img src="https://dianedii-weekly.oss-cn-beijing.aliyuncs.com/img/image-20210204000801611.png" alt="image-20210204000801611"></p><ul><li><p>文章</p><ul><li><p>一名工人子弟的<a href="http://bbs.tianya.cn/post-no20-690736-1.shtml">人生经历</a>（兼谈机关生涯），讲述七八十年代一名普通人从上学到中年的经历，很有时代感，值得一读。</p></li><li><p>一个面试官角度的面试<a href="https://www.cnblogs.com/liyao0312/p/11368351.html">经验帖</a>（Java），思路是通用的，值得借鉴。</p></li><li><p><a href="https://www.yuque.com/zenany/up/high_productivity_work">如何高效工作</a>，达到期望的高效基本是不可能的，但尽可能地提高是必要地。</p></li></ul></li><li><p>言论</p><ul><li><p>如此生活三十年，直到大厦崩塌。 —《杀死那个石家庄人》</p></li><li><p>找逻辑的漏洞总是很容易，可是这并不能证明你牛逼。 —stromzhang</p></li><li><p>If you don’t make a choice, the choices make you    —佚名</p></li><li><p>先把自己置身于问题之中，才有机会解决问题。 —李靖</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 期刊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鸡汤</title>
      <link href="/record/2019/07/07/%E9%B8%A1%E6%B1%A4/"/>
      <url>/record/2019/07/07/%E9%B8%A1%E6%B1%A4/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="430f28e1ec9e420f8f421e627653d2086356f0ed3dcfd2fe606af1a22187e11c">73ec4e90604b298de70b40cddedb7a1361b462f307d9ce1a3289179ffa3c19971747052032c958ed94579d485b517d21dd85bc0ace7924707c6e1a4259d6c94d772e65e8df9daf38cd1bf4cd1adc245f8450f4849e81858cb25c3c386f889946829d3ba21adad6ab46e67a174a9860291679e2e423635b283c8d753fd1310e51b1b49c079e6cb878e3bdb611c6f8b5f32c288126efb8716e8a25e16feb9cc126f48b7be90fcbec5e1121f929123450c8111fd415d1ef8f574d92b6d12585c32469454151c8235a10d98d48e65cb5488060e3dccc22b36ecb1111750c9da59ee9d4599672e8ba2f3396c7b824adcd99ef858c827bcab1608e4cf0ddc6ab5b3410fdb1b838257a2f4530b2f72da51e0b8f119d1521acd10b94bab1d8d61a6939beb228283030008953f2b7dc0f35c7a1916510716d362d04b7da78bd17a438db9f58ac9ce5617fba02bb2e7019a275b5454f311656bfcf2ea2f31e034e48333bfc9b9138c6017c2b9ced194127ffa554042f87b1c92f999694ffada3eb178c55ea71e6344062449d3a2815a9b24bbcd46cc461101e917fdbe12d8d3b575030e25ad6fd48829cfb4ffcdb2bb1fcdcea87238289f43067774d59a6fc177658ae98388d2d389c162e471268083fad1c53a615eba2193dc84cc816337ca9e529f0ab0deabda57dedd021d13a675bcf66bc87bc9266c4ad716c03f5be2f982b6a11ad086db6d56586a084787696abca38256a9fba6fc1ad525c6ebff181623dc28bbc7b0512e006943271bab95db383ed5466e87b77cbcaebc39dc98bc2445bad4684d7a7b83faa38ead783f549e6feaf0d84628624e667591733e556aef0619f8ecb68797e63de8f7ec3354108701f4fedc8dff8a99553caff0857429a8d24f0007e265151c8e6eadaff47824830e37c08368532d60a4952db194a6928e6dd45c83f036d44f67cd919a2592973a7722efcf3107780466f37d636ce3c6c857b95af91f50ab91718efd4d6038b04e5f9a268147f1bcc2a69829e82003e4133e92e46009b1136beb3e0a33e3e29983f121badd9cf87e8b05344015f05f57247f9d11b743a23b9ef0eced64592b29ff7a0e1bbaaaee43810aa15dc49a1d1eb6df93f3b57f57192a94c51c2cf61c3ffed9fe6a79e5b98bb39600f08d63d80d7725c3f9b57482ef4c5a3e954fb103ccca89a0dc4ecaf6e79a63aa9354cebca74dbaa8ed5713eb61146039a82be7eb707935c76872a3208d0621f79a147ec0af407fe865aa4f2778de458feb2e7d69a17667878b9f3faa8a63df96421273c77b7393e56bf5d0abdfd6aff4399924967e4b63c99ddc25e9e5652144872be1384845c6fda262d5c0de2916c88d2d2fc16df3f4c9addd283c434a6d14f1a72895c62df679a84d70eb140ed76f87f383003c47916e89fe4ce898df942e5b6d08ceca20d3c2dbccc4af773ee972cf8045fb3826428de9974afd22efce0b6e9384d5f7b80a68e4a0f6cff4fdbedc4f2fa32a717fa3c1b1d7f83a965fad82d44b2d2964e445feed49fdd62a403156b0828dfa94d64b5ec7046717e2ed82b67126f14374afd13ce58a4160ff52a85ec805b72829d4d880569ff1d35e0ef8919ef598f9bbada30a892821398739ba4854fb510dd9bd011b60ef16d0499086794a7e05585a4b6c9739ebe36f7c659d7668ee12ccf56d501eac94b72e653dac337727414b6a2a73381f025b78c098ccbe0618a68bce801db3174191f087168fd2d41a1f947f228a827208f1cbf61ed5ba08568fc61fc9647874fe11b76e5e250dfe8652141b92b4a7d3003ce7c7cb5278672ed94141c260502e86b200545c0c909747b21c49e351a73ab3c500fbdcdf1afb8c366d84b28be5ac8422ff2ffe8d8d8282614a8500aef9b4312aa38edcfbe66fdc102921fc7ac8bcfcbe3c6bf5326ce9281297ad2a4ea4f92d404f6b980b1178983c198362ea1cd77f6299ae97481417d65432d85597890408b7facfdd39e566118476fb913d72fcb35662436f12bf2b499b159d038efc70804dd54c269856df48a68a367198357c7146dc128134a00240eb72259e563fbfadcdf7acfe78caf8800f2d01d58f34877fc2b2c94d7a95c7b4de21e641ad2dd84a3aa6a607b80e6df7a47282b0335ebf3862dbdf739bf4c04cdea89e3860da4287cc1e1cf05287ff339ca29d18fd0b3b25bae7d1996a3efc9d7a03308e653db118911239b677a9bc20d57f3141a202e257cf849d60dc0fc9f8ddbf6b9901ad91b57fe08bd10d3e7b140b2bd0c1556cc80a0e8dca6ee6d5fe03d1b79bb173f85f45e1f94f6c14cd305a93d1b082356fd7b6adbf28ee6e8619d4cd7ec7c57a9207cf9345bdf84aecab6cd43ed29776d55e12d09cc1b7e734483f40c86408942c270ad02fa3bf1c28d54c4e559a9d8d9f16379b4e2387f1348f98be4dbbdb26d561da7a3f147de2c23d46b30a53d929944684a916829cb496251b384fb4d9e3bbe905dbe3c7f7218c35c1ce5cd62313baf0db320d4691f7738ba083fc79695ff8db256d740171304b934efd4055e4cfb2a10b2f1fbae774adb3e1f3e4d04334e9e008a64b36fddc973cf04460c442cf23d91e917f7dffdb86f04983594533b54aa342f9502e49571f0556b12f2c8266080b55781bbc9fadc76a4874101554abdf4fbb761dfb94afc2a45e33672df36290e13033a09a5bba699df2548119aa1d5f8e3a6052d7edfc1021ff6f13324fb1e506bf9f9d1d015fc693361def27805e3bafddc9c9ea5f43c2dcbb700ed76581ea1264a579919ed92c0b701fcc5a798c4b5554dcecf8b3bfc6f5ee21e89cf22d1b8ae27937acd4451a8442c5ba2fdec83da1b65c72dba53793b0976b007ce9ec911c8c5e7c4bbc53a63f461f280c13d91a157c335a18937b2d68731205c0ed9ac2cc75e9249cf10c0056d2ba79d23d923a334a25696146a42c2a73f6f10d28456cab6e518dae0ac8e0bd66beaf662ac3d0d281c1a0cbc4bdcb26051a6fd55477a5b9c183b7a40bb74934e432e21fbee3ea55030de44e52270c2f300e4b308d69cf26f785e8571ef5443f77832e73606165086c0f13831ff3ac2a361a4dd0ce890f74880e3e5064a553f747c05a82fd1be450a0d9e0ca4f3466da2bc9aa65d589ed76d328a3df72a684f1ce64e4634d8fec356fe5b0c63d682b701343a6d3cb9c3216ed560134dbf959f4cf46c0364d104f8166b03e77f1d4900a66ee179256311faafee8df850e9c40eea312e7e4550cab11421b1553d19211f2b2658cd43b30d5a5903ce229e2fffd92d94c503060d3b389506f6a2297b75b1a1e06c3c8e0e9931a38733f9d628703a3209f358fa8bdd1b2443c2390cfd9301e5a9c901010c1e54af2b1f3349f4b8f8ccf8241def824d3db5058f43286875923b7b843eda12e3f35059139ea0f894e1d02f94b10b637fd9890db21e75d41b03b90137e511253c90be81460c629d9dcd1857e993cfa4653536cad1f9a9cd82ead03bd9a72639413a5c789a67fc0c437df428d0f21f9b85c6907e7990c704aebb3fc1cc014d13f3429df53030d154692a79a43dee89d3a985bd29e65767c6959fb3636611a5b652ccecea48ffc18d717510b0cbb3ef27ac26a662c618bc8a08c960b5cbacffc9c4b83353210691ea456d295fb9b371b79c203efa6d922fc9124c7b0a7d944fc02463b9fa4626a4ef2173d1153bde00013f85df7865e4b9922ba94ba5ba4fab5eb90d7b7a12fbe219b330fcf28af592e316c28874274b9ae266600cb67d827e108a4066f964d64f1ec4fb3f34cf6edf66f062161c8518ec2dd3a5482b1b73c020a07a4afba68c1e4805d748211e3fbed5b374026b93bff2fd4663963b89a50892beeb75f15fbd26ab67d3dc5b220cc58d8833a34644bc68f43d07cecea718d76a52d8def8b4a5eed3100f3fb1aa774e66901f7b6bbaa9b4a96a535f9183f65dfe2d2b49e107</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/record/lib/hbe.js"></script><link href="/record/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生命</title>
      <link href="/record/2019/03/04/%E7%94%9F%E5%91%BD/"/>
      <url>/record/2019/03/04/%E7%94%9F%E5%91%BD/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="28c00d329cf0f9cff4d175da712159eeca8560c23d625e74940e50ba71a21468">73ec4e90604b298de70b40cddedb7a1361b462f307d9ce1a3289179ffa3c1997f4bfda2301db86772c45003b4cdb6865140952db335a0100542a3bf0a165f54aaece6088a32edae6e12dae5ae9d23be86d86b7a53cf26fd0596f248b3e5ff21c68f59f4061de28e5a07f062629bd0a027b563b9bec7912ea9f05f1f3cea0f9a647d7f156ab744f3830535d34e974cf0d43471fd4b139c55d6a84b4f016dea04f425dd0adf094ac3004eac2668ad4279cdd6e34094c6d0bdeff32e930ce4861a4b7d3a448f89df1812ebe3c36261bd7e79bb44b1613ed1319aa30c24ab14bc6803e8afb5ab957aa6e6c51d48c6d056e8e8ab5246556ab44e7eafc772338d285176c4f287b9b5aa252c1faa8f850f1bbe740a80a613649d4f96dd9202be3bff2dc1b22bb845f53e3d70896270632971f46496caa1150ac8280abe450023b0fb0325079c0ee38cf334f96e5e0d870faad18a70873e8d10a2ade87285c78755bde36bcf2a8c22d9dd531f64dc2792deb9588ae9e1d463126c10545ecedc5de741be5e2966ac9a0ee9de15379bb55fc97efa7a3053839fb9c2c36464d65c705ff723fc6460004bea0df2d8ee38b9928b333eceebdabcfe330cfd8a1f92ecf77422e3ccf230a7ce9e54e8636c7ad49cd08e181ce9ef5977a887cff77ca9bcc4e9088970218f0bec6c5e5051c628e6ca691d35c63d53df172a91692233ab2b953eec1777da6c633392afcd4c990737e14cbe40829bc94af47bbc527260013f7aa187eb9008152e42c8fb93a6b44898f52ae999250ea13ac22dd7cb552e003101dc13cf407763b6db5c4b49e9231d55a0e0f798c8ab0f9270c6a43269507100270b008079b162de2baa36236e441157b0e9fe80328d162239bcc1f8abd03bd68ff0cfdf8c782994aeb0a6482747c469f9ec048f373d8172b78b232b59012fb2e048baf4dfc98328b36f086f723cedee9918930de3ec0df5c2f42eb480add5b64337bd17d3a1ee5c8625afc8d203ebac35f16667beb964a890bf149aded2716237a96915d66a35493f9af42be80462d568e314a783c71b8533babdb4f444f444dd803741a1db4cd01693992314376c8db52ff240a265858e1e469dd67d255e5c63ea25bbe25c8d42d625c929f76006ba8f698e7674bdbb757545f960b2455bb36f8d78331a34f8108a7e6e460f73d2ccc0c7a9529b51aec49f90926c6cd33d214c44f1c755655efbc5066ab7f383c9401fed6a44d6467fe3f06f7ebb291191ce099830b2fa6a4bdeb549915ddc8b58350daf599b3abd69f70bb5712f552fcc2849acbb9a7390396d53dbe9a3519253f7c9bdca27cca8389b0d79ce3c615e095a8b772e4575e4bfa2478b0dab268c02603462104c96c22f126aa79ab43a4a07af2b2ab980cfde5403c49ea8f2b6bc9d0770342289a8c7ed9e2998da5ac8f794410177f1a94ceb93e976bbfae46a1a2b8949f6662fae196a19351892c72942d6e49013c18a99d64ce5414b5ee55beeff0ee16acf7064ec1a19f33341ffe996edafc5fbb1aa15c555bfba0240ab21caced4788b5e9cbd68e1a9f458adb55d25eb4391feb95f208caf9e5451ba5ed52572067eec8cc02799dcfa412281034d8cb55b35354654543db26681173db895fdad6016ea284609bec7321e2fae0ffb692f8d93249b55552174db770e6ddaa819df405d4a7005cdcb17b91fbf53431c65a9e507443b0e4ccac145e81d4d005a8010d8bf49198c612bcf7c2e6c90d95ca6f57139c634a4c1b6810bd4f3cd134fedacdd06e6512094daf5762190be9785b1ef78910d89f164c0c735a0171d8bc862edb751055b8fe2fad85f600d97e145e7294f7c7bd1d2317b399e8f4e65c3245a8dc2befc43ea3ef16a640734cfa41af882e895ffc3e6ceb29340334e6bf6e8949b40972261d86b34ab99f0d7e104365947bac78b0f68c8d29f1dce83a8ff73a61c28b6fe09fda629c684877175a719c2e0f98db4bcfe895e1e7dd6b97acfb9cacf892bf9d08a7fd5a813bd72b5476cd1e51d72a1c408b595f186b5b86586e126eeb3b1c8e773cab0458cdc5278047a2bb6a76374508a9043a9f0e509f3203e4867cad9c757d402cac2d7755d67a2ba503f0b1b6a33fe4a03f74a8fa69932cc99316f4d207386c3acee9eb25bf678a247fef8748c27bb4c45eef7140c0a19caac8a809f0ac87866b7e0c3e770acf079267f811ebf815df5bc35772a9ae19affd7daef2d3e0c95f70af6a4e9ed227f4ee7794a1eaacf6ea63d8e6fa3d72cd249d803a6fa1be4fbdc550fe6031fde4183f1b7dccac4bb7779eea43f86cc099ee457e70352c17d2afd467c2d692a16f85b7282905552839f03bba5a6f749d2df3c15f15190bff093deedcac2dcfdf7a004fc58e3c122848a0402b2956f92991764d681af041f2f171ff7c8204a0057fe3d8ee0112cb0b7bd366d3f36d39cadda9bfb782baa1a107fab79256f5c21d924e461e40f3ecfb493385566cc110391b9a8d3dc354e72022960114718cbd7ed7ff5b6110b7aa4dbd2f785e315fea4480bf7c54388d40f6401d75993cf1d0b8aded2985400dffd24579755dfe7d654cf3d25a03ebbf4ee684eb884899265ba6d1de2ffc075e78ecc9f660834ca4b203ddabe57b22cebf741ca129f6592835de2d87b53ff2aa025fa58dd9b0df616efbea5ba020a7417a11ff06e8ae2cbf25010138bb0df594b94079557c2745b7c427bb5918cbf108d4ecf34cefea8d982e875ba3bce55042bc9dfa956398db7734816c605248f23b40bae40e7817d7e6d9dd929ab9f89414a19cfeda8cfbaf4c9ee3a54be9fb90577518f03e94c2b6303f14cc8d3298ccc18edb510a04a71f69cd838f4c895c3cc98500abe1fb643136f43fca94c3778fb2d0dc51b697bd7de88b825e139712dab3f4ea8268e1f40c474bb6caabe9c55cf175ae75018d15e470156007c0f29b9e1cb0c9a600084a9cd14c3257417b284b4f63e32e44a0a95ecbd2bd955ce461c2b57868659d5d9b7b6e984f814f5cbe792bcf15fd3d543ff8ecd060e126c95c949ff0fc50dd70904e02cd6d91f7d9a61e382ff3ac8456673a816b6f7848c60316b217c6178cf8e77c9d1c6c0b30b3ecf60aaccbad55781393987fc041c2cfd14884f03a42220ac325e6a30861125ad32b429b29fbefc6f02274e5b83e15be3c39c7eb5fc61f889f22ebe344e18ba0898c7f4934573d4c9c8acffef82977726227e6597f3a444ab5171579ee66f94489bc6e0e1bf5645a7e3b69c15407db406396a601c23bc165549811a0e297519ff1545ce9edbafcc0c70e231786c3a8e24ddd690f4185dd6c02baa538134540eff804630a36d1e5f14dc5d4db6833a2b1eef3e50d0df74b70d9bf7789d4e323a804a95c071395e3d288c98e15586749a90afb9761431bb3dec605c5e8ad3fc073b1cbb3d7c5ee99966617abc7595ba191ed5ef48283e553a08163d8d4cbe0cc5c83799affb1a253d1d12e8b1bc7ed1a357d5ac08c905b57d79e43e8d6f3daca244773ee3baa142a8ebd124255155d0d603dd742bf3063a5efff9da0571da0bf9a54d27b39ce0f6af6ccce6f2649cbe90a3b84f8260f7ede841da2b9378405f2be258b2dcf8bcf9b2a275b963253b3c113c2451b380bba15f3bd6f0a45dc6aa521f3919bfe7e68f9423ad21a1b818c4bbe1d12d5075975de0efec9dbf20b6d52b68f707294e1171c990faf1fe7f72efb4313807080ec98fcccbd38eb2894e0b57b060918a075cfb24a0a1c94b743018fc272be2c178e2af2a89778201fcb57c226a2156bc965994386cfcf26887819a271d4b18aed7b83ed5f6227f8fb7ac41abe4d8dc037c082de9606c30901a818b6ceea09044924117fb87751072e95b9cb44e6012fe13d54c0d44e848b534e5b886bf9fa82cb48f48e2233a5aea1ca8cc12133c8946087f96df31ae5650b295e0362de81725500247633645cf2df2af42090e819128a7a12fe06a1f64a354966e876e73dfb71a33adaca13d97a7e974a0c14607d01b6066aa57ba3c611bad1e8af2733a2ceb11fd33c6fbae81172132dfaee0a98704980d406fd025430e5b22039e4948d9ce033b68e2bd0393c4db94933264ac9b6c9cf534b968e7b2160627b3947657a83d715a1a3f23316c755a8fc957415e7bc8998312bb4a7819b379cbf29342592756ac90d9b430aadd566e220ad4f1b1630515f8809098e83e741eea754dc5a6f776ca7d96d5dd502004dfd3996886fd89ef259b3ff1dbf9afa155d40cd4094c42a4fe334dbcdd7132e7c03d48cff3df152acea6287d895f4b2f7d1ce41faaefe16c6774ab881eaf41b93777edc90eb57099a85698f7e7f66984335a699ca7e9a73778b6d94e038688c7f5b91fcb02545d2cc4da7e680d277386fc41c4a95da878253fdcb6a5aef390920414a37408efb669ce6e0c86cb13c911ec8ff323294e2efb29e171dfaf9e7a90c03f79bbc09568169a79426482d6969c8e3185e1ddaf599edfc72b97bfe7228ccd7fa5edb02011e6db273a421bc871e8741a5286920c04b1a3c212a5cf3324333c5a99fef875a6d7334f1a7e6543a5a548ccd3bed9bd2ff8774c8622ab56ed435867be8ac717a673308c8bd8f7dbcce7065cf5b61c6b50f398ed4582446043179837d444193168a301b5d5dc6edb19c2556ff14379bf6d4d72a15f0349afe5ce7cfa4adfd7c54c4d7fd978c2e47245756b6f5ed7b1b2624579834e23b66650c75de9edce3b539582d51f157862acca01270bedb1218b6e0d6cfc1b4763766eaeb91b5f8f018b59de60f18a68cc07798d9ab009940417e69d68bfdf08fb693173e9f524d68f18957e5eb31cb55421d53088b7f127ff40dbc1bc73597cad52bd075c3c615dbdf8a4893852138e59a8ac191c6ae4baaefca5f2c7e0e7928ca9d58fa3c31063e24abe927997c9c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/record/lib/hbe.js"></script><link href="/record/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>妹妹</title>
      <link href="/record/2018/09/24/%E5%A6%B9%E5%A6%B9/"/>
      <url>/record/2018/09/24/%E5%A6%B9%E5%A6%B9/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e561a7601decb7cc10a862bc8233e4acef8c77423b95135a56efc62f8a20384c">73ec4e90604b298de70b40cddedb7a1361b462f307d9ce1a3289179ffa3c19975f713dcf86804018fe356ce723d18369f0c244396ef1d41792e74b7dfab40c66dfc711d3878f92016c04338150ebb60040574dd50c29183b562c6b646c996ebb9b5657a6a2e82b374aedcbd781335780aad0e110e6b0e88ddc991798dbec02e575b2ff42ae6181c2bf8c8ac89a8a7ec69371189434e585b566b3369b7d5ad8ef1e5c2a5fce546685a45e31622c82badcbb8572c4f845f9266a827173de5bbe52411502d72d4dc8fea7029e0ba9d608648ad3ab8ee4ec5ff7515322aba9ed46ea0062a81d1cd9dcb09fce12a3214145531f32b523f9f015168e6e68815dd175dc99cec87d7d07c8a1acd4d7b57f8a0b0f4d6fb64cbf5cb24981d5eeee5c9329f7ccd17b70061b08fcffbc5e06da6a921124a0b303dce8a939a6c999e95bf8230fdd8a1395cc1a86ab530157e540fdbfb37b3b1b67b9780ab2d14cfeddfa78fb5561f1b7b539216b514e59575555d9a7fb8aa7e5d62460ceab5cfbd519b38f331750e00379e41087fcde6f152db5ba94d5298800f53cb24ea2d3626304ea205510088ac36b37d602d9a2de33dd28499bb63746b2086342452a4207cf5a91c138140a102e78374cec40a9b580295f1145c4e3272a583b8dbacc18e6b5cfc3f70ee14d6a4ad7d9ad5c5ca138d5585cfde06840ee6c17bf6735397a7ed59b7017012c5bcf557545ead381d9f0b280e59b3c52b3e10fcff2364ce2619f036a94adf6f565375852cbb8cfa34a0bcf2bc79b2ee61fc0e15eb5885667cabfe024c9f3dce6e26a20b01386a2f73d9dfa90cc0580baa8129dae9b6d9f40a961ca2ccc4c146f9c825a5e1982bd4d299332ef3863715d3de8530886bb71ae592bb10dcc9076cd263f732a7b704a853e74dc704a37e8e765e3877a475e8be34668d2fe6e14a2ba6c8c884ceff6c6cf19dacf21ddb0d919c3e4b7f9042bf44fff3d0fe2a3989597fe29fe0cbf6ce35ac9099c6858208b545f91d0d9070aa16362e61faefd2b2388f07904ab8fff5d71d6d75d031dee6827fd278e0d92b6ae2ce11e7a44a304172f3d84e9c58ccc7d57657bfacd796f62d3be599dcab4144028b6ab8c481f30510c594ed6256e0f4630941ab6a518cd381f2502f931f279f0f4ebfee592cf703edd8ec4bb3064b44c66b1e831d1e54340bb9052640739df13fcb37167a4329e0c8179291022ac026610a9e341e20e0b60eee1774869f74e7f764440fa530cb77726798c59825a1b3c947c2f4ed14b549b35fb81510965f5494b255952931de980c025f6a4aa049338a4d30cc0e7ef4575bc9eb495c9ffd4ac5ed6dd84bfd49d21c95cafcae8b10de73b62ec97275776ee7f11ab4d516537ac927edf0badd29792ab6e5535ed083ddbc9c5da2d00b4ed602b58d3d2a5944ad9184c7288213dc5ebbeca66f9ed9a554ba89fc020e4c67627d85ddc00c5e528bff976f9891e38d796e60af0a5c58627d90eaa6a0b26d97040632c87eb61928cb6d5d742b9bd335e4ffeb87f500338d59d0d64b2a8a4131b5e78eedbf6f236b6714ff31e9f7adf047c28a0792c0db01ca2d3da301bb90fdb40709b39618e4bdb471e64ca6f1445a0c27758733591ec4453acfa0d8d5e896f531854bb840009c55b8760da6214550f617ecd64fb1f03f7ad16cbc095ff7462b7eaa0879be505907d60c36f5111372543f5df2ce8b3aecb12d7345d3bfc738d732e34dce183268afb709c28bb7f3c01350808a9e44ebbd25350337cb3f4d057739c4fc2514705f2f9807be9536ebdd4fc8eda6d14291bee4a2820a7153109b1260adb524ae3328d73527d7ea15ae2aa3de470470c5455dfc158651afa288d3956896195827451e77822365861a19f1f1a9a5066ceb65e1e8537def51397cea8940fbf4b80cada9a3943e2bee69aa478024c13336270dc35a8195c15f4d2b75684e5333e553e2cda57ef125b93ba790f1d1c035bc2c78a27e04fbd9cfdac88261f858634d2fada257057c2019ab948e161c58ae78b6dbf5c33afd696f497a3d4862ee035210278466840858c8ea11893044d3be5b63e37d435228d91df1e474711f1bf1367c82f13c901b9ca99508d13c2017945adfdb9595fb3f95237cc033e300496b13490a047d792f4b461c68e96d6647e6f74bffc30376a30ced3f7988682bfe6d10c95b6c4d6bd97b0b34be1b775c22859dd7aa6919bb5ccb08373bd3513af42710e6db86b2b757131386e71c49c258b2ee1637b76d1dc5db35bc1b6297ce04c0ee98717a81e82b143a1a2a27c80dfe72f683267af3aa1388379c04b678351c25b4f2fdd3c655a3fba6b1c309bbb12f6ba877507223c7357e85b0140943a5b37d837892339c23ee566fb43326dd880</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/record/lib/hbe.js"></script><link href="/record/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
