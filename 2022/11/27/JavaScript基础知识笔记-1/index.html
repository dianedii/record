<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="0.前言本文基于ES5版本的JavaScript教程，阅读时整理的基于知识点结构的笔记。仅梳理了本人以往不清晰或者与其他编程语言有差异之处或该语言特点。作为一文流笔记以备之后检索使用。 1.lableJavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。 12label:  语句  标签可以是任意的标识符，但不能是保留字，语句部分可">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript基础知识笔记">
<meta property="og:url" content="https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/index.html">
<meta property="og:site_name" content="dianedii&#96;blog">
<meta property="og:description" content="0.前言本文基于ES5版本的JavaScript教程，阅读时整理的基于知识点结构的笔记。仅梳理了本人以往不清晰或者与其他编程语言有差异之处或该语言特点。作为一文流笔记以备之后检索使用。 1.lableJavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。 12label:  语句  标签可以是任意的标识符，但不能是保留字，语句部分可">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-27T08:56:28.000Z">
<meta property="article:modified_time" content="2022-11-27T09:17:01.607Z">
<meta property="article:author" content="戴安">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/record/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/record/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/record/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>JavaScript基础知识笔记</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/record/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/record/">Home</a></li><!--
     --><!--
       --><li><a href="/record/about/">About</a></li><!--
     --><!--
       --><li><a href="/record/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/record/categories/">categories</a></li><!--
     --><!--
       --><li><a href="/record/tags/">Tag</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/record/2022/11/17/ssn0010/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&text=JavaScript基础知识笔记"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&title=JavaScript基础知识笔记"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&is_video=false&description=JavaScript基础知识笔记"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=JavaScript基础知识笔记&body=Check out this article: https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&title=JavaScript基础知识笔记"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&title=JavaScript基础知识笔记"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&title=JavaScript基础知识笔记"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&title=JavaScript基础知识笔记"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&name=JavaScript基础知识笔记&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&t=JavaScript基础知识笔记"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">0.前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-lable"><span class="toc-number">2.</span> <span class="toc-text">1.lable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%83%E5%B0%94%E5%80%BC"><span class="toc-number">3.</span> <span class="toc-text">2.布尔值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E5%80%BC"><span class="toc-number">4.</span> <span class="toc-text">3.数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">4. 字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">5.对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">6.0.1.</span> <span class="toc-text">对象属性的操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#in%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.0.2.</span> <span class="toc-text">in运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">6.函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#javaScript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">7.0.1.</span> <span class="toc-text">javaScript中的闭包的理解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%95%B0%E7%BB%84"><span class="toc-number">8.</span> <span class="toc-text">7.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E4%BC%BC%E6%95%B0%E7%BB%84%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.0.1.</span> <span class="toc-text">类似数组的对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.</span> <span class="toc-text">8.运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E9%94%99%E8%AF%AF%E6%9C%BA%E5%88%B6%E5%A4%84%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">9.错误机制处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-js%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E5%BB%BA%E8%AE%AE"><span class="toc-number">11.</span> <span class="toc-text">10. js编程风格建议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-console%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.</span> <span class="toc-text">11. console对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">12.0.1.</span> <span class="toc-text">控制台常见命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Js%E5%AF%B9%E8%B1%A1%E8%AE%A4%E8%AF%86"><span class="toc-number">12.0.2.</span> <span class="toc-text">Js对象认识</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Object%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.</span> <span class="toc-text">12.Object对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#proto-%E8%AF%B4%E6%98%8E"><span class="toc-number">13.0.1.</span> <span class="toc-text">__proto__说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Object-%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">13.0.2.</span> <span class="toc-text">Object 的实例方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">13.0.3.</span> <span class="toc-text">对象的拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Array%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.</span> <span class="toc-text">13.Array对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1"><span class="toc-number">15.</span> <span class="toc-text">14.包装对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Boolean-%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">16.</span> <span class="toc-text">15.Boolean 值得注意的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Number%E5%AF%B9%E8%B1%A1%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">17.</span> <span class="toc-text">16.Number对象值得注意的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-String%E5%AF%B9%E8%B1%A1%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">18.</span> <span class="toc-text">17.String对象值得注意的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-Math%E5%AF%B9%E8%B1%A1%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">19.</span> <span class="toc-text">18.Math对象值得注意的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Date%E5%AF%B9%E8%B1%A1%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">20.</span> <span class="toc-text">19.Date对象值得注意的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-JSON%E5%AF%B9%E8%B1%A1"><span class="toc-number">21.</span> <span class="toc-text">20.JSON对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">22.</span> <span class="toc-text">21.面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">22.0.1.</span> <span class="toc-text">严格模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-JavaScript%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">23.</span> <span class="toc-text">22.JavaScript的异步操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%9A%84%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">23.0.1.</span> <span class="toc-text">异步的操作模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">23.0.2.</span> <span class="toc-text">多个异步的流程控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">24.</span> <span class="toc-text">23.定时器相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91"><span class="toc-number">24.0.1.</span> <span class="toc-text">定时器的实现逻辑</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E9%98%B2%E6%8A%96%E5%A4%84%E7%90%86-debounce"><span class="toc-number">24.0.2.</span> <span class="toc-text">页面防抖处理 debounce</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-Promise%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">25.</span> <span class="toc-text">24.Promise对象（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">25.0.1.</span> <span class="toc-text">Promise对象的状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">25.0.2.</span> <span class="toc-text">构造函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-number">26.</span> <span class="toc-text">25.鼠标事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-number">27.</span> <span class="toc-text">26.键盘事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E8%BF%9B%E5%BA%A6%E4%BA%8B%E4%BB%B6"><span class="toc-number">28.</span> <span class="toc-text">27.进度事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6"><span class="toc-number">29.</span> <span class="toc-text">28.表单事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6"><span class="toc-number">30.</span> <span class="toc-text">29.触摸事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E6%8B%96%E6%8B%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">31.</span> <span class="toc-text">30.拖拉事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%8B%96%E6%8B%89%E4%BA%8B%E4%BB%B6%EF%BC%8C%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9%E3%80%82"><span class="toc-number">31.0.1.</span> <span class="toc-text">关于拖拉事件，有以下几个注意点。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E8%B5%84%E6%BA%90%E4%BA%8B%E4%BB%B6"><span class="toc-number">32.</span> <span class="toc-text">31.资源事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-session%E5%8E%86%E5%8F%B2%E4%BA%8B%E4%BB%B6"><span class="toc-number">33.</span> <span class="toc-text">32.session历史事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E7%BD%91%E9%A1%B5%E7%8A%B6%E6%80%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">34.</span> <span class="toc-text">33.网页状态事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E7%AA%97%E5%8F%A3%E4%BA%8B%E4%BB%B6"><span class="toc-number">35.</span> <span class="toc-text">34.窗口事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E5%89%AA%E5%88%87%E6%9D%BF%E4%BA%8B%E4%BB%B6"><span class="toc-number">36.</span> <span class="toc-text">35.剪切板事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6-FocusEvent"><span class="toc-number">37.</span> <span class="toc-text">36.焦点事件 FocusEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-CustomEvent-%E6%8E%A5%E5%8F%A3"><span class="toc-number">38.</span> <span class="toc-text">37.CustomEvent 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-script-%E5%85%83%E7%B4%A0"><span class="toc-number">39.</span> <span class="toc-text">38.script 元素</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        JavaScript基础知识笔记
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">戴安</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-11-27T08:56:28.000Z" itemprop="datePublished">2022-11-27</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/record/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h3><p>本文基于<code>ES5</code>版本的<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/"><code>JavaScript</code>教程</a>，阅读时整理的基于知识点结构的笔记。仅梳理了本人以往不清晰或者与其他编程语言有差异之处或该语言特点。作为一文流笔记以备之后检索使用。</p>
<h3 id="1-lable"><a href="#1-lable" class="headerlink" title="1.lable"></a>1.<code>lable</code></h3><p><code>JavaScript</code> 语言允许，语句的前面有标签<code>（label）</code>，相当于定位符，用于跳转到程序的任意位置，标签的格式如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">  语句</span><br></pre></td></tr></table></figure>

<p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。</p>
<p>标签通常与<code>break</code>语句和<code>continue</code>语句配合使用，跳出特定的循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">break</span> top;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;i=&#x27;</span> + i + <span class="string">&#x27;, j=&#x27;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// i=0, j=0</span></span><br><span class="line"><span class="comment">// i=0, j=1</span></span><br><span class="line"><span class="comment">// i=0, j=2</span></span><br><span class="line"><span class="comment">// i=1, j=0</span></span><br></pre></td></tr></table></figure>

<p>上面代码为一个双重循环区块，<code>break</code>命令后面加上了<code>top</code>标签（注意，<code>top</code>不用加引号），满足条件时，直接跳出双层循环。如果<code>break</code>语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。</p>
<p>标签也可以用于跳出代码块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo: &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">break</span> foo;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;本行不会输出&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码执行到<code>break foo</code>，就会跳出区块。</p>
<p><code>continue</code>语句也可以与标签配合使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">continue</span> top;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;i=&#x27;</span> + i + <span class="string">&#x27;, j=&#x27;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// i=0, j=0</span></span><br><span class="line"><span class="comment">// i=0, j=1</span></span><br><span class="line"><span class="comment">// i=0, j=2</span></span><br><span class="line"><span class="comment">// i=1, j=0</span></span><br><span class="line"><span class="comment">// i=2, j=0</span></span><br><span class="line"><span class="comment">// i=2, j=1</span></span><br><span class="line"><span class="comment">// i=2, j=2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>continue</code>命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果<code>continue</code>语句后面不使用标签，则只能进入下一轮的内层循环。</p>
<hr>
<h3 id="2-布尔值"><a href="#2-布尔值" class="headerlink" title="2.布尔值"></a>2.布尔值</h3><p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code>。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>0</code></li>
<li><code>NaN</code></li>
<li><code>&quot;&quot;</code>或<code>&#39;&#39;</code>（空字符串）</li>
</ul>
<p>注意：空数组（<code>[]</code>）和空对象（<code>&#123;&#125;</code>）对应的布尔值，都是<code>true</code>。</p>
<hr>
<h3 id="3-数值"><a href="#3-数值" class="headerlink" title="3.数值"></a>3.数值</h3><ul>
<li><p>不要拿在<code>js</code>中直接做小数的数值运算</p>
</li>
<li><p><code>js</code>可以使用科学计数法表示数值，但不要用<code>parseInt()</code>去转化科学计数法表示的值，用<code>praseFloat()</code>。</p>
</li>
<li><p>其他进制表示：（八进制前缀不要只加<code>0</code>）</p>
<ul>
<li>八进制：有前缀<code>0o</code>或<code>0O</code>的数值，<del>或者有前导0</del>、且只用到<code>0-7</code>的八个阿拉伯数字的数值。</li>
<li>十六进制：有前缀<code>0x</code>或<code>0X</code>的数值。</li>
<li>二进制：有前缀<code>0b</code>或<code>0B</code>的数值。</li>
</ul>
</li>
<li><p>了解几个特殊值：（尤其是涉及特殊值的运算，结果要注意）</p>
<ul>
<li><code>NaN</code></li>
<li><code>+0 /-0</code></li>
<li><code>Infinity</code></li>
</ul>
</li>
<li><p>常见方法</p>
<p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">null</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="number">1</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>。</p>
</li>
</ul>
<hr>
<h3 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h3><ul>
<li><p>字符串可以被视为字符数组，但通过这种方式：字符串内部的单个字符无法改变和增删，这些操作会默默地失败</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">s[<span class="number">0</span>] <span class="comment">// &quot;h&quot;</span></span><br><span class="line">s[<span class="number">1</span>] <span class="comment">// &quot;e&quot;</span></span><br><span class="line">s[<span class="number">4</span>] <span class="comment">// &quot;o&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接对字符串使用方括号运算符</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>[<span class="number">1</span>] <span class="comment">// &quot;e&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> s[<span class="number">0</span>];</span><br><span class="line">s <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">s <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>JavaScript</code> 原生提供两个 Base64 相关的方法。注意这两个方法不适合非 <code>ASCII</code> 码的字符，会报错</p>
<ul>
<li><code>btoa()</code>：任意值转为 Base64 编码</li>
<li><code>atob()</code>：Base64 编码转为原来的值</li>
</ul>
<p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Encode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> btoa(<span class="built_in">encodeURIComponent</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Decode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(atob(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b64Encode(<span class="string">&#x27;你好&#x27;</span>) <span class="comment">// &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;</span></span><br><span class="line">b64Decode(<span class="string">&#x27;JUU0JUJEJUEwJUU1JUE1JUJE&#x27;</span>) <span class="comment">// &quot;你好&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="5-对象"><a href="#5-对象" class="headerlink" title="5.对象"></a>5.对象</h3><ul>
<li>对象的引用</li>
</ul>
<p>​        如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"></span><br><span class="line">o1.a = <span class="number">1</span>;</span><br><span class="line">o2.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">o2.b = <span class="number">2</span>;</span><br><span class="line">o1.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>​        上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。</p>
<p>​        此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"></span><br><span class="line">o1 = <span class="number">1</span>;</span><br><span class="line">o2 <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>​        上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，然后<code>o1</code>的值变为1，这时不会对<code>o2</code>产生影响，<code>o2</code>还是指向原来的那个对象。</p>
<hr>
<h5 id="对象属性的操作"><a href="#对象属性的操作" class="headerlink" title="对象属性的操作"></a>对象属性的操作</h5><ul>
<li>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">key1</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">key2</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="comment">// [&#x27;key1&#x27;, &#x27;key2&#x27;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// [&quot;p&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br><span class="line">obj.p <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>​        上面代码中，<code>delete</code>命令删除对象<code>obj</code>的<code>p</code>属性。删除后，再读取<code>p</code>属性就会返回<code>undefined</code>，而且<code>Object.keys</code>方法的返回值也不再包括该属性。</p>
<p>​        注意，删除一个不存在的属性，<code>delete</code>不报错，而且返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>​        上面代码中，对象<code>obj</code>并没有<code>p</code>属性，但是<code>delete</code>命令照样返回<code>true</code>。因此，不能根据<code>delete</code>命令的结果，认定某个属性是存在的。</p>
<p>​        只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>​        上面代码之中，对象<code>obj</code>的<code>p</code>属性是不能删除的，所以<code>delete</code>命令返回<code>false</code>。</p>
<p>​        另外，需要注意的是，<code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.toString <span class="comment">// true</span></span><br><span class="line">obj.toString <span class="comment">// function toString() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<p>​        上面代码中，<code>toString</code>是对象<code>obj</code>继承的属性，虽然<code>delete</code>命令返回<code>true</code>，但该属性并没有被删除，依然存在。这个例子还说明，即使<code>delete</code>返回<code>true</code>，该属性依然可能读取到值。</p>
<hr>
<h5 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a><code>in</code>运算符</h5><p><code>in</code>运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回<code>true</code>，否则返回<code>false</code>。它的左边是一个字符串，表示属性名，右边是一个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="string">&#x27;p&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>in</code>运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象<code>obj</code>本身并没有<code>toString</code>属性，但是<code>in</code>运算符会返回<code>true</code>，因为这个属性是继承的。</p>
<p>这时，可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-函数"><a href="#6-函数" class="headerlink" title="6.函数"></a>6.函数</h3><p>函数<code>A.name</code>可以获取函数名，<code>.length</code>可以获取函数参数个数，<code>toString</code>返回函数源码，有点反射内味儿了。</p>
<p>函数内部也能定义函数…</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> f = foo();</span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>foo</code>内部声明了一个函数<code>bar</code>，<code>bar</code>的作用域绑定<code>foo</code>。当我们在<code>foo</code>外部取出<code>bar</code>执行时，变量<code>x</code>指向的是<code>foo</code>内部的<code>x</code>，而不是<code>foo</code>外部的<code>x</code>。正是这种机制，构成了下文要讲解的“闭包”现象。</p>
<hr>
<p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递<code>（passes by value）</code>。这意味着，在函数体内修改参数值，不会影响到函数外部。</p>
<p>但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递<code>（pass by reference）</code>。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。</p>
<p>注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。</p>
<hr>
<h5 id="javaScript中的闭包的理解"><a href="#javaScript中的闭包的理解" class="headerlink" title="javaScript中的闭包的理解"></a>javaScript中的闭包的理解</h5><p>闭包<code>（closure）</code>是 <code>JavaScript</code> 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>
<p>理解闭包，首先必须理解变量作用域。前面提到，<code>JavaScript</code> 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line">f1() <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f1</code>可以读取全局变量<code>n</code>。</p>
<p>但是，正常情况下，函数外部无法读取函数内部声明的变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: n is not defined(</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f1</code>内部声明的变量<code>n</code>，函数外是无法读取的。</p>
<p>如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="built_in">console</span>.log(n); <span class="comment">// 999</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f2</code>就在函数<code>f1</code>内部，这时<code>f1</code>内部的所有局部变量，对<code>f2</code>都是可见的。但是反过来就不行，<code>f2</code>内部的局部变量，对<code>f1</code>就是不可见的。这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然<code>f2</code>可以读取<code>f1</code>的局部变量，那么只要把<code>f2</code>作为返回值，我们不就可以在<code>f1</code>外部读取它的内部变量了吗！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f1</code>的返回值就是函数<code>f2</code>，由于<code>f2</code>可以读取<code>f1</code>的内部变量，所以就可以在外部获得<code>f1</code>的内部变量了。</p>
<p>闭包就是函数<code>f2</code>，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如<code>f2</code>记住了它诞生的环境<code>f1</code>，所以从<code>f2</code>可以得到<code>f1</code>的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p>闭包的最大用处有两个，一个是可以读取外层函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrementor</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> start++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inc = createIncrementor(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">inc() <span class="comment">// 5</span></span><br><span class="line">inc() <span class="comment">// 6</span></span><br><span class="line">inc() <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>start</code>是函数<code>createIncrementor</code>的内部变量。通过闭包，<code>start</code>的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包<code>inc</code>使得函数<code>createIncrementor</code>的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。</p>
<p>为什么闭包能够返回外层函数的内部变量？原因是闭包（上例的<code>inc</code>）用到了外层变量（<code>start</code>），导致外层函数（<code>createIncrementor</code>）不能从内存释放。只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始终保存着当前值，供闭包读取。</p>
<p>闭包的另一个用处，是封装对象的私有属性和私有方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _age;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setAge</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    _age = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: name,</span><br><span class="line">    <span class="attr">getAge</span>: getAge,</span><br><span class="line">    <span class="attr">setAge</span>: setAge</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Person(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">p1.setAge(<span class="number">25</span>);</span><br><span class="line">p1.getAge() <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>Person</code>的内部变量<code>_age</code>，通过闭包<code>getAge</code>和<code>setAge</code>，变成了返回对象<code>p1</code>的私有变量。</p>
<p>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p>
<hr>
<p><code>eval</code>命令接受一个字符串作为参数，并将这个字符串当作语句执行。</p>
<p>总之，<code>eval</code>的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，一般不推荐使用。通常情况下，<code>eval</code>最常见的场合是解析 JSON 数据的字符串，不过正确的做法应该是使用原生的<code>JSON.parse</code>方法。</p>
<hr>
<h3 id="7-数组"><a href="#7-数组" class="headerlink" title="7.数组"></a>7.数组</h3><p><code>length</code>属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到<code>length</code>设置的值。</p>
<p>清空数组的一个有效方法，就是将<code>length</code>属性设为0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line">arr <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>如果人为设置<code>length</code>大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位 undefined。</p>
<p>值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响<code>length</code>属性的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;p&#x27;</span>] = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">a.length <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">2.1</span>] = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">a.length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<hr>
<p>检查某个键名是否存在的运算符<code>in</code>，适用于对象，也适用于数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> arr  <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span> <span class="keyword">in</span> arr <span class="comment">// true</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">in</span> arr <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，数组存在键名为<code>2</code>的键。由于键名都是字符串，所以数值<code>2</code>会自动转成字符串。</p>
<hr>
<p><code>for...in</code>不仅会遍历数组所有的数字键，还会遍历非数字键。</p>
<p>所以，不推荐使用<code>for...in</code>遍历数组。</p>
<p>数组的遍历可以考虑使用普通<code>for</code>循环或<code>while</code>循环。</p>
<hr>
<p>使用<code>delete</code>命令删除一个数组成员，会形成空位，并且不会影响<code>length</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// undefined</span></span><br><span class="line">a.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码用<code>delete</code>命令删除了数组的第二个元素，这个位置就形成了空位，但是对<code>length</code>属性没有影响。也就是说，<code>length</code>属性不过滤空位。所以，使用<code>length</code>属性进行数组遍历，一定要非常小心。</p>
<p>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过。如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过。这就是说，空位就是数组没有这个元素，所以不会被遍历到，而<code>undefined</code>则表示数组有这个元素，值是<code>undefined</code>，所以遍历不会跳过。</p>
<hr>
<h5 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h5><p>如果一个对象的所有键名都是正整数或零，并且有<code>length</code>属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="number">0</span>] <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">obj[<span class="number">1</span>] <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line">obj.length <span class="comment">// 3</span></span><br><span class="line">obj.push(<span class="string">&#x27;d&#x27;</span>) <span class="comment">// TypeError: obj.push is not a function</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象<code>obj</code>没有数组的<code>push</code>方法，使用该方法就会报错。</p>
<p>“类似数组的对象”的根本特征，就是具有<code>length</code>属性。只要有<code>length</code>属性，就可以认为这个对象类似于数组。但是有一个问题，这种<code>length</code>属性不是动态值，不会随着成员的变化而变化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[<span class="number">3</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">obj.length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面代码为对象<code>obj</code>添加了一个数字键，但是<code>length</code>属性没变。这就说明了<code>obj</code>不是数组。</p>
<p>典型的“类似数组的对象”是函数的<code>arguments</code>对象，以及大多数 DOM 元素集，还有字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">args</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">arguments</span> &#125;</span><br><span class="line"><span class="keyword">var</span> arrayLike = args(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">arrayLike[<span class="number">0</span>] <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">arrayLike.length <span class="comment">// 2</span></span><br><span class="line">arrayLike <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM元素集</span></span><br><span class="line"><span class="keyword">var</span> elts = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;h3&#x27;</span>);</span><br><span class="line">elts.length <span class="comment">// 3</span></span><br><span class="line">elts <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="number">1</span>] <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.length <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码包含三个例子，它们都不是数组（<code>instanceof</code>运算符返回<code>false</code>），但是看上去都非常像数组。</p>
<p>数组的<code>slice</code>方法可以将“类似数组的对象”变成真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>

<p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过<code>call()</code>把数组的方法放到对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index + <span class="string">&#x27; : &#x27;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(arrayLike, print);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>arrayLike</code>代表一个类似数组的对象，本来是不可以使用数组的<code>forEach()</code>方法的，但是通过<code>call()</code>，可以把<code>forEach()</code>嫁接到<code>arrayLike</code>上面调用。</p>
<p>下面的例子就是通过这种方法，在<code>arguments</code>对象上面调用<code>forEach</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span> (<span class="params">elem, i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i + <span class="string">&#x27;. &#x27;</span> + elem);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 for 循环</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i + <span class="string">&#x27;. &#x27;</span> + <span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串也是类似数组的对象，所以也可以用<code>Array.prototype.forEach.call</code>遍历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(<span class="string">&#x27;abc&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<p>注意，这种方法比直接使用数组原生的<code>forEach</code>要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的<code>forEach</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">chr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="8-运算符"><a href="#8-运算符" class="headerlink" title="8.运算符"></a>8.运算符</h3><ul>
<li><strong>指数运算符</strong>：<code>x ** y</code></li>
<li><strong>余数运算符</strong>：<code>x % y</code></li>
</ul>
<hr>
<p>JavaScript 提供两种相等运算符：<code>==</code>和<code>===</code>。</p>
<p>简单说，它们的区别是相等运算符（<code>==</code>）比较两个值是否相等，严格相等运算符（<code>===</code>）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（<code>===</code>）直接返回<code>false</code>，而相等运算符（<code>==</code>）会将它们转换成同一个类型，再用严格相等运算符进行比较。</p>
<p><code>undefined</code>和<code>null</code>与自身严格相等。</p>
<hr>
<ul>
<li><strong>二进制或运算符</strong>（or）：符号为<code>|</code>，表示若两个二进制位都为<code>0</code>，则结果为<code>0</code>，否则为<code>1</code>。</li>
<li><strong>二进制与运算符</strong>（and）：符号为<code>&amp;</code>，表示若两个二进制位都为1，则结果为1，否则为0。</li>
<li><strong>二进制否运算符</strong>（not）：符号为<code>~</code>，表示对一个二进制位取反。</li>
<li><strong>异或运算符</strong>（xor）：符号为<code>^</code>，表示若两个二进制位不相同，则结果为1，否则为0。</li>
<li><strong>左移运算符</strong>（left shift）：符号为<code>&lt;&lt;</code>，详见下文解释。</li>
<li><strong>右移运算符</strong>（right shift）：符号为<code>&gt;&gt;</code>，详见下文解释。</li>
<li><strong>头部补零的右移运算符</strong>（zero filled right shift）：符号为<code>&gt;&gt;&gt;</code>，详见下文解释。</li>
</ul>
<hr>
<p><code>void</code>运算符的作用是执行一个表达式，然后不返回任何值，或者说返回<code>undefined</code>。</p>
<p>这个运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转。</p>
<p>请看下面的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;f(); return false;&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>上面代码中，点击链接后，会先执行<code>onclick</code>的代码，由于<code>onclick</code>返回<code>false</code>，所以浏览器不会跳转到 example.com。</p>
<p><code>void</code>运算符可以取代上面的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript: void(f())&quot;</span>&gt;文字&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript: void(document.form.submit())&quot;</span>&gt;</span><br><span class="line">  提交</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p><code>Boolean()</code>函数可以将任意类型的值转为布尔值。</p>
<p>它的转换规则相对简单：除了以下五个值的转换结果为<code>false</code>，其他的值全部为<code>true</code>。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>0</code>（包含<code>-0</code>和<code>+0</code>）</li>
<li><code>NaN</code></li>
<li><code>&#39;&#39;</code>（空字符串）</li>
</ul>
<p>使用<code>Number()</code>函数，可以将任意类型的值转化成数值。 转不了的会变成NaN,同理也有<code>String()</code></p>
<hr>
<h3 id="9-错误机制处理"><a href="#9-错误机制处理" class="headerlink" title="9.错误机制处理"></a>9.错误机制处理</h3><p>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.message = message || <span class="string">&#x27;默认信息&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;UserError&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">UserError.prototype.constructor = UserError;</span><br></pre></td></tr></table></figure>

<p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> UserError(<span class="string">&#x27;这是自定义的错误！&#x27;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p><code>try catch</code>    语句内不管报错还是有<code>return</code>,只要有<code>finally</code>就一定会执行它。</p>
<hr>
<h3 id="10-js编程风格建议"><a href="#10-js编程风格建议" class="headerlink" title="10. js编程风格建议"></a>10. js编程风格建议</h3><p>JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。</p>
<p>因此，建议避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如<code>UPPER_CASE</code>。</p>
<p>建议不要使用相等运算符（<code>==</code>），只使用严格相等运算符（<code>===</code>）。</p>
<p>建议不要将不同目的的语句，合并成一行。</p>
<p>建议自增（<code>++</code>）和自减（<code>--</code>）运算符尽量使用<code>+=</code>和<code>-=</code>代替。</p>
<hr>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAction</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> actions = &#123;</span><br><span class="line">    <span class="string">&#x27;hack&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;hack&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;slash&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;slash&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;run&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;run&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actions[action] !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Invalid action.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> actions[action]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议<code>switch...case</code>结构可以用对象结构代替。</p>
<hr>
<h3 id="11-console对象"><a href="#11-console对象" class="headerlink" title="11. console对象"></a>11. <code>console</code>对象</h3><p>打开开发者工具以后，顶端有多个面板。</p>
<ul>
<li><strong>Elements</strong>：查看网页的 HTML 源码和 CSS 代码。</li>
<li><strong>Resources</strong>：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。</li>
<li><strong>Network</strong>：查看网页的 HTTP 通信情况。</li>
<li><strong>Sources</strong>：查看网页加载的脚本源码。</li>
<li><strong>Timeline</strong>：查看各种网页行为随时间变化的情况。</li>
<li><strong>Performance</strong>：查看网页的性能情况，比如 CPU 和内存消耗。</li>
<li><strong>Console</strong>：用来运行 JavaScript 命令。</li>
</ul>
<hr>
<p><code>console.log</code>方法支持以下占位符，不同类型的数据必须使用对应的占位符。</p>
<ul>
<li><code>%s</code> 字符串</li>
<li><code>%d</code> 整数</li>
<li><code>%i</code> 整数</li>
<li><code>%f</code> 浮点数</li>
<li><code>%o</code> 对象的链接</li>
<li><code>%c</code> CSS 格式字符串</li>
</ul>
<p>使用<code>%c</code>占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="string">&#x27;%cThis text is styled!&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;color: red; background: yellow; font-size: 24px;&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<p>对于某些复合类型的数据，<code>console.table</code>方法可以将其转为表格显示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;JavaScript&quot;</span>, <span class="attr">fileExtension</span>: <span class="string">&quot;.js&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;TypeScript&quot;</span>, <span class="attr">fileExtension</span>: <span class="string">&quot;.ts&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;CoffeeScript&quot;</span>, <span class="attr">fileExtension</span>: <span class="string">&quot;.coffee&quot;</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table(languages);</span><br></pre></td></tr></table></figure>

<hr>
<p><code>console.count</code>方法用于计数，输出它被调用了多少次。</p>
<p>该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.count(user);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hi &quot;</span> + user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line"><span class="comment">// bob: 1</span></span><br><span class="line"><span class="comment">// &quot;hi bob&quot;</span></span><br><span class="line"></span><br><span class="line">greet(<span class="string">&#x27;alice&#x27;</span>)</span><br><span class="line"><span class="comment">// alice: 1</span></span><br><span class="line"><span class="comment">// &quot;hi alice&quot;</span></span><br><span class="line"></span><br><span class="line">greet(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line"><span class="comment">// bob: 2</span></span><br><span class="line"><span class="comment">// &quot;hi bob&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码根据参数的不同，显示<code>bob</code>执行了两次，<code>alice</code>执行了一次。</p>
<hr>
<p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</p>
<p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为<code>false</code>，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.assert(list.childNodes.length &lt; <span class="number">500</span>, <span class="string">&#x27;节点个数大于等于500&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。</p>
<hr>
<p><code>console.time()  console.timeEnd()</code>这两个方法用于计时，可以算出一个操作所花费的准确时间。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;Array initialize&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array= <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  array[i] = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;Array initialize&#x27;</span>);</span><br><span class="line"><span class="comment">// Array initialize: 1914.481ms</span></span><br></pre></td></tr></table></figure>

<p><code>time</code>方法表示计时开始，<code>timeEnd</code>方法表示计时结束。它们的参数是计时器的名称。调用<code>timeEnd</code>方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p>
<hr>
<p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.trace()</span><br><span class="line"><span class="comment">// console.trace()</span></span><br><span class="line"><span class="comment">//   (anonymous function)</span></span><br><span class="line"><span class="comment">//   InjectedScript._evaluateOn</span></span><br><span class="line"><span class="comment">//   InjectedScript._evaluateAndWrap</span></span><br><span class="line"><span class="comment">//   InjectedScript.evaluate</span></span><br></pre></td></tr></table></figure>

<p><code>console.clear</code>方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，<code>console.clear</code>方法将不起作用。</p>
<hr>
<h5 id="控制台常见命令"><a href="#控制台常见命令" class="headerlink" title="控制台常见命令"></a>控制台常见命令</h5><p>浏览器控制台中，除了使用<code>console</code>对象，还可以使用一些控制台自带的命令行方法。</p>
<p>（1）<code>$_</code></p>
<p><code>$_</code>属性返回上一个表达式的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">$_</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>（2）<code>$0</code> - <code>$4</code></p>
<p>控制台保存了最近5个在 Elements 面板选中的 DOM 元素，<code>$0</code>代表倒数第一个（最近一个），<code>$1</code>代表倒数第二个，以此类推直到<code>$4</code>。</p>
<p>（3）<code>$(selector)</code></p>
<p><code>$(selector)</code>返回第一个匹配的元素，等同于<code>document.querySelector()</code>。注意，如果页面脚本对<code>$</code>有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行<code>$(selector)</code>就会采用 jQuery 的实现，返回一个数组。</p>
<p>（4）<code>$$(selector)</code></p>
<p><code>$$(selector)</code>返回选中的 DOM 对象，等同于<code>document.querySelectorAll</code>。</p>
<p>（5）<code>$x(path)</code></p>
<p><code>$x(path)</code>方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$x(<span class="string">&quot;//p[a]&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码返回所有包含<code>a</code>元素的<code>p</code>元素。</p>
<p>（6）<code>inspect(object)</code></p>
<p><code>inspect(object)</code>方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在<code>Elements</code>面板中显示，比如<code>inspect(document)</code>会在 Elements 面板显示<code>document</code>元素。JavaScript 对象在控制台面板<code>Profiles</code>面板中显示，比如<code>inspect(window)</code>。</p>
<p>（7）<code>getEventListeners(object)</code></p>
<p><code>getEventListeners(object)</code>方法返回一个对象，该对象的成员为<code>object</code>登记了回调函数的各种事件（比如<code>click</code>或<code>keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数。</p>
<p>（8）<code>keys(object)</code>，<code>values(object)</code></p>
<p><code>keys(object)</code>方法返回一个数组，包含<code>object</code>的所有键名。</p>
<p><code>values(object)</code>方法返回一个数组，包含<code>object</code>的所有键值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="string">&#x27;p1&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;p2&#x27;</span>: <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">keys(o)</span><br><span class="line"><span class="comment">// [&quot;p1&quot;, &quot;p2&quot;]</span></span><br><span class="line">values(o)</span><br><span class="line"><span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure>

<p>（9）<code>monitorEvents(object[, events]) ，unmonitorEvents(object[, events])</code></p>
<p><code>monitorEvents(object[, events])</code>方法监听特定对象上发生的特定事件。事件发生时，会返回一个<code>Event</code>对象，包含该事件的相关信息。<code>unmonitorEvents</code>方法用于停止监听。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">monitorEvents(<span class="built_in">window</span>, <span class="string">&quot;resize&quot;</span>);</span><br><span class="line">monitorEvents(<span class="built_in">window</span>, [<span class="string">&quot;resize&quot;</span>, <span class="string">&quot;scroll&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>上面代码分别表示单个事件和多个事件的监听方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">monitorEvents($<span class="number">0</span>, <span class="string">&#x27;mouse&#x27;</span>);</span><br><span class="line">unmonitorEvents($<span class="number">0</span>, <span class="string">&#x27;mousemove&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码表示如何停止监听。</p>
<p><code>monitorEvents</code>允许监听同一大类的事件。所有事件可以分成四个大类。</p>
<ul>
<li>mouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”</li>
<li>key：”keydown”, “keyup”, “keypress”, “textInput”</li>
<li>touch：”touchstart”, “touchmove”, “touchend”, “touchcancel”</li>
<li>control：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset”</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitorEvents($(&quot;#msg&quot;), &quot;key&quot;);</span><br></pre></td></tr></table></figure>

<p>上面代码表示监听所有<code>key</code>大类的事件。</p>
<p>（10）其他方法</p>
<p>命令行 API 还提供以下方法。</p>
<ul>
<li><code>clear()</code>：清除控制台的历史。</li>
<li><code>copy(object)</code>：复制特定 DOM 元素到剪贴板。</li>
<li><code>dir(object)</code>：显示特定对象的所有属性，是<code>console.dir</code>方法的别名。</li>
<li><code>dirxml(object)</code>：显示特定对象的 XML 形式，是<code>console.dirxml</code>方法的别名。</li>
</ul>
<hr>
<p><code>debugger</code>语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。如果没有除错工具，<code>debugger</code>语句不会产生任何结果，JavaScript 引擎自动跳过这一句。</p>
<p>Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">2</span>) <span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。</p>
<hr>
<h5 id="Js对象认识"><a href="#Js对象认识" class="headerlink" title="Js对象认识"></a><code>Js</code>对象认识</h5><p>所谓“静态方法”，是指部署在<code>Object</code>对象自身的方法。</p>
<p>写在对象的原型对象上的方法，就是”实例”方法，</p>
<hr>
<h3 id="12-Object对象"><a href="#12-Object对象" class="headerlink" title="12.Object对象"></a>12.<code>Object</code>对象</h3><p><code>Object</code>本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。</p>
<p>如果参数是原始类型的值，<code>Object</code>方法将其转为对应的包装对象的实例</p>
<p>如果<code>Object</code>方法的参数是一个对象，它总是返回该对象，即不用转换。</p>
<p>利用这一点，可以写一个判断变量是否为对象的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value === <span class="built_in">Object</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Object.keys</code>方法和<code>Object.getOwnPropertyNames</code>方法都用来遍历对象的属性。区别是前者返回的数组的成员都是该对象自身的（而不是继承的）所有属性名。后者包含了该对象自身的所有属性名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(a) <span class="comment">// [&quot;0&quot;, &quot;1&quot;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(a) <span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]</span></span><br></pre></td></tr></table></figure>

<p>一般情况下，几乎总是使用<code>Object.keys</code>方法，遍历对象的属性。</p>
<hr>
<p><code>Object</code>还有不少其他静态方法，将在后文逐一详细介绍。</p>
<p><strong>（1）对象属性模型的相关方法</strong></p>
<ul>
<li><code>Object.getOwnPropertyDescriptor()</code>：获取某个属性的描述对象。</li>
<li><code>Object.defineProperty()</code>：通过描述对象，定义某个属性。</li>
<li><code>Object.defineProperties()</code>：通过描述对象，定义多个属性。</li>
</ul>
<p><strong>（2）控制对象状态的方法</strong></p>
<ul>
<li><code>Object.preventExtensions()</code>：防止对象扩展。</li>
<li><code>Object.isExtensible()</code>：判断对象是否可扩展。</li>
<li><code>Object.seal()</code>：禁止对象配置。</li>
<li><code>Object.isSealed()</code>：判断一个对象是否可配置。</li>
<li><code>Object.freeze()</code>：冻结一个对象。</li>
<li><code>Object.isFrozen()</code>：判断一个对象是否被冻结。</li>
</ul>
<p><strong>（3）原型链相关方法</strong></p>
<ul>
<li><p><code>Object.create()</code>：该方法可以指定原型对象和属性，返回一个新的对象。(生成实例对象的常用方法是，使用<code>new</code>命令让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？该方法用来满足这种需求。)</p>
</li>
<li><p><code>Object.getPrototypeOf()</code>：获取对象的<code>Prototype</code>对象。</p>
</li>
<li><p><code>Object.setPrototypeOf</code>方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。</p>
<hr>
<h5 id="proto-说明"><a href="#proto-说明" class="headerlink" title="__proto__说明"></a><code>__proto__</code>说明</h5></li>
<li><p><code>Object.prototype.__proto__</code>实例对象的的这个属性（前后各两个下划线），返回该对象的原型。该属性可读写。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.__proto__ = p;</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj) === p <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码通过<code>__proto__</code>属性，将<code>p</code>对象设为<code>obj</code>对象的原型。</p>
<p>根据语言标准，<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用<code>Object.getPrototypeOf()</code>和<code>Object.setPrototypeOf()</code>，进行原型对象的读写操作。</p>
<p>原型链可以用<code>__proto__</code>很直观地表示。</p>
<hr>
<h5 id="Object-的实例方法"><a href="#Object-的实例方法" class="headerlink" title="Object 的实例方法"></a>Object 的实例方法</h5><p>除了静态方法，还有不少方法定义在<code>Object.prototype</code>对象。它们称为实例方法，所有<code>Object</code>的实例对象都继承了这些方法。</p>
<p><code>Object</code>实例对象的方法，主要有以下六个。</p>
<ul>
<li><code>Object.prototype.valueOf()</code>：返回当前对象对应的值。</li>
<li><code>Object.prototype.toString()</code>：返回当前对象对应的字符串形式。</li>
<li><code>Object.prototype.toLocaleString()</code>：返回当前对象对应的本地字符串形式。</li>
<li><code>Object.prototype.hasOwnProperty()</code>：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</li>
<li><code>Object.prototype.isPrototypeOf()</code>：判断当前对象是否为另一个对象的原型。</li>
<li><code>Object.prototype.propertyIsEnumerable()</code>：判断某个属性是否可枚举。</li>
</ul>
<hr>
<p><code>JavaScript</code>对于对象提供了六个默认属性，通过<code>getOwnPropertyDescriptor()</code>方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。以下是默认属性说明。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="string">&#x27;a&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;p&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>（1）<code>value</code></p>
<p><code>value</code>是该属性的属性值，默认为<code>undefined</code>。</p>
<p>（2）<code>writable</code></p>
<p><code>writable</code>是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为<code>true</code>。</p>
<p>（3）<code>enumerable</code></p>
<p><code>enumerable</code>是一个布尔值，表示该属性是否可遍历，默认为<code>true</code>。如果设为<code>false</code>，会使得某些操作（比如<code>for...in</code>循环、<code>Object.keys()</code>、<code>JSON.stringify</code>方法）跳过该属性。</p>
<ul>
<li>如果对象的 JSON 格式输出要排除某些属性，就可以把这些属性的<code>enumerable</code>设为<code>false</code></li>
</ul>
<p>（4）<code>configurable</code></p>
<p><code>configurable</code>是一个布尔值，表示属性的可配置性，默认为<code>true</code>。如果设为<code>false</code>，将阻止某些操作改写属性描述对象，比如无法删除该属性，也不得改变各种元属性（<code>value</code>属性除外）。也就是说，<code>configurable</code>属性控制了属性描述对象的可写性。</p>
<p>（5）<code>get</code></p>
<p><code>get</code>是一个函数，表示该属性的取值函数（getter），默认为<code>undefined</code>。</p>
<p>（6）<code>set</code></p>
<p><code>set</code>是一个函数，表示该属性的存值函数（setter），默认为<code>undefined</code>。</p>
<hr>
<ul>
<li><p>一旦定义了取值函数<code>get</code>（或存值函数<code>set</code>），就不能将<code>writable</code>属性设为<code>true</code>，或者同时定义<code>value</code>属性，否则会报错。</p>
</li>
<li><p>这些属性也被称作元属性。通过<code>defineProperty()</code>方法进行修改</p>
</li>
<li><p><code>obj.p</code>定义了<code>get</code>和<code>set</code>属性。<code>obj.p</code>取值时，就会调用<code>get</code>；赋值时，就会调用<code>set</code>。以下是一般写法</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">p</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">p</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><p><code>Object.getOwnPropertyNames</code>方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。</p>
</li>
<li><p>实例对象的<code>propertyIsEnumerable()</code>方法返回一个布尔值，用来判断某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回<code>false</code>。</p>
</li>
</ul>
<hr>
<h5 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h5><p>既需要拷贝自定义属性，也需要拷贝元属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extend = <span class="function"><span class="keyword">function</span> (<span class="params">to, <span class="keyword">from</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> property <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">from</span>.hasOwnProperty(property)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(</span><br><span class="line">      to,</span><br><span class="line">      property,</span><br><span class="line">      <span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="keyword">from</span>, property)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extend(&#123;&#125;, &#123; <span class="keyword">get</span> <span class="title">a</span>()&#123; <span class="keyword">return</span> <span class="number">1</span> &#125; &#125;)</span><br><span class="line"><span class="comment">// &#123; get a()&#123; return 1 &#125; &#125;)</span></span><br></pre></td></tr></table></figure>

<hr>
<p>控制对象的状态</p>
<p>有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是<code>Object.preventExtensions</code>，其次是<code>Object.seal</code>，最强的是<code>Object.freeze</code>。</p>
<ul>
<li><p><code>Object.preventExtensions</code>方法可以使得一个对象无法再添加新的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​        <code>Object.isExtensible</code>方法用于检查一个对象是否使用了<code>Object.preventExtensions</code>方法。也就是说，检查是否可以为一个对象添加属性。</p>
<ul>
<li><p><code>Object.seal</code>方法使得一个对象既无法添加新属性，也无法删除旧属性。<code>Object.seal</code>实质是把属性描述对象的<code>configurable</code>属性设为<code>false</code>，因此属性描述对象不再能改变了。<code>Object.seal</code>只是禁止新增或删除属性，并不影响修改某个属性的值。</p>
<p><code>Object.isSealed</code>方法用于检查一个对象是否使用了<code>Object.seal</code>方法。</p>
</li>
<li><p><code>Object.freeze</code>方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。(凯亚：冻结吧！)</p>
<p><code>Object.isFrozen</code>方法用于检查一个对象是否使用了<code>Object.freeze</code>方法。<code>Object.isFrozen</code>的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值。</p>
</li>
<li><p>漏洞</p>
<ul>
<li>漏洞一：虽然冻结了对象（Object），但是可以通过改变原型对象，来为对象增加属性。</li>
</ul>
<p>一种解决方案是，把<code>obj</code>的原型也冻结住。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.getPrototypeOf(obj);</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proto);</span><br></pre></td></tr></table></figure>

<ul>
<li>漏洞二：如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。比如说：<code>obj.bar</code>属性指向一个数组，<code>obj</code>对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="13-Array对象"><a href="#13-Array对象" class="headerlink" title="13.Array对象"></a>13.<code>Array</code>对象</h3><ul>
<li><code>push()</code> 末尾插数</li>
<li><code>pop()</code> 末尾减数，返回被减去的数对象</li>
</ul>
<p><code>push</code>和<code>pop</code>结合使用，就构成了“后进先出”的栈结构（stack）。</p>
<ul>
<li><code>shift()</code>头部插数</li>
<li><code>unshift()</code>头部减数，返回被减去的数对象</li>
</ul>
<p><code>push()</code>和<code>shift()</code>结合使用，就构成了“先进先出”的队列结构（queue）。</p>
<ul>
<li><p><code>join()</code>相当于<code>Java</code>的<code>spilt</code>,</p>
</li>
<li><p><code>concat()</code>方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;hello&#x27;</span>].concat([<span class="string">&#x27;world&#x27;</span>], [<span class="string">&#x27;!&#x27;</span>])</span><br><span class="line"><span class="comment">//concat也接受其他类型的值作为参数，添加到目标数组尾部。</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].concat(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>如果数组成员包括对象，<code>concat</code>方法返回当前数组的一个浅拷贝。</p>
</li>
<li><p><code>reverse</code>方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</p>
</li>
<li><p><code>arr.slice(start, end)</code>方法用于提取目标数组的一部分，返回一个新数组，原数组不变。如果<code>slice()</code>方法的参数是负数，则表示倒着数计算的位置。</p>
<p><code>slice()</code>方法的一个重要应用，是将类似数组的对象转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(&#123; <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>));</span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码的参数都不是数组，但是通过<code>call</code>方法，在它们上面调用<code>slice()</code>方法，就可以把它们转为真正的数组。</p>
</li>
<li><p><code>splice()</code>方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(start, count, addElement1, addElement2, ...);</span><br></pre></td></tr></table></figure>

<p><code>splice</code>的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。相同的，起始位置如果是负数，就表示从倒数位置开始删除。</p>
<ul>
<li>如果只是单纯地插入元素，<code>splice</code>方法的第二个参数可以设为<code>0</code>。</li>
<li>如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</li>
</ul>
</li>
<li><p><code>sort</code>方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</p>
<p>如果想让<code>sort</code>方法按照自定义方式排序，可以传入一个函数作为参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10111</span>, <span class="number">1101</span>, <span class="number">111</span>].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [111, 1101, 10111]</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>map()</code>方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</p>
<p><code>map()</code>方法接受一个函数作为参数。该函数调用时，这个参数函数可以传入三个参数：当前成员、当前位置和数组本身。</p>
<p><code>map()</code>方法还可以接受第二个参数，用来绑定回调函数内部的<code>this</code>变量,就是把结果指向<code>arr</code>数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">elem, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem * index;</span><br><span class="line">&#125;);</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem + <span class="number">1</span>;</span><br><span class="line">&#125;,arr);</span><br></pre></td></tr></table></figure></li>
<li><p><code>forEach()</code>的用法与<code>map()</code>方法一致，参数是也一致。如果数组遍历的目的是为了得到返回值，那么使用<code>map()</code>方法，否则使用<code>forEach()</code>方法。</p>
<p><code>forEach()</code>方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用<code>for</code>循环</p>
<p><code>forEach()</code>方法不会跳过<code>undefined</code>和<code>null</code>，但会跳过空位。</p>
</li>
<li><p><code>filter()</code>方法用于过滤数组成员，满足条件的成员组成一个新数组返回,参数同上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].filter(<span class="function"><span class="keyword">function</span> (<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (elem &gt; <span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [4, 5]</span></span><br></pre></td></tr></table></figure></li>
<li><p>类似断言的方法</p>
<ul>
<li><code>some</code>方法是只要一个成员的返回值是<code>true</code>，则整个<code>some</code>方法的返回值就是<code>true</code>，否则返回<code>false</code>。</li>
<li><code>every</code>方法是所有成员的返回值都是<code>true</code>，整个<code>every</code>方法才返回<code>true</code>，否则返回<code>false</code>。</li>
</ul>
</li>
<li><p><code>reduce()</code>方法和<code>reduceRight()</code>方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code>reduce()</code>是从左到右处理（从第一个成员到最后一个成员），<code>reduceRight()</code>则是从右到左（从最后一个成员到第一个成员），其他完全一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"><span class="comment">// 3 3</span></span><br><span class="line"><span class="comment">// 6 4</span></span><br><span class="line"><span class="comment">// 10 5</span></span><br><span class="line"><span class="comment">//最后结果：15</span></span><br></pre></td></tr></table></figure>

<p>这四个参数之中，只有前两个是必须的，后两个则是可选的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  a,   <span class="comment">// 累积变量，必须</span></span></span></span><br><span class="line"><span class="params"><span class="function">  b,   <span class="comment">// 当前变量，必须</span></span></span></span><br><span class="line"><span class="params"><span class="function">  i,   <span class="comment">// 当前位置，可选</span></span></span></span><br><span class="line"><span class="params"><span class="function">  arr  <span class="comment">// 原数组，可选</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... ...</span></span><br></pre></td></tr></table></figure>

<p>如果要对累积变量指定初值，可以把它放在<code>reduce()</code>方法和<code>reduceRight()</code>方法的第二个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 25</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>lastIndexOf</code>方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回<code>-1</code></p>
<p>该和<code>indexOf()</code>方法不能用来搜索<code>NaN</code>的位置，即它们无法确定数组成员是否包含<code>NaN</code>。这是因为这两个方法内部，使用严格相等运算符（<code>===</code>）进行比较，而<code>NaN</code>是唯一一个不等于自身的值。</p>
</li>
<li><p>总结一下：这个就是类似<code>java Stream</code>的方法，它们也可以链式调用。</p>
</li>
</ul>
<hr>
<h3 id="14-包装对象"><a href="#14-包装对象" class="headerlink" title="14.包装对象"></a>14.包装对象</h3><p>所谓“包装对象”，指的是与数值、字符串、布尔值分别相对应的<code>Number</code>、<code>String</code>、<code>Boolean</code>三个原生对象。</p>
<p>值得注意的是包装对象还可以自定义方法和属性，供原始类型的值直接调用。</p>
<p>比如，我们可以新增一个<code>double</code>方法，使得字符串和数字翻倍。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.double = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() + <span class="built_in">this</span>.valueOf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.double()</span><br><span class="line"><span class="comment">// abcabc</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.prototype.double = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() + <span class="built_in">this</span>.valueOf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="number">123</span>).double() <span class="comment">// 246</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="15-Boolean-值得注意的点"><a href="#15-Boolean-值得注意的点" class="headerlink" title="15.Boolean 值得注意的点"></a>15.<code>Boolean</code> 值得注意的点</h3><p>Boolean对于特殊值的判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;false&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="regexp">/foo/</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>使用双重的否运算符（<code>!</code>）也可以将任意值转为对应的布尔值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!!<span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">null</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>最后，对于一些特殊值，<code>Boolean</code>对象前面加不加<code>new</code>，会得到完全相反的结果，必须小心。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Boolean</span>(<span class="literal">false</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// 无输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Boolean</span>(<span class="literal">null</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// 无输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">null</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="16-Number对象值得注意的点"><a href="#16-Number对象值得注意的点" class="headerlink" title="16.Number对象值得注意的点"></a>16.Number对象值得注意的点</h3><ul>
<li><code>Number.POSITIVE_INFINITY</code>：正的无限，指向<code>Infinity</code>。</li>
<li><code>Number.NEGATIVE_INFINITY</code>：负的无限，指向<code>-Infinity</code>。</li>
<li><code>Number.NaN</code>：表示非数值，指向<code>NaN</code>。</li>
<li><code>Number.MIN_VALUE</code>：表示最小的正数（即最接近0的正数，在64位浮点数体系中为<code>5e-324</code>），相应的，最接近0的负数为<code>-Number.MIN_VALUE</code>。</li>
<li><code>Number.MAX_SAFE_INTEGER</code>：表示能够精确表示的最大整数，即<code>9007199254740991</code>。</li>
<li><code>Number.MIN_SAFE_INTEGER</code>：表示能够精确表示的最小整数，即<code>-9007199254740991</code>。</li>
</ul>
<hr>
<ul>
<li><p><code>toFixed()</code>方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。</p>
<p><code>toFixed()</code>方法的参数为小数位数，有效范围为0到100，超出这个范围将抛出 RangeError 错误。</p>
<p>由于浮点数的原因，小数<code>5</code>的四舍五入是不确定的，使用的时候必须小心。</p>
</li>
<li><p><code>toExponential</code>方法用于将一个数转为科学计数法形式。</p>
<p><code>toExponential</code>方法的参数是小数点后有效数字的位数，范围为0到100，超出这个范围，会抛出一个 RangeError 错误。</p>
</li>
<li><p><code>Number.prototype.toPrecision()</code>方法用于将一个数转为指定位数的有效数字。 参数同上</p>
<p>该方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关。</p>
</li>
<li><p>总结：Js做小数的操作都不太靠谱，能不用尽量别用。</p>
</li>
</ul>
<hr>
<h3 id="17-String对象值得注意的点"><a href="#17-String对象值得注意的点" class="headerlink" title="17.String对象值得注意的点"></a>17.<code>String</code>对象值得注意的点</h3><ul>
<li><p><code>charCodeAt()</code>方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于<code>String.fromCharCode()</code>的逆操作。</p>
</li>
<li><p><code>concat</code>方法用于连接两个字符串，返回一个新字符串，不改变原字符串。</p>
</li>
<li><p><code>slice()</code>方法用于从原字符串取出子字符串并返回，<em><strong>不改变原字符串</strong></em>。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。<code>substr</code>方法好像作用一样。</p>
</li>
<li><p><code>trim</code>方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</p>
</li>
<li><p><code>match</code>方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回<code>null</code>。<code>search</code>方法作用一样，但还可以使用正则表达式作为参数。</p>
</li>
</ul>
<hr>
<h3 id="18-Math对象值得注意的点"><a href="#18-Math对象值得注意的点" class="headerlink" title="18.Math对象值得注意的点"></a>18.<code>Math</code>对象值得注意的点</h3><p><code>Math</code>对象的静态属性，提供以下一些数学常数。</p>
<ul>
<li><code>Math.E</code>：常数<code>e</code>。</li>
<li><code>Math.LN2</code>：2 的自然对数。</li>
<li><code>Math.LN10</code>：10 的自然对数。</li>
<li><code>Math.LOG2E</code>：以 2 为底的<code>e</code>的对数。</li>
<li><code>Math.LOG10E</code>：以 10 为底的<code>e</code>的对数。</li>
<li><code>Math.PI</code>：常数<code>π</code>。</li>
<li><code>Math.SQRT1_2</code>：0.5 的平方根。</li>
<li><code>Math.SQRT2</code>：2 的平方根。</li>
</ul>
<p><code>Math</code>对象提供以下一些静态方法。</p>
<ul>
<li><code>Math.abs()</code>：绝对值</li>
<li><code>Math.ceil()</code>：向上取整</li>
<li><code>Math.floor()</code>：向下取整</li>
<li><code>Math.max()</code>：最大值</li>
<li><code>Math.min()</code>：最小值</li>
<li><code>Math.pow()</code>：幂运算</li>
<li><code>Math.sqrt()</code>：平方根</li>
<li><code>Math.log()</code>：自然对数</li>
<li><code>Math.exp()</code>：<code>e</code>的指数</li>
<li><code>Math.round()</code>：四舍五入</li>
<li><code>Math.random()</code>：随机数</li>
</ul>
<hr>
<h3 id="19-Date对象值得注意的点"><a href="#19-Date对象值得注意的点" class="headerlink" title="19.Date对象值得注意的点"></a>19.<code>Date</code>对象值得注意的点</h3><p>定义时间就跟<code>Java8 Time</code>包的差不多，但更灵活。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"><span class="comment">//灵活在这样都能解析</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2013-2-15&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2013/2/15&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;02/15/2013&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>日期设为<code>0</code>，就代表上个月的最后一天。</p>
</li>
<li><p>参数还可以使用负数，表示扣去的时间。</p>
</li>
<li><p>日期运算不能直接加减，先转成对应的毫秒数，运算后在<code>new Date()</code>转回来。</p>
</li>
</ul>
<p>静态方法</p>
<ul>
<li><code>Date.now</code>方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。</li>
<li><code>Date.parse</code>方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。如果解析失败，返回<code>NaN</code>。</li>
<li><code>Date.UTC</code>方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数</li>
</ul>
<p>实例方法</p>
<p><code>Date</code>的实例对象，有几十个自己的方法，除了<code>valueOf</code>和<code>toString</code>，可以分为以下三类。</p>
<ul>
<li><code>to</code>类：从<code>Date</code>对象返回一个字符串，表示指定的时间。</li>
<li><code>get</code>类：获取<code>Date</code>对象的日期和时间。<code>getFullYear</code>这种就不加以赘述</li>
<li><code>set</code>类：设置<code>Date</code>对象的日期和时间。<code>setFullYear</code>这种就不加以赘述</li>
</ul>
<hr>
<ul>
<li><code>valueOf</code>方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，等同于<code>getTime</code>方法。</li>
<li><code>toDateString</code>方法返回日期字符串（不含小时、分和秒）。</li>
<li><code>toTimeString</code>方法返回时间字符串（不含年月日）。</li>
</ul>
<hr>
<p>正则用到的时候再看吧，语法都是其次，<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/stdlib/regexp#%E6%A6%82%E8%BF%B0">here</a>.</p>
<hr>
<h3 id="20-JSON对象"><a href="#20-JSON对象" class="headerlink" title="20.JSON对象"></a>20.<code>JSON</code>对象</h3><ul>
<li><p><code>JSON.stringify()</code>方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，</p>
<p><code>JSON.stringify()</code>方法还可以接受一个数组，作为第二个参数，指定参数对象的哪些属性需要转成字符串。</p>
<p><code>(</code>用处不大<code>)</code>：<code>JSON.stringify()</code>还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。默认返回的是单行字符串，对于大型的 JSON 对象，可读性非常差。第三个参数使得每个属性单独占据一行，并且将每个属性前面添加指定的前缀（不超过10个字符）。第三个属性如果是一个数字，则表示每个属性前面添加的空格（最多不超过10个）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认输出</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">p1</span>: <span class="number">1</span>, <span class="attr">p2</span>: <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// JSON.stringify(&#123; p1: 1, p2: 2 &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分行输出</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">p1</span>: <span class="number">1</span>, <span class="attr">p2</span>: <span class="number">2</span> &#125;, <span class="literal">null</span>, <span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	&quot;p1&quot;: 1,</span></span><br><span class="line"><span class="comment">// 	&quot;p2&quot;: 2</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    <code>toJSON()</code>方法跟<code>JSON.stringify()</code>作用一样。它的一个应用是，将正则对象自动转为字符串。因为<code>JSON.stringify()</code>默认不能转换正则对象，但是设置了<code>toJSON()</code>方法以后，就可以转换正则对象了。</p>
<ul>
<li><code>JSON.parse()</code>方法用于将 JSON 字符串转换成对应的值。</li>
</ul>
<hr>
<h3 id="21-面向对象"><a href="#21-面向对象" class="headerlink" title="21.面向对象"></a>21.面向对象</h3><ul>
<li><p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用<code>Object.create()</code>方法。</p>
</li>
<li><p><code>this</code>就是属性或方法“当前”所在的对象。</p>
</li>
<li><p>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</p>
<p>如果一层层地上溯，所有对象的原型最终都可以上溯到<code>Object.prototype</code>，即<code>Object</code>构造函数的<code>prototype</code>属性。也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的。</p>
<p>那么，<code>Object.prototype</code>对象有没有它的原型呢？回答是<code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是<code>null</code>。</p>
</li>
<li><p>JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.hello = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.world = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">S</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  M1.call(<span class="built_in">this</span>);</span><br><span class="line">  M2.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 M1</span></span><br><span class="line">S.prototype = <span class="built_in">Object</span>.create(M1.prototype);</span><br><span class="line"><span class="comment">// 继承链上加入 M2</span></span><br><span class="line"><span class="built_in">Object</span>.assign(S.prototype, M2.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定构造函数</span></span><br><span class="line">S.prototype.constructor = S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> S();</span><br><span class="line">s.hello <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">s.world <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，子类<code>S</code>同时继承了父类<code>M1</code>和<code>M2</code>。这种模式又称为 Mixin（混入）。</p>
</li>
</ul>
<hr>
<p>JavaScript 模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<p>模块是实现特定功能的一组属性和方法的封装。</p>
<p>简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　<span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">　<span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　  <span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　<span class="attr">m1</span> : m1,</span><br><span class="line">　　<span class="attr">m2</span> : m2</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>上面的函数<code>m1</code>和<code>m2</code>，都封装在<code>module1</code>对象里。使用的时候，就是调用这个对象的属性。</p>
<p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">mod</span>) </span>&#123;</span><br><span class="line">　<span class="comment">//...</span></span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(<span class="built_in">window</span>.module1 || &#123;&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><p>进入严格模式的标志，是一行字符串<code>use strict</code>。作用域可以是脚本：使用需要放在脚本文件的第一行。作用域也可以是单个函数：需要将其放在函数体的第一行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br></pre></td></tr></table></figure>

<p>在多人开发中，有时需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="22-JavaScript的异步操作"><a href="#22-JavaScript的异步操作" class="headerlink" title="22.JavaScript的异步操作"></a>22.<code>JavaScript</code>的异步操作</h3><ul>
<li><p>首先，<code>JavaScript</code>是单线程模型的语言，但<code>JavaScript</code> 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。对于高频大量访问的情况是通过异步解决的。</p>
</li>
<li><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p>
<p>同步任务就在主线程上排队，异步任务就其他任务队列（队列有多个）的，从而不影响异步任务后的任务。引擎会实时检查异步任务能否是否满足执行条件，满足的话就把它挪到主线程上去（异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数，如果一个异步任务没有回调函数，就不会重新进入主线程，因为没有用回调函数指定下一步的操作。），当任务队列清空，程序结束。</p>
</li>
</ul>
<h5 id="异步的操作模式"><a href="#异步的操作模式" class="headerlink" title="异步的操作模式"></a>异步的操作模式</h5><ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
</ul>
<h5 id="多个异步的流程控制"><a href="#多个异步的流程控制" class="headerlink" title="多个异步的流程控制"></a>多个异步的流程控制</h5><ul>
<li>串行执行：编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。</li>
<li>并行执行：即所有异步任务同时执行，等到全部完成以后，才执行<code>final</code>函数。</li>
<li>线程池模式：并行给他设置个池子大小，即同时最多只能执行<code>n</code>个任务….简易的线程池。</li>
</ul>
<hr>
<h3 id="23-定时器相关"><a href="#23-定时器相关" class="headerlink" title="23.定时器相关"></a>23.定时器相关</h3><p><code>setTimeout</code>函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。<code>setTimeout</code>函数接受两个参数，第一个参数<code>func|code</code>是将要推迟执行的函数名或者一段代码，第二个参数<code>delay</code>是推迟执行的毫秒数。<code>setTimeout</code>的第二个参数如果省略，则默认为0。</p>
<p><code>setTimeout</code>还允许更多的参数。下例中的<code>1,1</code>就作为回调函数的参数<code>a,b</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>值得注意的点：</p>
<ul>
<li><p>setTimeout<code>的作用是将代码推迟到指定时间执行，如果指定时间为</code>0<code>，即</code>setTimeout(f, 0)会在下一轮事件循环一开始就执行。<code>setTimeout(f, 0)</code>有几个非常重要的用途。</p>
<ul>
<li><p>可以调整事件的发生顺序（举例：父子模块执行顺序）。</p>
</li>
<li><p>另一个应用是，用户自定义的回调函数，通常在浏览器的默认动作之前触发。（举例：用户每次输入文本后，立即将字符转为大写。但是实际上，它只能将本次输入前的字符转为大写，因为浏览器此时还没接收到新的文本，所以<code>this.value</code>取不到最新输入的那个字符。只有用<code>setTimeout</code>改写，上面的代码才能发挥作用。）</p>
</li>
<li><p>由于<code>setTimeout(f, 0)</code>实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到<code>setTimeout(f, 0)</code>里面执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0xA00000</span>; i &lt; <span class="number">0xFFFFFF</span>; i++) &#123;</span><br><span class="line">  div.style.backgroundColor = <span class="string">&#x27;#&#x27;</span> + i.toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> timer;</span><br><span class="line"><span class="keyword">var</span> i=<span class="number">0x100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(func, <span class="number">0</span>);</span><br><span class="line">  div.style.backgroundColor = <span class="string">&#x27;#&#x27;</span> + i.toString(<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">if</span> (i++ == <span class="number">0xFFFFFF</span>) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timer = <span class="built_in">setTimeout</span>(func, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，因为 JavaScript 执行速度远高于 DOM，会造成大量 DOM 操作“堆积”，而写法二就不会，这就是<code>setTimeout(f, 0)</code>的好处。</p>
<p>另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成<code>setTimeout(highlightNext, 50)</code>的样子，性能压力就会减轻。</p>
</li>
</ul>
</li>
<li><p>如果回调函数是对象的方法，那么<code>setTimeout</code>使得方法内部的<code>this</code>关键字指向全局环境，而不是定义时所在的那个对象。</p>
<p>为了防止出现这个问题，一种解决方法是将<code>obj.y</code>放入一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  obj.y();</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.y</code>放在一个匿名函数之中，这使得<code>obj.y</code>在<code>obj</code>的作用域执行，而不是在全局作用域内执行，所以能够显示正确的值。</p>
<p>另一种解决方法是，使用<code>bind</code>方法，将<code>obj.y</code>这个方法绑定在<code>obj</code>上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.y.bind(obj), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><code>setInterval</code>函数的用法与<code>setTimeout</code>完全一致，区别仅仅在于<code>setInterval</code>指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p>
<p><code>setInterval</code>指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，<code>setInterval</code>指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。</p>
<p>为了确保两次执行之间有固定的间隔，可以不用<code>setInterval</code>，而是每次执行结束后，使用<code>setTimeout</code>指定下一次执行的具体时间。即双重<code>setTimeout</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(f, <span class="number">2000</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p><code>setTimeout</code>和<code>setInterval</code>函数，都返回一个整数值，表示计数器编号。将该整数传入<code>clearTimeout</code>和<code>clearInterval</code>函数，就可以取消对应的定时器。</p>
<p><code>setTimeout</code>和<code>setInterval</code>返回的整数值是连续的，也就是说，第二个<code>setTimeout</code>方法返回的整数值，将比第一个的整数值大1。</p>
<p>利用这一点，可以写一个函数，取消当前所有的<code>setTimeout</code>定时器。先调用<code>setTimeout</code>，得到一个计算器编号，然后把编号比它小的计数器全部取消。</p>
<h5 id="定时器的实现逻辑"><a href="#定时器的实现逻辑" class="headerlink" title="定时器的实现逻辑"></a>定时器的实现逻辑</h5><p><code>setTimeout</code>和<code>setInterval</code>的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。</p>
<p>这意味着，<code>setTimeout</code>和<code>setInterval</code>指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，<code>setTimeout</code>和<code>setInterval</code>指定的任务，一定会按照预定时间执行。</p>
<hr>
<h5 id="页面防抖处理-debounce"><a href="#页面防抖处理-debounce" class="headerlink" title="页面防抖处理 debounce"></a>页面防抖处理 debounce</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;textarea&#x27;</span>).on(<span class="string">&#x27;keydown&#x27;</span>, debounce(ajaxAction, <span class="number">2500</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>; <span class="comment">// 声明计时器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，只要在2500毫秒之内，用户再次击键，就会取消上一次的定时器，然后再新建一个定时器。这样就保证了回调函数之间的调用间隔，至少是2500毫秒。</p>
<hr>
<h3 id="24-Promise对象（重要）"><a href="#24-Promise对象（重要）" class="headerlink" title="24.Promise对象（重要）"></a>24.<code>Promise</code>对象（重要）</h3><p>Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p>
<p>Promise 是一个对象，也是一个构造函数。传统的写法可能需要把<code>f2</code>作为回调函数传入<code>f1</code>，比如写成<code>f1(f2)</code>，异步操作完成后，在<code>f1</code>内部调用<code>f2</code>。Promise 使得<code>f1</code>和<code>f2</code>变成了链式写法。不仅改善了可读性，而且对于多层嵌套的回调函数尤其方便。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line">step1(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</span><br><span class="line">  step2(value1, <span class="function"><span class="keyword">function</span>(<span class="params">value2</span>) </span>&#123;</span><br><span class="line">    step3(value2, <span class="function"><span class="keyword">function</span>(<span class="params">value3</span>) </span>&#123;</span><br><span class="line">      step4(value3, <span class="function"><span class="keyword">function</span>(<span class="params">value4</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 的写法</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Promise</span>(step1))</span><br><span class="line">  .then(step2)</span><br><span class="line">  .then(step3)</span><br><span class="line">  .then(step4);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Promise对象的状态"><a href="#Promise对象的状态" class="headerlink" title="Promise对象的状态"></a><code>Promise</code>对象的状态</h5><p>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</p>
<ul>
<li>异步操作未完成（pending）</li>
<li>异步操作成功（fulfilled）</li>
<li>异步操作失败（rejected）</li>
</ul>
<p>上面三种状态里面，<code>fulfilled</code>和<code>rejected</code>合在一起称为<code>resolved</code>（已定型）。</p>
<p>因此，Promise 的最终结果只有两种。</p>
<ul>
<li>异步操作成功，Promise 实例传回一个值（value），状态变为<code>fulfilled</code>。</li>
<li>异步操作失败，Promise 实例抛出一个错误（error），状态变为<code>rejected</code>。</li>
</ul>
<hr>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>（异步操作成功时调用）和<code>reject</code>（失败时调用）。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。</p>
<p>Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。</p>
<p>而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。</p>
<p>Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆<code>then</code>，必须自己在<code>then</code>的回调函数里面理清逻辑。</p>
<p>Promise 的回调函数属于异步任务，会在同步任务之后执行。但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。</p>
<hr>
<p>DOM 操作 忽略</p>
<hr>
<h3 id="25-鼠标事件"><a href="#25-鼠标事件" class="headerlink" title="25.鼠标事件"></a>25.鼠标事件</h3><p>鼠标事件主要有下面这些，所有事件都继承了<code>MouseEvent</code>接口</p>
<p>（1）点击事件</p>
<p>鼠标点击相关的有四个事件。</p>
<ul>
<li><code>click</code>：按下鼠标（通常是按下主按钮）时触发。</li>
<li><code>dblclick</code>：在同一个元素上双击鼠标时触发。</li>
<li><code>mousedown</code>：按下鼠标键时触发。</li>
<li><code>mouseup</code>：释放按下的鼠标键时触发。</li>
</ul>
<p><code>click</code>事件可以看成是两个事件组成的：用户在同一个位置先触发<code>mousedown</code>，再触发<code>mouseup</code>。因此，触发顺序是，<code>mousedown</code>首先触发，<code>mouseup</code>接着触发，<code>click</code>最后触发。</p>
<p>双击时，<code>dblclick</code>事件则会在<code>mousedown</code>、<code>mouseup</code>、<code>click</code>之后触发。</p>
<p>（2）移动事件</p>
<p>鼠标移动相关的有五个事件。</p>
<ul>
<li><code>mousemove</code>：当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。</li>
<li><code>mouseenter</code>：鼠标进入一个节点时触发，进入子节点不会触发这个事件（详见后文）。</li>
<li><code>mouseover</code>：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件（详见后文）。</li>
<li><code>mouseout</code>：鼠标离开一个节点时触发，离开父节点也会触发这个事件（详见后文）。</li>
<li><code>mouseleave</code>：鼠标离开一个节点时触发，离开父节点不会触发这个事件（详见后文）。</li>
</ul>
<p><code>mouseover</code>事件和<code>mouseenter</code>事件，都是鼠标进入一个节点时触发。两者的区别是，<code>mouseenter</code>事件只触发一次，而只要鼠标在节点内部移动，<code>mouseover</code>事件会在子节点上触发多次。</p>
<p>（3）其他事件</p>
<ul>
<li><code>contextmenu</code>：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文”菜单键时触发。</li>
<li><code>wheel</code>：滚动鼠标的滚轮时触发，该事件继承的是<code>WheelEvent</code>接口。</li>
</ul>
<hr>
<h3 id="26-键盘事件"><a href="#26-键盘事件" class="headerlink" title="26.键盘事件"></a>26.键盘事件</h3><p>键盘事件由用户击打键盘触发，主要有<code>keydown</code>、<code>keypress</code>、<code>keyup</code>三个事件，它们都继承了<code>KeyboardEvent</code>接口。</p>
<ul>
<li><code>keydown</code>：按下键盘时触发。</li>
<li><code>keypress</code>：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发<code>keydown</code>事件，再触发这个事件。</li>
<li><code>keyup</code>：松开键盘时触发该事件。</li>
</ul>
<p>如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。</p>
<ol>
<li>keydown</li>
<li>keypress</li>
<li>keydown</li>
<li>keypress</li>
<li>…（重复以上过程）</li>
<li>keyup</li>
</ol>
<p><code>KeyboardEvent</code>接口用来描述用户与键盘的互动。这个接口继承了<code>Event</code>接口，并且定义了自己的实例属性和实例方法。</p>
<p>浏览器原生提供<code>KeyboardEvent</code>构造函数，用来新建键盘事件的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> KeyboardEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>KeyboardEvent</code>构造函数接受两个参数。第一个参数是字符串，表示事件类型；第二个参数是一个事件配置对象，该参数可选。除了<code>Event</code>接口提供的属性，还可以配置以下字段，它们都是可选。</p>
<ul>
<li><code>key</code>：字符串，当前按下的键，默认为空字符串。</li>
<li><code>code</code>：字符串，表示当前按下的键的字符串形式，默认为空字符串。</li>
<li><code>location</code>：整数，当前按下的键的位置，默认为<code>0</code>。</li>
<li><code>ctrlKey</code>：布尔值，是否按下 Ctrl 键，默认为<code>false</code>。</li>
<li><code>shiftKey</code>：布尔值，是否按下 Shift 键，默认为<code>false</code>。</li>
<li><code>altKey</code>：布尔值，是否按下 Alt 键，默认为<code>false</code>。</li>
<li><code>metaKey</code>：布尔值，是否按下 Meta 键，默认为<code>false</code>。</li>
<li><code>repeat</code>：布尔值，是否重复按键，默认为<code>false</code>。</li>
</ul>
<hr>
<h3 id="27-进度事件"><a href="#27-进度事件" class="headerlink" title="27.进度事件"></a>27.进度事件</h3><p>进度事件用来描述资源加载的进度，主要由 AJAX 请求、<code>&lt;img&gt;</code>、<code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;style&gt;</code>、<code>&lt;link&gt;</code>等外部资源的加载触发，继承了<code>ProgressEvent</code>接口。它主要包含以下几种事件。</p>
<ul>
<li><code>abort</code>：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。</li>
<li><code>error</code>：由于错误导致外部资源无法加载时触发。</li>
<li><code>load</code>：外部资源加载成功时触发。</li>
<li><code>loadstart</code>：外部资源开始加载时触发。</li>
<li><code>loadend</code>：外部资源停止加载时触发，发生顺序排在<code>error</code>、<code>abort</code>、<code>load</code>等事件的后面。</li>
<li><code>progress</code>：外部资源加载过程中不断触发。</li>
<li><code>timeout</code>：加载超时时触发。</li>
</ul>
<p>注意，除了资源下载，文件上传也存在这些事件。</p>
<hr>
<h3 id="28-表单事件"><a href="#28-表单事件" class="headerlink" title="28.表单事件"></a>28.表单事件</h3><ul>
<li><p><code>input</code>事件当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>的值发生变化时触发。</p>
</li>
<li><p><code>select</code>事件当在<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>里面选中文本时触发。</p>
</li>
<li><p><code>change</code>事件当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>的值发生变化时触发。它与<code>input</code>事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发，另一方面<code>input</code>事件必然伴随<code>change</code>事件。具体来说，分成以下几种情况。</p>
<ul>
<li>激活单选框（radio）或复选框（checkbox）时触发。</li>
<li>用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。</li>
<li>当文本框或<code>&lt;textarea&gt;</code>元素的值发生改变，并且丧失焦点时触发。</li>
</ul>
</li>
<li><p><code>invalid</code>事件当用户提交表单时，如果表单元素的值不满足校验条件时触发。</p>
</li>
<li><p><code>reset</code>事件当表单重置（所有表单成员变回默认值）时触发。</p>
<p><code>submit</code>事件当表单数据向服务器提交时触发。注意，<code>submit</code>事件的发生对象是<code>&lt;form&gt;</code>元素，而不是<code>&lt;button&gt;</code>元素，因为提交的是表单，而不是按钮。</p>
</li>
</ul>
<hr>
<h3 id="29-触摸事件"><a href="#29-触摸事件" class="headerlink" title="29.触摸事件"></a>29.触摸事件</h3><p>触摸引发的事件，有以下几种。可以通过<code>TouchEvent.type</code>属性，查看到底发生的是哪一种事件。</p>
<ul>
<li><code>touchstart</code>：用户开始触摸时触发，它的<code>target</code>属性返回发生触摸的元素节点。</li>
<li><code>touchend</code>：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的<code>target</code>属性与<code>touchstart</code>事件一致的，就是开始触摸时所在的元素节点。它的<code>changedTouches</code>属性返回一个<code>TouchList</code>实例，包含所有不再触摸的触摸点（即<code>Touch</code>实例对象）。</li>
<li><code>touchmove</code>：用户移动触摸点时触发，它的<code>target</code>属性与<code>touchstart</code>事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。</li>
<li><code>touchcancel</code>：触摸点取消时触发，比如在触摸区域跳出一个模态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。</li>
</ul>
<p>浏览器的触摸 API 由三个部分组成。</p>
<ul>
<li>Touch：一个触摸点</li>
<li>TouchList：多个触摸点的集合</li>
<li>TouchEvent：触摸引发的事件实例</li>
</ul>
<p><code>Touch</code>接口的实例对象用来表示触摸点（一根手指或者一根触摸笔），包括位置、大小、形状、压力、目标元素等属性。有时，触摸动作由多个触摸点（多根手指）组成，多个触摸点的集合由<code>TouchList</code>接口的实例对象表示。<code>TouchEvent</code>接口的实例对象代表由触摸引发的事件，只有触摸屏才会引发这一类事件。</p>
<p>很多时候，触摸事件和鼠标事件同时触发，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。如果想避免这种情况，可以用<code>event.preventDefault</code>方法阻止发出鼠标事件。</p>
<p>Touch 接口代表单个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。</p>
<p>浏览器原生提供<code>Touch</code>构造函数，用来生成<code>Touch</code>实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> touch = <span class="keyword">new</span> Touch(touchOptions);</span><br></pre></td></tr></table></figure>

<p><code>Touch</code>构造函数接受一个配置对象作为参数，它有以下属性。</p>
<ul>
<li><code>identifier</code>：必需，类型为整数，表示触摸点的唯一 ID。</li>
<li><code>target</code>：必需，类型为元素节点，表示触摸点开始时所在的网页元素。</li>
<li><code>clientX</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的水平距离，默认为0。</li>
<li><code>clientY</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的垂直距离，默认为0。</li>
<li><code>screenX</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的水平距离，默认为0。</li>
<li><code>screenY</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的垂直距离，默认为0。</li>
<li><code>pageX</code>：可选，类型为数值，表示触摸点相对于网页左上角的水平位置（即包括页面的滚动距离），默认为0。</li>
<li><code>pageY</code>：可选，类型为数值，表示触摸点相对于网页左上角的垂直位置（即包括页面的滚动距离），默认为0。</li>
<li><code>radiusX</code>：可选，类型为数值，表示触摸点周围受到影响的椭圆范围的 X 轴半径，默认为0。</li>
<li><code>radiusY</code>：可选：类型为数值，表示触摸点周围受到影响的椭圆范围的 Y 轴半径，默认为0。</li>
<li><code>rotationAngle</code>：可选，类型为数值，表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间，默认值为0。</li>
<li><code>force</code>：可选，类型为数值，范围在<code>0</code>到<code>1</code>之间，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力，默认为<code>0</code>。</li>
</ul>
<hr>
<h3 id="30-拖拉事件"><a href="#30-拖拉事件" class="headerlink" title="30.拖拉事件"></a>30.拖拉事件</h3><p>在网页中，除了元素节点默认不可以拖拉，其他（图片、链接、选中的文字）都可以直接拖拉。为了让元素节点可拖拉，可以将该节点的<code>draggable</code>属性设为<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div draggable=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">  此区域可拖拉</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>当元素节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件。</p>
<ul>
<li><code>drag</code>：拖拉过程中，在被拖拉的节点上持续触发（相隔几百毫秒）。</li>
<li><code>dragstart</code>：用户开始拖拉时，在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。</li>
<li><code>dragend</code>：拖拉结束时（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。它与<code>dragstart</code>事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，<code>dragend</code>事件总是会触发的。</li>
<li><code>dragenter</code>：拖拉进入当前节点时，在当前节点上触发一次，该事件的<code>target</code>属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。</li>
<li><code>dragover</code>：拖拉到当前节点上方时，在当前节点上持续触发（相隔几百毫秒），该事件的<code>target</code>属性是当前节点。该事件与<code>dragenter</code>事件的区别是，<code>dragenter</code>事件在进入该节点时触发，然后只要没有离开这个节点，<code>dragover</code>事件会持续触发。</li>
<li><code>dragleave</code>：拖拉操作离开当前节点范围时，在当前节点上触发，该事件的<code>target</code>属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。</li>
<li><code>drop</code>：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许<code>drop</code>，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。</li>
</ul>
<h5 id="关于拖拉事件，有以下几个注意点。"><a href="#关于拖拉事件，有以下几个注意点。" class="headerlink" title="关于拖拉事件，有以下几个注意点。"></a>关于拖拉事件，有以下几个注意点。</h5><ul>
<li>拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发。</li>
<li>将文件从操作系统拖拉进浏览器，不会触发<code>dragstart</code>和<code>dragend</code>事件。</li>
<li><code>dragenter</code>和<code>dragover</code>事件的监听函数，用来取出拖拉的数据（即允许放下被拖拉的元素）。由于网页的大部分区域不适合作为放下拖拉元素的目标节点，所以这两个事件的默认设置为当前节点不允许接受被拖拉的元素。如果想要在目标节点上放下的数据，首先必须阻止这两个事件的默认行为。</li>
</ul>
<hr>
<h3 id="31-资源事件"><a href="#31-资源事件" class="headerlink" title="31.资源事件"></a>31.资源事件</h3><ul>
<li><code>beforeunload</code>事件在窗口、文档、各种资源将要卸载前触发。它可以用来防止用户不小心卸载资源。</li>
<li><code>unload</code>事件在窗口关闭或者<code>document</code>对象将要卸载时触发。它的触发顺序排在<code>beforeunload</code>、<code>pagehide</code>事件后面。<code>unload</code>事件发生时，文档处于一个特殊状态。所有资源依然存在，但是对用户来说都不可见，UI 互动全部无效。这个事件是无法取消的，即使在监听函数里面抛出错误，也不能停止文档的卸载</li>
<li><code>load</code>事件在页面或某个资源加载成功时触发。注意，页面或资源从浏览器缓存加载，并不会触发<code>load</code>事件。页面的<code>load</code>事件也可以用<code>pageshow</code>事件代替。</li>
<li><code>error</code>事件是在页面或资源加载失败时触发。</li>
<li><code>abort</code>事件在用户取消加载时触发。</li>
</ul>
<hr>
<h3 id="32-session历史事件"><a href="#32-session历史事件" class="headerlink" title="32.session历史事件"></a>32.<code>session</code>历史事件</h3><ul>
<li><code>pageshow</code>事件在页面加载时触发，包括第一次加载和从缓存加载两种情况。如果要指定页面每次加载（不管是不是从浏览器缓存）时都运行的代码，可以放在这个事件的监听函数。</li>
<li><code>pagehide</code>事件与<code>pageshow</code>事件类似，当用户通过“前进/后退”按钮，离开当前页面时触发。它与 unload 事件的区别在于，如果在 window 对象上定义<code>unload</code>事件的监听函数之后，页面不会保存在缓存中，而使用<code>pagehide</code>事件，页面会保存在缓存中。</li>
</ul>
<p>注意，这两个事件只在浏览器的<code>history</code>对象发生变化时触发，跟网页是否可见没有关系。</p>
<ul>
<li><p><code>popstate</code>事件在浏览器的<code>history</code>对象的当前记录发生显式切换时触发。注意，调用<code>history.pushState()</code>或<code>history.replaceState()</code>，并不会触发<code>popstate</code>事件。该事件只在用户在<code>history</code>记录之间显式切换时触发，比如鼠标点击“后退/前进”按钮，或者在脚本中调用<code>history.back()</code>、<code>history.forward()</code>、<code>history.go()</code>时触发。</p>
<p>该事件对象有一个<code>state</code>属性，保存<code>history.pushState</code>方法和<code>history.replaceState</code>方法为当前记录添加的<code>state</code>对象。</p>
</li>
<li><p><code>hashchange</code>事件在 URL 的 hash 部分（即<code>#</code>号后面的部分，包括<code>#</code>号）发生变化时触发。该事件一般在<code>window</code>对象上监听。</p>
<p><code>hashchange</code>的事件实例具有两个特有属性：<code>oldURL</code>属性和<code>newURL</code>属性，分别表示变化前后的完整 URL。</p>
</li>
</ul>
<hr>
<h3 id="33-网页状态事件"><a href="#33-网页状态事件" class="headerlink" title="33.网页状态事件"></a>33.网页状态事件</h3><ul>
<li><p>网页下载并解析完成以后，浏览器就会在<code>document</code>对象上触发 DOMContentLoaded 事件。这时，仅仅完成了网页的解析（整张页面的 DOM 生成了），所有外部资源（样式表、脚本、iframe 等等）可能还没有下载结束。也就是说，这个事件比<code>load</code>事件，发生时间早得多。</p>
<p>注意，网页的 JavaScript 脚本是同步执行的，脚本一旦发生堵塞，将推迟触发<code>DOMContentLoaded</code>事件。</p>
</li>
</ul>
<hr>
<h3 id="34-窗口事件"><a href="#34-窗口事件" class="headerlink" title="34.窗口事件"></a>34.窗口事件</h3><ul>
<li><p><code>scroll</code>事件在文档或文档元素滚动时触发，主要出现在用户拖动滚动条。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, callback);</span><br></pre></td></tr></table></figure>

<p>该事件会连续地大量触发，所以它的监听函数之中不应该有非常耗费计算的操作。推荐的做法是使用<code>requestAnimationFrame</code>或<code>setTimeout</code>控制该事件的触发频率，然后可以结合<code>customEvent</code>抛出一个新事件。</p>
</li>
<li><p><code>resize</code>事件在改变浏览器窗口大小时触发，主要发生在<code>window</code>对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resizeMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.body.clientWidth &lt; <span class="number">768</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;移动设备的视口&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, resizeMethod, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>该事件也会连续地大量触发，所以最好像上面的<code>scroll</code>事件一样，通过<code>throttle</code>函数控制事件触发频率。</p>
</li>
<li><p><code>fullscreenchange</code>事件在进入或退出全屏状态时触发，该事件发生在<code>document</code>对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;fullscreenchange&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">document</span>.fullscreenElement);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p><code>fullscreenerror</code>事件在浏览器无法切换到全屏状态时触发。</p>
</li>
</ul>
<hr>
<h3 id="35-剪切板事件"><a href="#35-剪切板事件" class="headerlink" title="35.剪切板事件"></a>35.剪切板事件</h3><p>以下三个事件属于剪贴板操作的相关事件。</p>
<ul>
<li><code>cut</code>：将选中的内容从文档中移除，加入剪贴板时触发。</li>
<li><code>copy</code>：进行复制动作时触发。</li>
<li><code>paste</code>：剪贴板内容粘贴到文档后触发。</li>
</ul>
<p>举例来说，如果希望禁止输入框的粘贴事件，可以使用下面的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputElement.addEventListener(<span class="string">&#x27;paste&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> e.preventDefault());</span><br></pre></td></tr></table></figure>

<p>上面的代码使得用户无法在<code>&lt;input&gt;</code>输入框里面粘贴内容。</p>
<p><code>cut</code>、<code>copy</code>、<code>paste</code>这三个事件的事件对象都是<code>ClipboardEvent</code>接口的实例。<code>ClipboardEvent</code>有一个实例属性<code>clipboardData</code>，是一个 DataTransfer 对象，存放剪贴的数据。具体的 API 接口和操作方法，请参见《拖拉事件》的 DataTransfer 对象部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;copy&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.clipboardData.setData(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">  e.clipboardData.setData(<span class="string">&#x27;text/html&#x27;</span>, <span class="string">&#x27;&lt;b&gt;Hello, world!&lt;/b&gt;&#x27;</span>);</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码使得复制进入剪贴板的，都是开发者指定的数据，而不是用户想要拷贝的数据。</p>
<hr>
<h3 id="36-焦点事件-FocusEvent"><a href="#36-焦点事件-FocusEvent" class="headerlink" title="36.焦点事件 FocusEvent"></a>36.焦点事件 FocusEvent</h3><p>焦点事件发生在元素节点和<code>document</code>对象上面，与获得或失去焦点相关。它主要包括以下四个事件。</p>
<ul>
<li><code>focus</code>：元素节点获得焦点后触发，该事件不会冒泡。</li>
<li><code>blur</code>：元素节点失去焦点后触发，该事件不会冒泡。</li>
<li><code>focusin</code>：元素节点将要获得焦点时触发，发生在<code>focus</code>事件之前。该事件会冒泡。</li>
<li><code>focusout</code>：元素节点将要失去焦点时触发，发生在<code>blur</code>事件之前。该事件会冒泡。</li>
</ul>
<hr>
<h3 id="37-CustomEvent-接口"><a href="#37-CustomEvent-接口" class="headerlink" title="37.CustomEvent 接口"></a>37.CustomEvent 接口</h3><p>CustomEvent 接口用于生成自定义的事件实例。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。</p>
<p>浏览器原生提供<code>CustomEvent()</code>构造函数，用来生成 CustomEvent 事件实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CustomEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>CustomEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。<code>CustomEvent</code>的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。</p>
<ul>
<li><code>detail</code>：表示事件的附带数据，默认为<code>null</code>。</li>
</ul>
<hr>
<h3 id="38-script-元素"><a href="#38-script-元素" class="headerlink" title="38.script 元素"></a>38.<code>script</code> 元素</h3><p>正常的网页加载流程是这样的。</p>
<ol>
<li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li>
<li>解析过程中，浏览器发现<code>&lt;script&gt;</code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</li>
<li>如果<code>&lt;script&gt;</code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li>
<li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li>
</ol>
<ul>
<li>为了解决脚本文件下载阻塞网页渲染的问题，一个方法是对<code>&lt;script&gt;</code>元素加入<code>defer</code>属性。它的作用是延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;a.js&quot;</span> defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决“阻塞效应”的另一个方法是对<code>&lt;script&gt;</code>元素加入<code>async</code>属性。它会并行下载脚本，先下载完的先执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;a.js&quot;</span> <span class="keyword">async</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>defer</code>属性和<code>async</code>属性到底应该使用哪一个？</p>
<p>一般来说，如果脚本之间没有依赖关系，就使用<code>async</code>属性，如果脚本之间有依赖关系，就使用<code>defer</code>属性。如果同时使用<code>async</code>和<code>defer</code>属性，后者不起作用，浏览器行为由<code>async</code>属性决定。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/record/">Home</a></li>
         
          <li><a href="/record/about/">About</a></li>
         
          <li><a href="/record/archives/">Writing</a></li>
         
          <li><a href="/record/categories/">categories</a></li>
         
          <li><a href="/record/tags/">Tag</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">0.前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-lable"><span class="toc-number">2.</span> <span class="toc-text">1.lable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%83%E5%B0%94%E5%80%BC"><span class="toc-number">3.</span> <span class="toc-text">2.布尔值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E5%80%BC"><span class="toc-number">4.</span> <span class="toc-text">3.数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">4. 字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">5.对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">6.0.1.</span> <span class="toc-text">对象属性的操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#in%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.0.2.</span> <span class="toc-text">in运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">6.函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#javaScript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">7.0.1.</span> <span class="toc-text">javaScript中的闭包的理解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%95%B0%E7%BB%84"><span class="toc-number">8.</span> <span class="toc-text">7.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E4%BC%BC%E6%95%B0%E7%BB%84%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.0.1.</span> <span class="toc-text">类似数组的对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.</span> <span class="toc-text">8.运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E9%94%99%E8%AF%AF%E6%9C%BA%E5%88%B6%E5%A4%84%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">9.错误机制处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-js%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E5%BB%BA%E8%AE%AE"><span class="toc-number">11.</span> <span class="toc-text">10. js编程风格建议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-console%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.</span> <span class="toc-text">11. console对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">12.0.1.</span> <span class="toc-text">控制台常见命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Js%E5%AF%B9%E8%B1%A1%E8%AE%A4%E8%AF%86"><span class="toc-number">12.0.2.</span> <span class="toc-text">Js对象认识</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Object%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.</span> <span class="toc-text">12.Object对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#proto-%E8%AF%B4%E6%98%8E"><span class="toc-number">13.0.1.</span> <span class="toc-text">__proto__说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Object-%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">13.0.2.</span> <span class="toc-text">Object 的实例方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">13.0.3.</span> <span class="toc-text">对象的拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Array%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.</span> <span class="toc-text">13.Array对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1"><span class="toc-number">15.</span> <span class="toc-text">14.包装对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Boolean-%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">16.</span> <span class="toc-text">15.Boolean 值得注意的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Number%E5%AF%B9%E8%B1%A1%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">17.</span> <span class="toc-text">16.Number对象值得注意的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-String%E5%AF%B9%E8%B1%A1%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">18.</span> <span class="toc-text">17.String对象值得注意的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-Math%E5%AF%B9%E8%B1%A1%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">19.</span> <span class="toc-text">18.Math对象值得注意的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Date%E5%AF%B9%E8%B1%A1%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">20.</span> <span class="toc-text">19.Date对象值得注意的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-JSON%E5%AF%B9%E8%B1%A1"><span class="toc-number">21.</span> <span class="toc-text">20.JSON对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">22.</span> <span class="toc-text">21.面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">22.0.1.</span> <span class="toc-text">严格模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-JavaScript%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">23.</span> <span class="toc-text">22.JavaScript的异步操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%9A%84%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">23.0.1.</span> <span class="toc-text">异步的操作模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">23.0.2.</span> <span class="toc-text">多个异步的流程控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">24.</span> <span class="toc-text">23.定时器相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91"><span class="toc-number">24.0.1.</span> <span class="toc-text">定时器的实现逻辑</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E9%98%B2%E6%8A%96%E5%A4%84%E7%90%86-debounce"><span class="toc-number">24.0.2.</span> <span class="toc-text">页面防抖处理 debounce</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-Promise%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">25.</span> <span class="toc-text">24.Promise对象（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">25.0.1.</span> <span class="toc-text">Promise对象的状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">25.0.2.</span> <span class="toc-text">构造函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-number">26.</span> <span class="toc-text">25.鼠标事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-number">27.</span> <span class="toc-text">26.键盘事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E8%BF%9B%E5%BA%A6%E4%BA%8B%E4%BB%B6"><span class="toc-number">28.</span> <span class="toc-text">27.进度事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6"><span class="toc-number">29.</span> <span class="toc-text">28.表单事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6"><span class="toc-number">30.</span> <span class="toc-text">29.触摸事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E6%8B%96%E6%8B%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">31.</span> <span class="toc-text">30.拖拉事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%8B%96%E6%8B%89%E4%BA%8B%E4%BB%B6%EF%BC%8C%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9%E3%80%82"><span class="toc-number">31.0.1.</span> <span class="toc-text">关于拖拉事件，有以下几个注意点。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E8%B5%84%E6%BA%90%E4%BA%8B%E4%BB%B6"><span class="toc-number">32.</span> <span class="toc-text">31.资源事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-session%E5%8E%86%E5%8F%B2%E4%BA%8B%E4%BB%B6"><span class="toc-number">33.</span> <span class="toc-text">32.session历史事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E7%BD%91%E9%A1%B5%E7%8A%B6%E6%80%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">34.</span> <span class="toc-text">33.网页状态事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E7%AA%97%E5%8F%A3%E4%BA%8B%E4%BB%B6"><span class="toc-number">35.</span> <span class="toc-text">34.窗口事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E5%89%AA%E5%88%87%E6%9D%BF%E4%BA%8B%E4%BB%B6"><span class="toc-number">36.</span> <span class="toc-text">35.剪切板事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6-FocusEvent"><span class="toc-number">37.</span> <span class="toc-text">36.焦点事件 FocusEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-CustomEvent-%E6%8E%A5%E5%8F%A3"><span class="toc-number">38.</span> <span class="toc-text">37.CustomEvent 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-script-%E5%85%83%E7%B4%A0"><span class="toc-number">39.</span> <span class="toc-text">38.script 元素</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&text=JavaScript基础知识笔记"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&title=JavaScript基础知识笔记"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&is_video=false&description=JavaScript基础知识笔记"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=JavaScript基础知识笔记&body=Check out this article: https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&title=JavaScript基础知识笔记"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&title=JavaScript基础知识笔记"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&title=JavaScript基础知识笔记"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&title=JavaScript基础知识笔记"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&name=JavaScript基础知识笔记&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://dianedii.github.io/2022/11/27/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0-1/&t=JavaScript基础知识笔记"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2018-2021
    戴安
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/record/">Home</a></li><!--
     --><!--
       --><li><a href="/record/about/">About</a></li><!--
     --><!--
       --><li><a href="/record/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/record/categories/">categories</a></li><!--
     --><!--
       --><li><a href="/record/tags/">Tag</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/record/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
